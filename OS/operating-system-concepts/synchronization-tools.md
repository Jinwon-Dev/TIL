> **협력적 프로세스**

→ ***시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나, 영향을 받는 프로세스***

- 논리 주소 공간을 직접 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다.
    - 하지만, **데이터를 공유 데이터를 동시에 접근하면 데이터의 일관성이 깨질 수 있다.**

</br>


> **논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하고, 데이터의 일관성을 유지하는 방법을 알아보자!**

</br>

## 1. 배경

→ ***이번 절에서는 프로세스가 병행, 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지 알아본다.***

</br>

> **유한 버퍼 문제**

→ ***0으로 초기화되어 있는 `count` 라는 정수형 변수를 추가한다.***

- 버퍼에 새 항목을 추가할 때마다 값을 증가시키고, 한 항목을 꺼낼 때마다 값을 감소시킨다.

</br>

- **생산자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156150-b9ba1d1d-5e51-4c98-bc66-ebd80ea16013.png">

</br>

- **소비자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156241-5f697ed4-7f12-4597-ad06-1add92c99d65.png">

</br>

> **생산자와 소비자 코드는 개별적으로는 올바를지라도, 병행적으로 수행시키면 올바르게 동작하지 않는다!**

- ex) `count` = 5, 생산자와 소비자는 `count++` 과 `count--` 를 병행하게 실행하는 상황
    - 수행 후의 결과는 `5` 가 아닌 `4` 나 `5` , `6` 이 된다.

</br>

> **`count` 변수 접근 연산의 기계어 구현**

<img width="155" alt="image" src="https://user-images.githubusercontent.com/106216912/213156424-8ae84027-6cfa-4315-8366-636b213f9927.png">

→ `register1` , `register2` 는 한 CPU만 접근할 수 있는 레지스터 중 하나이다.

</br>

- `count++` 와 `count--` 를 병행하게 실행하는 것은, 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 같다.
    - 두 개의 프로세스가 동시에 변수 `count` 를 조작하도록 허용해서 **부정확한 상태**에 도달하였다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/106216912/213156555-66328c13-e078-4f63-8fc2-a0ad697050d3.png">

</br>

> **경쟁 상황**

→ ***동시에 여러 개의 프로세스가 동일한 자료를 접근해서 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황***

- 따라서, 한 순간에 하나의 프로세스만이 `count` 를 조작하도록 보장해야 한다.
    - 프로세스들이 **동기화되도록** 해야 한다!

---

## 2. 임계구역 문제

> **임계구역(critical section)** 

→ ***각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고, 갱신할 수 있다.***

- **특징 : 한 프로세스가 자신의 임계구역에서 수행하는 동안은, 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다!**
    
    → **즉, 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없다.**
    
</br>

> **임계구역 문제 : 프로세스들이 데이터를 협력적으로 공유하기 위해, 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것**

</br>

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/213166520-a3f08a2d-96d8-43d6-9992-ac5bca4f13a5.png">

- **진입 구역(entry section)**
    - 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다.

</br>

- **나머지 구역(remainder section)**
    - 코드의 나머지 부분

</br>

> **임계구역 문제에 대한 해결안은 세 가지 요구 조건을 충족해야 한다.**

1. **상호 배제(mutual exclusion)**
    - 한 프로세스가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.

</br>

2. **진행(progress)**
    - 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 임계구역에 진입할 프로세스를 결정하는 데 참여할 수 있다.
        - 이 선택은 무한정 연기될 수 없다.

</br>

3. **한정된 대기(bounded waiting)**
    - 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지, 다른 프로세스들이 그들의 임계구역에 진입하도록 허용하는 횟수에 한계가 있어야 한다.

</br>

> **임의의 한 순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있다.**

→ ***운영체제를 구현하는 코드는 경쟁 조건이 발생하기 쉽다!***

- ex) 두 프로세스가 동시에 파일을 열려고 하면, 리스트에 대한 개별적인 갱신은 경쟁 조건을 일으킬 수 있다.

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/213166834-c81ee87d-a0da-478b-bef4-07c10deb1a90.png">

- ex) 두 프로세스가 `fork()` 시스템 콜을 호출하여 자식 프로세스를 생성하고, `pid` 를 부모 프로세스로 반환하는 상황
    - 상호 배제가 제공되지 않으면, 동일한 프로세스 식별자 번호가 두 개의 다른 프로세스에 배정될 수 있다.

</br>

- 경쟁 조건이 발생하기 쉬운 커널 자료구조
    - 메모리 할당을 관리하는 자료구조
    - 프로세스 리스트를 유지하는 자료구조
    - 인터럽트 처리를 위한 자료구조

</br>

> **단일 코어 환경에서는 공유 변수를 수정하는 동안 인터럽트가 발생하는 것을 막을 수 있다면, 임계구역 문제는 간단히 해결된다.**

→ 하지만, 다중 처리기 환경에서는 실현할 수 없다!

</br>

> **임계구역을 다루기 위해 선점형 커널, 비선점형 커널 두 가지 일반적인 접근법이 사용된다.**

- **선점형 커널**
    - **프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용**한다.
    - 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.

</br>

- **비선점형 커널**
    - **커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.**
    - 커널 모드 프로세스는 커널을 빠져 나가거나 봉쇄될 때까지, 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.
    - 한순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로, 경쟁 조건을 염려할 필요가 없다.

</br>

→ **그렇다면 왜 비선점형 커널보다 선점형 커널이 선호되는가?**

- 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에, **응답이 더 민첩**할 수 있다.
    - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에, **실시간 프로그래밍에 더 적당**하다.

---

## 3. Peterson의 해결안

→ ***임계구역에 대한 고전적인 소프트웨어 기반 해결책이다.***

- 현대 컴퓨터 구조에서 올바르게 실행된다고 보장할 수는 없다.

</br>

- Peterson의 해결안은 **임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스**로 한정된다.
    - 프로세스는 P0, P1로 번호를 매긴다.
    - 한 프로세스 = Pi, 다른 프로세스 = Pj, `j = 1 - i`

</br>

> **Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유하도록 해서 해결한다!**

<img width="137" alt="image" src="https://user-images.githubusercontent.com/106216912/213174761-00976d72-7dd9-4f58-a66c-b7df6f7d7f0b.png">

- `turn` : 임계구역으로 진입할 순번
    - `turn == i` 이면 프로세스 Pi가 임계구역에서 실행될 수 있다.

</br>

- `flag` 배열 : 프로세스가 임계구역으로 진입할 준비가 되었다는 것

</br>

> **알고리즘**

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213175015-53700167-3531-4f6a-a92e-42193f174f6d.png">

- 임계구역으로 진입하기 위해서 Pi는 먼저 `flag[i]` 를 참으로 만들고, `turn` 을 `j` 로 지정한다.
    - 프로세스 `j` 가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다.

</br>

- 만약 두 프로세스가 동시에 진입하기를 원한다면 `turn` 은 거의 동시에 `i` 와 `j` 로 지정될 것이다.
    - 그러나 둘 중 오직 한 배정만이 지속되고, `turn` 의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결정한다.

</br>

> **해결책이 올바르게 동작한다는 것을 증명해야 한다.**

→ ***세 가지 조건을 모두 충족하는가?***

1. **상호 배제가 제대로 지켜진다는 사실**
    - Pi가 임계구역에 들어가려면 반드시 `flag[j] == false` 이거나, `turn == i` 여야 한다.
    - 두 프로세스가 동시에 임계구역에서 수행 중이라면 `flag[0] == flag[1] == true` 로 지정해야 한다.

</br>

2. **진행에 대한 요구 조건을 만족한다는 사실**
    - Pi가 요청했을 때 이미 Pj가 임계구역을 수행 중이면, `flag[j] == true` 이고 `turn = j` 이므로 Pi는 기다린다.
    - 그 후, Pj가 임계구역을 벗어나는 순간 `flag[j] == false` 를 만들어 주어 Pi가 임계구역에 진입하게 된다.

</br>

3. **대기 시간이 한없이 길어지지 않는다는 사실**
    - Pi는 Pj가 지난번에 진입했다면, 이번에는 Pj가 나머지 구역을 수행 중이더라도 한번은 임계구역에 들어갈 수 있게 보장된다.

</br>

> **Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다.**

→ ***시스템 성능을 향상하기 위해 프로세스 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬 할 수 있다.***

</br>

- 데이터를 공유하는 다중 스레드 프로그램의 경우, **명령 순서가 바뀌게 되면 데이터의 일관성이 깨지거나 예기치 못한 결과**를 낳을 수 있다.
    - ex) 두 스레드 간에 공유되는 데이터

<img width="191" alt="image" src="https://user-images.githubusercontent.com/106216912/213175255-8fd9083b-85c1-4e53-a38a-00606fb1c452.png">

</br>

- Thread 1은 다음 명령문을 수행한다.

<img width="116" alt="image" src="https://user-images.githubusercontent.com/106216912/213175361-483f727e-276f-4f39-bf6d-8814e555f50e.png">

</br>

- Thread 2는 다음 명령문을 수행한다.

<img width="110" alt="image" src="https://user-images.githubusercontent.com/106216912/213175439-6465e6cd-e367-448e-8164-58f11e2eeefd.png">

</br>

→ `flag` 와 `x` 사이에 데이터 종속성이 없으므로, 프로세서가 Thread 2의 명령어를 재정렬하여 `x = 100` 을 배정하기 전에, `flag` 가 `true` 로 지정될 수 있다.

- Thread 1은 `x` 에 대해 0을 출력할 수 있다.

</br>

> **이러한 사실에 Peterson의 해결안에 어떤 영향을 미치는가?**

→ ***두 스레드가 동시에 임계구역에서 활성화될 수 있다.***

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/213175547-635e34c9-5404-4d17-83e6-a940b4906365.png">

</br>

- 상호 배제를 유지하는 유일한 방법 : 적절한 동기화 도구를 사용하는 것

---