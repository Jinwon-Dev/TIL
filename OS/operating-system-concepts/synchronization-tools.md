> **협력적 프로세스**

→ ***시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나, 영향을 받는 프로세스***

- 논리 주소 공간을 직접 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다.
    - 하지만, **데이터를 공유 데이터를 동시에 접근하면 데이터의 일관성이 깨질 수 있다.**

</br>


> **논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하고, 데이터의 일관성을 유지하는 방법을 알아보자!**

</br>

## 1. 배경

→ ***이번 절에서는 프로세스가 병행, 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지 알아본다.***

</br>

> **유한 버퍼 문제**

→ ***0으로 초기화되어 있는 `count` 라는 정수형 변수를 추가한다.***

- 버퍼에 새 항목을 추가할 때마다 값을 증가시키고, 한 항목을 꺼낼 때마다 값을 감소시킨다.

</br>

- **생산자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156150-b9ba1d1d-5e51-4c98-bc66-ebd80ea16013.png">

</br>

- **소비자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156241-5f697ed4-7f12-4597-ad06-1add92c99d65.png">

</br>

> **생산자와 소비자 코드는 개별적으로는 올바를지라도, 병행적으로 수행시키면 올바르게 동작하지 않는다!**

- ex) `count` = 5, 생산자와 소비자는 `count++` 과 `count--` 를 병행하게 실행하는 상황
    - 수행 후의 결과는 `5` 가 아닌 `4` 나 `5` , `6` 이 된다.

</br>

> **`count` 변수 접근 연산의 기계어 구현**

<img width="155" alt="image" src="https://user-images.githubusercontent.com/106216912/213156424-8ae84027-6cfa-4315-8366-636b213f9927.png">

→ `register1` , `register2` 는 한 CPU만 접근할 수 있는 레지스터 중 하나이다.

</br>

- `count++` 와 `count--` 를 병행하게 실행하는 것은, 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 같다.
    - 두 개의 프로세스가 동시에 변수 `count` 를 조작하도록 허용해서 **부정확한 상태**에 도달하였다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/106216912/213156555-66328c13-e078-4f63-8fc2-a0ad697050d3.png">

</br>

> **경쟁 상황**

→ ***동시에 여러 개의 프로세스가 동일한 자료를 접근해서 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황***

- 따라서, 한 순간에 하나의 프로세스만이 `count` 를 조작하도록 보장해야 한다.
    - 프로세스들이 **동기화되도록** 해야 한다!

---