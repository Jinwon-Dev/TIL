> **협력적 프로세스**

→ ***시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나, 영향을 받는 프로세스***

- 논리 주소 공간을 직접 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다.
    - 하지만, **데이터를 공유 데이터를 동시에 접근하면 데이터의 일관성이 깨질 수 있다.**

</br>


> **논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하고, 데이터의 일관성을 유지하는 방법을 알아보자!**

</br>

## 1. 배경

→ ***이번 절에서는 프로세스가 병행, 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지 알아본다.***

</br>

> **유한 버퍼 문제**

→ ***0으로 초기화되어 있는 `count` 라는 정수형 변수를 추가한다.***

- 버퍼에 새 항목을 추가할 때마다 값을 증가시키고, 한 항목을 꺼낼 때마다 값을 감소시킨다.

</br>

- **생산자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156150-b9ba1d1d-5e51-4c98-bc66-ebd80ea16013.png">

</br>

- **소비자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156241-5f697ed4-7f12-4597-ad06-1add92c99d65.png">

</br>

> **생산자와 소비자 코드는 개별적으로는 올바를지라도, 병행적으로 수행시키면 올바르게 동작하지 않는다!**

- ex) `count` = 5, 생산자와 소비자는 `count++` 과 `count--` 를 병행하게 실행하는 상황
    - 수행 후의 결과는 `5` 가 아닌 `4` 나 `5` , `6` 이 된다.

</br>

> **`count` 변수 접근 연산의 기계어 구현**

<img width="155" alt="image" src="https://user-images.githubusercontent.com/106216912/213156424-8ae84027-6cfa-4315-8366-636b213f9927.png">

→ `register1` , `register2` 는 한 CPU만 접근할 수 있는 레지스터 중 하나이다.

</br>

- `count++` 와 `count--` 를 병행하게 실행하는 것은, 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 같다.
    - 두 개의 프로세스가 동시에 변수 `count` 를 조작하도록 허용해서 **부정확한 상태**에 도달하였다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/106216912/213156555-66328c13-e078-4f63-8fc2-a0ad697050d3.png">

</br>

> **경쟁 상황**

→ ***동시에 여러 개의 프로세스가 동일한 자료를 접근해서 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황***

- 따라서, 한 순간에 하나의 프로세스만이 `count` 를 조작하도록 보장해야 한다.
    - 프로세스들이 **동기화되도록** 해야 한다!

---

## 2. 임계구역 문제

> **임계구역(critical section)** 

→ ***각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고, 갱신할 수 있다.***

- **특징 : 한 프로세스가 자신의 임계구역에서 수행하는 동안은, 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다!**
    
    → **즉, 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없다.**
    
</br>

> **임계구역 문제 : 프로세스들이 데이터를 협력적으로 공유하기 위해, 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것**

</br>

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/213166520-a3f08a2d-96d8-43d6-9992-ac5bca4f13a5.png">

- **진입 구역(entry section)**
    - 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다.

</br>

- **나머지 구역(remainder section)**
    - 코드의 나머지 부분

</br>

> **임계구역 문제에 대한 해결안은 세 가지 요구 조건을 충족해야 한다.**

1. **상호 배제(mutual exclusion)**
    - 한 프로세스가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.

</br>

2. **진행(progress)**
    - 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 임계구역에 진입할 프로세스를 결정하는 데 참여할 수 있다.
        - 이 선택은 무한정 연기될 수 없다.

</br>

3. **한정된 대기(bounded waiting)**
    - 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지, 다른 프로세스들이 그들의 임계구역에 진입하도록 허용하는 횟수에 한계가 있어야 한다.

</br>

> **임의의 한 순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있다.**

→ ***운영체제를 구현하는 코드는 경쟁 조건이 발생하기 쉽다!***

- ex) 두 프로세스가 동시에 파일을 열려고 하면, 리스트에 대한 개별적인 갱신은 경쟁 조건을 일으킬 수 있다.

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/213166834-c81ee87d-a0da-478b-bef4-07c10deb1a90.png">

- ex) 두 프로세스가 `fork()` 시스템 콜을 호출하여 자식 프로세스를 생성하고, `pid` 를 부모 프로세스로 반환하는 상황
    - 상호 배제가 제공되지 않으면, 동일한 프로세스 식별자 번호가 두 개의 다른 프로세스에 배정될 수 있다.

</br>

- 경쟁 조건이 발생하기 쉬운 커널 자료구조
    - 메모리 할당을 관리하는 자료구조
    - 프로세스 리스트를 유지하는 자료구조
    - 인터럽트 처리를 위한 자료구조

</br>

> **단일 코어 환경에서는 공유 변수를 수정하는 동안 인터럽트가 발생하는 것을 막을 수 있다면, 임계구역 문제는 간단히 해결된다.**

→ 하지만, 다중 처리기 환경에서는 실현할 수 없다!

</br>

> **임계구역을 다루기 위해 선점형 커널, 비선점형 커널 두 가지 일반적인 접근법이 사용된다.**

- **선점형 커널**
    - **프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용**한다.
    - 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.

</br>

- **비선점형 커널**
    - **커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.**
    - 커널 모드 프로세스는 커널을 빠져 나가거나 봉쇄될 때까지, 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.
    - 한순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로, 경쟁 조건을 염려할 필요가 없다.

</br>

→ **그렇다면 왜 비선점형 커널보다 선점형 커널이 선호되는가?**

- 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에, **응답이 더 민첩**할 수 있다.
    - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에, **실시간 프로그래밍에 더 적당**하다.

---

## 3. Peterson의 해결안

→ ***임계구역에 대한 고전적인 소프트웨어 기반 해결책이다.***

- 현대 컴퓨터 구조에서 올바르게 실행된다고 보장할 수는 없다.

</br>

- Peterson의 해결안은 **임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스**로 한정된다.
    - 프로세스는 P0, P1로 번호를 매긴다.
    - 한 프로세스 = Pi, 다른 프로세스 = Pj, `j = 1 - i`

</br>

> **Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유하도록 해서 해결한다!**

<img width="137" alt="image" src="https://user-images.githubusercontent.com/106216912/213174761-00976d72-7dd9-4f58-a66c-b7df6f7d7f0b.png">

- `turn` : 임계구역으로 진입할 순번
    - `turn == i` 이면 프로세스 Pi가 임계구역에서 실행될 수 있다.

</br>

- `flag` 배열 : 프로세스가 임계구역으로 진입할 준비가 되었다는 것

</br>

> **알고리즘**

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213175015-53700167-3531-4f6a-a92e-42193f174f6d.png">

- 임계구역으로 진입하기 위해서 Pi는 먼저 `flag[i]` 를 참으로 만들고, `turn` 을 `j` 로 지정한다.
    - 프로세스 `j` 가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다.

</br>

- 만약 두 프로세스가 동시에 진입하기를 원한다면 `turn` 은 거의 동시에 `i` 와 `j` 로 지정될 것이다.
    - 그러나 둘 중 오직 한 배정만이 지속되고, `turn` 의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결정한다.

</br>

> **해결책이 올바르게 동작한다는 것을 증명해야 한다.**

→ ***세 가지 조건을 모두 충족하는가?***

1. **상호 배제가 제대로 지켜진다는 사실**
    - Pi가 임계구역에 들어가려면 반드시 `flag[j] == false` 이거나, `turn == i` 여야 한다.
    - 두 프로세스가 동시에 임계구역에서 수행 중이라면 `flag[0] == flag[1] == true` 로 지정해야 한다.

</br>

2. **진행에 대한 요구 조건을 만족한다는 사실**
    - Pi가 요청했을 때 이미 Pj가 임계구역을 수행 중이면, `flag[j] == true` 이고 `turn = j` 이므로 Pi는 기다린다.
    - 그 후, Pj가 임계구역을 벗어나는 순간 `flag[j] == false` 를 만들어 주어 Pi가 임계구역에 진입하게 된다.

</br>

3. **대기 시간이 한없이 길어지지 않는다는 사실**
    - Pi는 Pj가 지난번에 진입했다면, 이번에는 Pj가 나머지 구역을 수행 중이더라도 한번은 임계구역에 들어갈 수 있게 보장된다.

</br>

> **Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다.**

→ ***시스템 성능을 향상하기 위해 프로세스 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬 할 수 있다.***

</br>

- 데이터를 공유하는 다중 스레드 프로그램의 경우, **명령 순서가 바뀌게 되면 데이터의 일관성이 깨지거나 예기치 못한 결과**를 낳을 수 있다.
    - ex) 두 스레드 간에 공유되는 데이터

<img width="191" alt="image" src="https://user-images.githubusercontent.com/106216912/213175255-8fd9083b-85c1-4e53-a38a-00606fb1c452.png">

</br>

- Thread 1은 다음 명령문을 수행한다.

<img width="116" alt="image" src="https://user-images.githubusercontent.com/106216912/213175361-483f727e-276f-4f39-bf6d-8814e555f50e.png">

</br>

- Thread 2는 다음 명령문을 수행한다.

<img width="110" alt="image" src="https://user-images.githubusercontent.com/106216912/213175439-6465e6cd-e367-448e-8164-58f11e2eeefd.png">

</br>

→ `flag` 와 `x` 사이에 데이터 종속성이 없으므로, 프로세서가 Thread 2의 명령어를 재정렬하여 `x = 100` 을 배정하기 전에, `flag` 가 `true` 로 지정될 수 있다.

- Thread 1은 `x` 에 대해 0을 출력할 수 있다.

</br>

> **이러한 사실에 Peterson의 해결안에 어떤 영향을 미치는가?**

→ ***두 스레드가 동시에 임계구역에서 활성화될 수 있다.***

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/213175547-635e34c9-5404-4d17-83e6-a940b4906365.png">

</br>

- 상호 배제를 유지하는 유일한 방법 : 적절한 동기화 도구를 사용하는 것

---

## 4. 동기화를 위한 하드웨어 지원

→ ***소프트웨어 기반 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있으므로, 임계구역 문제를 해결하기 위한 지원을 제공하는 세 가지 하드웨어 명령어를 제시한다.***

- 이러한 프리미티브 연산은 동기화 도구로 직접 사용될 수 있거나, 더 추상적인 동기화 기법의 기초 형태로 사용될 수 있다.

</br>

### 메모리 장벽

→ ***메모리 모델 : 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식***

1. **강한 순서**
    - 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임

</br>

2. **약한 순서**
    - 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음

</br>

> **메모리 모델은 프로세서 유형에 따라 다르므로, 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.**

- **메모리 장벽** : **메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공해서, 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장하는 것**
    - 시스템은 후속 적재, 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다.

</br>

- 위의 예제 에서 스레드 1에 메모리 장벽 연산을 추가하면, `flag` 값이 `x` 값 보다 먼저 적재되도록 보장한다.

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/213187383-e9699996-bcb5-4e9f-986d-fbcec6765d21.png">

</br>

- 스레드 2도 동일하게 메모리 장벽을 넣으면, `flag` 에 배정하기 전에 `x` 에 대한 배정이 먼저 실행되도록 한다.

<img width="137" alt="image" src="https://user-images.githubusercontent.com/106216912/213187459-cf53e1c7-8a52-4564-84f4-f7e39c696237.png">

</br>

→ 메모리 장벽을 배치하여 작업의 재정렬을 피할 수 있지만, **메모리 장벽은 매우 낮은 수준의 연산으로 간주**한다.

</br>

### 하드웨어 명령어

→ ***많은 현대 기계들은 한 워드의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어들을 제공한다.***

</br>

> **`test_and_set()`**

→ **원자적(atomically)으로 실행된다.**

- 두 개의 `test_and_set()` 명령어가 동시에 실행된다면, 어떤 임의의 순서로 순차적으로 실행될 것이다.

<img width="345" alt="image" src="https://user-images.githubusercontent.com/106216912/213187667-e739b676-31b4-42e6-9862-3277efc905b0.png">

</br>

- 기계가 `test_and_set()` 명령어를 지원한다면, `false` 로 초기화되는 `lock` 이라는 `boolean` 변수를 선언해서 상호 배제를 구현할 수 있다.
    - `acquire lock` , `release lock`

<img width="248" alt="image" src="https://user-images.githubusercontent.com/106216912/213187754-1ccc4bd4-c31b-493a-86e2-24e34d6cd345.png">

</br>

> **`compare_and_swap()`**

→ ***두 개의 워드에 대해 원자적인 연산을 하지만, 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.***

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/213187915-ba605c6b-e7b1-489b-9585-fa1b8afc1e62.png">

- 피연산자 `value` 는 오직 수식이 참일 때만 `new_value` 로 지정된다.
    - 어떠한 경우에든 CAS 명령어는 언제나 `value` 의 원래 값을 반환한다.

</br>

→ 두 개의 CAS 명령이 동시에 실행되면 임의의 순서로 순차적으로 실행된다.

</br>

- 전역 변수 `lock` 이 선언되고 `0` 으로 초기화된다.
    - `lock` 을 `1` 로 지정한다.
    - `lock` 의 원래 값이 `expected` 와 같으므로, 프로세스는 임계구역으로 들어간다.

</br>

<img width="342" alt="image" src="https://user-images.githubusercontent.com/106216912/213188075-d8fb4f65-fa83-45d8-8782-6effb1d81006.png">

- 이후의 `compare_and_swap()` 호출은 현재 `lock` 의 값이 기대값 `0` 과 같지 않기 때문에 성공하지 못한다.
    - 프로세스가 임계구역을 빠져나올 때 `lock` 을 `0` 으로 변경하고, 다른 프로세스가 임계구역을 들어갈 수 있게 허용한다.

</br>

> **임계구역 요구 조건을 모두 만족시키는 `compare_and_swap()` 명령어를 이용한 또다른 알고리즘**

<img width="292" alt="image" src="https://user-images.githubusercontent.com/106216912/213188194-c70bb3c7-bd93-43c8-91a9-3a10fd9b9583.png">

</br>

- 공통 데이터는 다음과 같고, `waiting` 배열의 원소는 `false` 로 초기화되고, `lock` 은 `0` 으로 초기화된다.

<img width="151" alt="image" src="https://user-images.githubusercontent.com/106216912/213188310-a100a15d-a54d-4f82-bf40-5a7fa4e30f7a.png">

</br>

- 이 알고리즘이 **상호 배제 조건**을 만족시킨다는 것을 증명하기 위해서는, Pi가 임계구역에 진입하는 경우는 오직 `waiting[i] == false` 이던지, `key == 0` 이어야 한다.
    - `key` 는 `compare_and_swap()` 을 실행했을 경우에만 `0` 이 된다.
    - 다른 프로세스들은 모두 기다려야 한다.
    - `waiting[i]` 가 `false` 가 되는 것은 다른 프로세스가 임계구역을 떠날 때뿐이다.

</br>

→ **이 때, 오직 한 개의 `waiting[i]` 만이 `false` 로 지정되고, 상호 배제가 보장된다.**

</br>

- **Progress 조건**이 만족함을 보이기 위해서는, 임계구역을 떠나는 프로세스는 `lock` 을 `0` 으로 하던지 `waiting[j]` 를 `false` 로 한다.
    - **어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어 준다.**

</br>

- **한정된 대기 조건**을 만족시킴을 증명하기 위해서는, 한 프로세스가 임계구역을 떠날 때는 `waiting` 배열을 순회하면서 흝어본다는 사실에 착안하면 된다.
    - 순환하면서 조사하여 `waiting[j] == true` 이면서 위 순환 순서 중 첫 번째 프로세스가 임계구역에 들어가게 된다.

</br>

→ **임계구역에 들어가고자 하는 프로세스는 최대한 `n-1` 회만 양보하면 들어갈 수 있다.**

</br>

### 원자적 변수

→ ***`compare_and_swap()` 같은 하드웨어 명령어는 상호 배제를 제공하기 위해 직접 사용되지 않고, 임계구역 문제를 해결하는 다른 도구를 구축하기 위한 기본 구성요소로 사용된다.***

- **원자적 변수(atomic variable)**
    - 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.
    - 갱신되는 동안 단일 변수에 대한 데이터 경쟁에 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용된다.

</br>

> **원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라, 특별한 원자적 데이터 유형을 제공한다.**

- ex) 다음은 원자적 정수 `sequence` 를 증가시킨다.

<img width="197" alt="image" src="https://user-images.githubusercontent.com/106216912/213188592-f345af27-96cc-41f2-94de-5c55e7ba0c6c.png">

</br>

- `incremental()` 함수는 CAS 명령어를 사용하여 구현된다.

<img width="387" alt="image" src="https://user-images.githubusercontent.com/106216912/213188685-249ae9db-bacc-462d-bbd6-6b9c0e32bdec.png">

</br>

→ **원자적 변수는 원자적 갱신을 제공하지만, 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다.**

- 카운터 및 시퀀스 생성기와 같은 공유 데이터 한 개의 갱신에만 제한되는 경우가 많다.

---