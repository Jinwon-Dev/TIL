> **협력적 프로세스**

→ ***시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나, 영향을 받는 프로세스***

- 논리 주소 공간을 직접 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다.
    - 하지만, **데이터를 공유 데이터를 동시에 접근하면 데이터의 일관성이 깨질 수 있다.**

</br>


> **논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하고, 데이터의 일관성을 유지하는 방법을 알아보자!**

</br>

## 1. 배경

→ ***이번 절에서는 프로세스가 병행, 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지 알아본다.***

</br>

> **유한 버퍼 문제**

→ ***0으로 초기화되어 있는 `count` 라는 정수형 변수를 추가한다.***

- 버퍼에 새 항목을 추가할 때마다 값을 증가시키고, 한 항목을 꺼낼 때마다 값을 감소시킨다.

</br>

- **생산자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156150-b9ba1d1d-5e51-4c98-bc66-ebd80ea16013.png">

</br>

- **소비자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156241-5f697ed4-7f12-4597-ad06-1add92c99d65.png">

</br>

> **생산자와 소비자 코드는 개별적으로는 올바를지라도, 병행적으로 수행시키면 올바르게 동작하지 않는다!**

- ex) `count` = 5, 생산자와 소비자는 `count++` 과 `count--` 를 병행하게 실행하는 상황
    - 수행 후의 결과는 `5` 가 아닌 `4` 나 `5` , `6` 이 된다.

</br>

> **`count` 변수 접근 연산의 기계어 구현**

<img width="155" alt="image" src="https://user-images.githubusercontent.com/106216912/213156424-8ae84027-6cfa-4315-8366-636b213f9927.png">

→ `register1` , `register2` 는 한 CPU만 접근할 수 있는 레지스터 중 하나이다.

</br>

- `count++` 와 `count--` 를 병행하게 실행하는 것은, 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 같다.
    - 두 개의 프로세스가 동시에 변수 `count` 를 조작하도록 허용해서 **부정확한 상태**에 도달하였다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/106216912/213156555-66328c13-e078-4f63-8fc2-a0ad697050d3.png">

</br>

> **경쟁 상황**

→ ***동시에 여러 개의 프로세스가 동일한 자료를 접근해서 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황***

- 따라서, 한 순간에 하나의 프로세스만이 `count` 를 조작하도록 보장해야 한다.
    - 프로세스들이 **동기화되도록** 해야 한다!

---

## 2. 임계구역 문제

> **임계구역(critical section)** 

→ ***각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고, 갱신할 수 있다.***

- **특징 : 한 프로세스가 자신의 임계구역에서 수행하는 동안은, 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다!**
    
    → **즉, 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없다.**
    
</br>

> **임계구역 문제 : 프로세스들이 데이터를 협력적으로 공유하기 위해, 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것**

</br>

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/213166520-a3f08a2d-96d8-43d6-9992-ac5bca4f13a5.png">

- **진입 구역(entry section)**
    - 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다.

</br>

- **나머지 구역(remainder section)**
    - 코드의 나머지 부분

</br>

> **임계구역 문제에 대한 해결안은 세 가지 요구 조건을 충족해야 한다.**

1. **상호 배제(mutual exclusion)**
    - 한 프로세스가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.

</br>

2. **진행(progress)**
    - 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 임계구역에 진입할 프로세스를 결정하는 데 참여할 수 있다.
        - 이 선택은 무한정 연기될 수 없다.

</br>

3. **한정된 대기(bounded waiting)**
    - 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지, 다른 프로세스들이 그들의 임계구역에 진입하도록 허용하는 횟수에 한계가 있어야 한다.

</br>

> **임의의 한 순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있다.**

→ ***운영체제를 구현하는 코드는 경쟁 조건이 발생하기 쉽다!***

- ex) 두 프로세스가 동시에 파일을 열려고 하면, 리스트에 대한 개별적인 갱신은 경쟁 조건을 일으킬 수 있다.

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/213166834-c81ee87d-a0da-478b-bef4-07c10deb1a90.png">

- ex) 두 프로세스가 `fork()` 시스템 콜을 호출하여 자식 프로세스를 생성하고, `pid` 를 부모 프로세스로 반환하는 상황
    - 상호 배제가 제공되지 않으면, 동일한 프로세스 식별자 번호가 두 개의 다른 프로세스에 배정될 수 있다.

</br>

- 경쟁 조건이 발생하기 쉬운 커널 자료구조
    - 메모리 할당을 관리하는 자료구조
    - 프로세스 리스트를 유지하는 자료구조
    - 인터럽트 처리를 위한 자료구조

</br>

> **단일 코어 환경에서는 공유 변수를 수정하는 동안 인터럽트가 발생하는 것을 막을 수 있다면, 임계구역 문제는 간단히 해결된다.**

→ 하지만, 다중 처리기 환경에서는 실현할 수 없다!

</br>

> **임계구역을 다루기 위해 선점형 커널, 비선점형 커널 두 가지 일반적인 접근법이 사용된다.**

- **선점형 커널**
    - **프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용**한다.
    - 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.

</br>

- **비선점형 커널**
    - **커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.**
    - 커널 모드 프로세스는 커널을 빠져 나가거나 봉쇄될 때까지, 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.
    - 한순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로, 경쟁 조건을 염려할 필요가 없다.

</br>

→ **그렇다면 왜 비선점형 커널보다 선점형 커널이 선호되는가?**

- 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에, **응답이 더 민첩**할 수 있다.
    - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에, **실시간 프로그래밍에 더 적당**하다.

---

## 3. Peterson의 해결안

→ ***임계구역에 대한 고전적인 소프트웨어 기반 해결책이다.***

- 현대 컴퓨터 구조에서 올바르게 실행된다고 보장할 수는 없다.

</br>

- Peterson의 해결안은 **임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스**로 한정된다.
    - 프로세스는 P0, P1로 번호를 매긴다.
    - 한 프로세스 = Pi, 다른 프로세스 = Pj, `j = 1 - i`

</br>

> **Peterson의 해결안은 두 프로세스가 두 개의 데이터 항목을 공유하도록 해서 해결한다!**

<img width="137" alt="image" src="https://user-images.githubusercontent.com/106216912/213174761-00976d72-7dd9-4f58-a66c-b7df6f7d7f0b.png">

- `turn` : 임계구역으로 진입할 순번
    - `turn == i` 이면 프로세스 Pi가 임계구역에서 실행될 수 있다.

</br>

- `flag` 배열 : 프로세스가 임계구역으로 진입할 준비가 되었다는 것

</br>

> **알고리즘**

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213175015-53700167-3531-4f6a-a92e-42193f174f6d.png">

- 임계구역으로 진입하기 위해서 Pi는 먼저 `flag[i]` 를 참으로 만들고, `turn` 을 `j` 로 지정한다.
    - 프로세스 `j` 가 임계구역으로 진입하기를 원한다면 진입 가능하다는 것을 보장한다.

</br>

- 만약 두 프로세스가 동시에 진입하기를 원한다면 `turn` 은 거의 동시에 `i` 와 `j` 로 지정될 것이다.
    - 그러나 둘 중 오직 한 배정만이 지속되고, `turn` 의 궁극적인 값이 둘 중 누가 먼저 임계구역으로 진입할 것인가를 결정한다.

</br>

> **해결책이 올바르게 동작한다는 것을 증명해야 한다.**

→ ***세 가지 조건을 모두 충족하는가?***

1. **상호 배제가 제대로 지켜진다는 사실**
    - Pi가 임계구역에 들어가려면 반드시 `flag[j] == false` 이거나, `turn == i` 여야 한다.
    - 두 프로세스가 동시에 임계구역에서 수행 중이라면 `flag[0] == flag[1] == true` 로 지정해야 한다.

</br>

2. **진행에 대한 요구 조건을 만족한다는 사실**
    - Pi가 요청했을 때 이미 Pj가 임계구역을 수행 중이면, `flag[j] == true` 이고 `turn = j` 이므로 Pi는 기다린다.
    - 그 후, Pj가 임계구역을 벗어나는 순간 `flag[j] == false` 를 만들어 주어 Pi가 임계구역에 진입하게 된다.

</br>

3. **대기 시간이 한없이 길어지지 않는다는 사실**
    - Pi는 Pj가 지난번에 진입했다면, 이번에는 Pj가 나머지 구역을 수행 중이더라도 한번은 임계구역에 들어갈 수 있게 보장된다.

</br>

> **Peterson의 해결안은 최신 컴퓨터 아키텍처에서 작동한다고 보장되지 않는다.**

→ ***시스템 성능을 향상하기 위해 프로세스 또는 컴파일러가 종속성이 없는 읽기 및 쓰기 작업을 재정렬 할 수 있다.***

</br>

- 데이터를 공유하는 다중 스레드 프로그램의 경우, **명령 순서가 바뀌게 되면 데이터의 일관성이 깨지거나 예기치 못한 결과**를 낳을 수 있다.
    - ex) 두 스레드 간에 공유되는 데이터

<img width="191" alt="image" src="https://user-images.githubusercontent.com/106216912/213175255-8fd9083b-85c1-4e53-a38a-00606fb1c452.png">

</br>

- Thread 1은 다음 명령문을 수행한다.

<img width="116" alt="image" src="https://user-images.githubusercontent.com/106216912/213175361-483f727e-276f-4f39-bf6d-8814e555f50e.png">

</br>

- Thread 2는 다음 명령문을 수행한다.

<img width="110" alt="image" src="https://user-images.githubusercontent.com/106216912/213175439-6465e6cd-e367-448e-8164-58f11e2eeefd.png">

</br>

→ `flag` 와 `x` 사이에 데이터 종속성이 없으므로, 프로세서가 Thread 2의 명령어를 재정렬하여 `x = 100` 을 배정하기 전에, `flag` 가 `true` 로 지정될 수 있다.

- Thread 1은 `x` 에 대해 0을 출력할 수 있다.

</br>

> **이러한 사실에 Peterson의 해결안에 어떤 영향을 미치는가?**

→ ***두 스레드가 동시에 임계구역에서 활성화될 수 있다.***

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/213175547-635e34c9-5404-4d17-83e6-a940b4906365.png">

</br>

- 상호 배제를 유지하는 유일한 방법 : 적절한 동기화 도구를 사용하는 것

---

## 4. 동기화를 위한 하드웨어 지원

→ ***소프트웨어 기반 해결책은 최신 컴퓨터 아키텍처에서 작동하지 않을 수 있으므로, 임계구역 문제를 해결하기 위한 지원을 제공하는 세 가지 하드웨어 명령어를 제시한다.***

- 이러한 프리미티브 연산은 동기화 도구로 직접 사용될 수 있거나, 더 추상적인 동기화 기법의 기초 형태로 사용될 수 있다.

</br>

### 메모리 장벽

→ ***메모리 모델 : 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리 접근 시 보장되는 사항을 결정한 방식***

1. **강한 순서**
    - 한 프로세서의 메모리 변경 결과가 다른 모든 프로세서에 즉시 보임

</br>

2. **약한 순서**
    - 한 프로세서의 메모리 변경 결과가 다른 프로세서에 즉시 보이지 않음

</br>

> **메모리 모델은 프로세서 유형에 따라 다르므로, 커널 개발자는 공유 메모리 다중 처리기에서 메모리 변경의 가시성에 대한 어떠한 가정도 할 수 없다.**

- **메모리 장벽** : **메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공해서, 다른 프로세서에서 실행 중인 스레드에 메모리 변경 사항이 보이는 것을 보장하는 것**
    - 시스템은 후속 적재, 또는 저장 연산이 수행되기 전에 모든 적재 및 저장이 완료되도록 한다.

</br>

- 위의 예제 에서 스레드 1에 메모리 장벽 연산을 추가하면, `flag` 값이 `x` 값 보다 먼저 적재되도록 보장한다.

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/213187383-e9699996-bcb5-4e9f-986d-fbcec6765d21.png">

</br>

- 스레드 2도 동일하게 메모리 장벽을 넣으면, `flag` 에 배정하기 전에 `x` 에 대한 배정이 먼저 실행되도록 한다.

<img width="137" alt="image" src="https://user-images.githubusercontent.com/106216912/213187459-cf53e1c7-8a52-4564-84f4-f7e39c696237.png">

</br>

→ 메모리 장벽을 배치하여 작업의 재정렬을 피할 수 있지만, **메모리 장벽은 매우 낮은 수준의 연산으로 간주**한다.

</br>

### 하드웨어 명령어

→ ***많은 현대 기계들은 한 워드의 내용을 검사하고 변경하거나, 두 워드의 내용을 원자적으로 교환할 수 있는, 즉 인터럽트 되지 않는 하나의 단위로서, 특별한 하드웨어 명령어들을 제공한다.***

</br>

> **`test_and_set()`**

→ **원자적(atomically)으로 실행된다.**

- 두 개의 `test_and_set()` 명령어가 동시에 실행된다면, 어떤 임의의 순서로 순차적으로 실행될 것이다.

<img width="345" alt="image" src="https://user-images.githubusercontent.com/106216912/213187667-e739b676-31b4-42e6-9862-3277efc905b0.png">

</br>

- 기계가 `test_and_set()` 명령어를 지원한다면, `false` 로 초기화되는 `lock` 이라는 `boolean` 변수를 선언해서 상호 배제를 구현할 수 있다.
    - `acquire lock` , `release lock`

<img width="248" alt="image" src="https://user-images.githubusercontent.com/106216912/213187754-1ccc4bd4-c31b-493a-86e2-24e34d6cd345.png">

</br>

> **`compare_and_swap()`**

→ ***두 개의 워드에 대해 원자적인 연산을 하지만, 두 워드의 내용 교환에 기반을 둔 다른 기법을 사용한다.***

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/213187915-ba605c6b-e7b1-489b-9585-fa1b8afc1e62.png">

- 피연산자 `value` 는 오직 수식이 참일 때만 `new_value` 로 지정된다.
    - 어떠한 경우에든 CAS 명령어는 언제나 `value` 의 원래 값을 반환한다.

</br>

→ 두 개의 CAS 명령이 동시에 실행되면 임의의 순서로 순차적으로 실행된다.

</br>

- 전역 변수 `lock` 이 선언되고 `0` 으로 초기화된다.
    - `lock` 을 `1` 로 지정한다.
    - `lock` 의 원래 값이 `expected` 와 같으므로, 프로세스는 임계구역으로 들어간다.

</br>

<img width="342" alt="image" src="https://user-images.githubusercontent.com/106216912/213188075-d8fb4f65-fa83-45d8-8782-6effb1d81006.png">

- 이후의 `compare_and_swap()` 호출은 현재 `lock` 의 값이 기대값 `0` 과 같지 않기 때문에 성공하지 못한다.
    - 프로세스가 임계구역을 빠져나올 때 `lock` 을 `0` 으로 변경하고, 다른 프로세스가 임계구역을 들어갈 수 있게 허용한다.

</br>

> **임계구역 요구 조건을 모두 만족시키는 `compare_and_swap()` 명령어를 이용한 또다른 알고리즘**

<img width="292" alt="image" src="https://user-images.githubusercontent.com/106216912/213188194-c70bb3c7-bd93-43c8-91a9-3a10fd9b9583.png">

</br>

- 공통 데이터는 다음과 같고, `waiting` 배열의 원소는 `false` 로 초기화되고, `lock` 은 `0` 으로 초기화된다.

<img width="151" alt="image" src="https://user-images.githubusercontent.com/106216912/213188310-a100a15d-a54d-4f82-bf40-5a7fa4e30f7a.png">

</br>

- 이 알고리즘이 **상호 배제 조건**을 만족시킨다는 것을 증명하기 위해서는, Pi가 임계구역에 진입하는 경우는 오직 `waiting[i] == false` 이던지, `key == 0` 이어야 한다.
    - `key` 는 `compare_and_swap()` 을 실행했을 경우에만 `0` 이 된다.
    - 다른 프로세스들은 모두 기다려야 한다.
    - `waiting[i]` 가 `false` 가 되는 것은 다른 프로세스가 임계구역을 떠날 때뿐이다.

</br>

→ **이 때, 오직 한 개의 `waiting[i]` 만이 `false` 로 지정되고, 상호 배제가 보장된다.**

</br>

- **Progress 조건**이 만족함을 보이기 위해서는, 임계구역을 떠나는 프로세스는 `lock` 을 `0` 으로 하던지 `waiting[j]` 를 `false` 로 한다.
    - **어느 쪽이든 둘 다 임계구역으로 들어가고자 하는 프로세스를 진입하게 만들어 준다.**

</br>

- **한정된 대기 조건**을 만족시킴을 증명하기 위해서는, 한 프로세스가 임계구역을 떠날 때는 `waiting` 배열을 순회하면서 흝어본다는 사실에 착안하면 된다.
    - 순환하면서 조사하여 `waiting[j] == true` 이면서 위 순환 순서 중 첫 번째 프로세스가 임계구역에 들어가게 된다.

</br>

→ **임계구역에 들어가고자 하는 프로세스는 최대한 `n-1` 회만 양보하면 들어갈 수 있다.**

</br>

### 원자적 변수

→ ***`compare_and_swap()` 같은 하드웨어 명령어는 상호 배제를 제공하기 위해 직접 사용되지 않고, 임계구역 문제를 해결하는 다른 도구를 구축하기 위한 기본 구성요소로 사용된다.***

- **원자적 변수(atomic variable)**
    - 정수 및 부울과 같은 기본 데이터 유형에 대한 원자적 연산을 제공한다.
    - 갱신되는 동안 단일 변수에 대한 데이터 경쟁에 있을 수 있는 상황에서 상호 배제를 보장하는 데 사용된다.

</br>

> **원자적 변수를 지원하는 대부분의 시스템은 원자적 변수에 접근하고 조작하기 위한 기능뿐만 아니라, 특별한 원자적 데이터 유형을 제공한다.**

- ex) 다음은 원자적 정수 `sequence` 를 증가시킨다.

<img width="197" alt="image" src="https://user-images.githubusercontent.com/106216912/213188592-f345af27-96cc-41f2-94de-5c55e7ba0c6c.png">

</br>

- `incremental()` 함수는 CAS 명령어를 사용하여 구현된다.

<img width="387" alt="image" src="https://user-images.githubusercontent.com/106216912/213188685-249ae9db-bacc-462d-bbd6-6b9c0e32bdec.png">

</br>

→ **원자적 변수는 원자적 갱신을 제공하지만, 모든 상황에서 경쟁 조건을 완벽히 해결하지는 않는다.**

- 카운터 및 시퀀스 생성기와 같은 공유 데이터 한 개의 갱신에만 제한되는 경우가 많다.

---

## 5. Mutex Locks

→ ***임계구역 문제에 대한 하드웨어 기반 해결책은 복잡할 뿐 아니라, 응용 프로그래머는 사용할 수 없다.***

- 운영체제 설계자들은 임계구역 문제를 해결하기 위한 상위 수준 소프트웨어 도구들을 개발한다.
    - 가장 간단한 도구 : **mutex 락**

</br>

> **임계구역을 보호하고, 경쟁 조건을 방지하기 위해 mutex 락을 사용한다.**

→ ***프로세스는 임계구역에 들어가기 전에 반드시 락을 획득해야 하고, 임계구역을 빠져나올 때 락을 반환해야 한다.***

<img width="238" alt="image" src="https://user-images.githubusercontent.com/106216912/213196545-b6ab410f-5fca-4369-9659-4f02679d661c.png">

- `acquire()` : 락 획득
- `release()` : 락 반환

</br>

- Mutex 락은 `available` 이라는 `boolean` 변수를 가지는데, 락의 가용 여부를 표시한다.
    - 락이 가용하면 `acquire()` 호출은 성공하고, 락은 곧 사용 불가 상태가 된다.
    - **사용 불가 상태의 락을 획득하려고 시도하는 프로세스는 락이 반환될 때까지 봉쇄**된다.

</br>

- `acquire()` 함수의 정의는 다음과 같다.

<img width="197" alt="image" src="https://user-images.githubusercontent.com/106216912/213196718-3f7f7fc6-32a6-4f32-bc45-393119d9fe38.png">

</br>

- `release()` 함수의 정의는 다음과 같다.

<img width="147" alt="image" src="https://user-images.githubusercontent.com/106216912/213196815-1558cf4e-c7c8-4f01-b8dc-b901d5b33b90.png">

</br>

→ `acquire()` 또는 `release()` 함수 호출은 **원자적으로 수행**되어야 한다.

</br>

> **단점 : 바쁜 대기(busy waiting)을 해야 한다.**

→ ***한 프로세스가 임계구역에 있는 동안, 임계구역에 진입하려는 다른 프로세스들은 `acquire()` 함수를 호출하는 반복문을 계속 실행해야 한다.***

- 계속된 루프의 실행은 하나의 CPU 코어가 여러 프로세스에서 공유되는 실제 다중 프로그래밍 시스템에서 문제가 된다!
    - 다른 프로세스가 생산적으로 사용할 수 있는 CPU 주기를 낭비한다.

</br>

> **mutex 락 유형 = 스핀락(spinlock)**

- **장점 : 스핀락은 프로세스가 락을 기다려야 하고 문맥 교환에 상당한 시간이 소요될 때, 문맥 교환이 필요하지 않다.**
    - 다중 코어 시스템의 특정 상황에서는 스핀락이 선호된다.
    - 잠깐 동안 락을 유지해야 하는 경우, **다른 스레드가 하나의 코어에서 임계구역을 실행하는 동안 스레드는 다른 처리 코어에서 스핀**하고 있을 수 있다.

---

## 6. 세마포(Semaphores)

→ ***세마포는 mutex와 유사하게 작동하지만, 프로세스들이 자신들의 행동을 더 정교하게 동기화할 수 있는 방법을 제공하는 강력한 도구이다.***

- 세마포 `S` 는 정수 변수로서, 초기화를 제외하고는 두 개의 표준 원자적 연산으로만 접근할 수 있다.
    - `wait()` , `signal()`

</br>

- `wait()` 의 정의는 다음과 같다.

<img width="199" alt="image" src="https://user-images.githubusercontent.com/106216912/213209089-ea620ca4-abdd-4a3d-91fb-c4b2355b08ec.png">

</br>

- `signal()` 의 정의는 다음과 같다.

<img width="116" alt="image" src="https://user-images.githubusercontent.com/106216912/213209230-65100ed3-81ff-4da8-8665-3969c3ab43f4.png">

</br>

> **`wait()` 와 `signal()` 연산 시 세마포의 정수 값을 변경하는 연산은 반드시 원자적으로 수행되어야 한다.**

→ 즉, **한 스레드가 세마포 값을 변경하면, 다른 어떤 스레드도 동시에 동일한 세마포 값을 변경할 수 없다.**

</br>

### 세마포 사용법

→ ***운영체제는 카운팅(counting)과 이진(binary) 세마포를 구분한다.***

- **카운팅 세마포** : 값은 **제한 없는 영역**을 갖는다.
    - 유한한 개수를 가진 자원에 대한 접근을 제어하는 데 사용될 수 있다.

</br>

- **이진 세마포** : 값은 **0과 1사이의 값**만 가능하다.
    - mutex 락과 유사하게 동작한다.

</br>

→ 세마포는 가용한 자원의 개수로 초기화된다.

- 각 자원을 사용하려는 프로세스는 세마포에 `wait()` 연산을 수행하고, 세마포의 값은 감소한다.
- 프로세스가 자원을 방출할 때는 `signal()` 연산을 수행하고, 세마포는 증가한다.
    - 세마포의 값이 0이 되면, 모든 자원이 사용 중임을 나타낸다.

</br>

> **다양한 동기화 문제를 해결하기 위해 세마포를 사용할 수 있다.**

- P1은 S1 명령문을, P2는 S2 명령문을 병행하게 수행하려는 두 프로세스가 있다.
    - S2는 S1이 끝난 뒤에만 수행되어야 한다.

</br>

- P1에 다음 명령문을 넣는다.

<img width="139" alt="image" src="https://user-images.githubusercontent.com/106216912/213209575-82a7ef5c-df28-415d-8048-0733d3164591.png">

</br>

- P2에 다음 명령문을 넣는다.

<img width="119" alt="image" src="https://user-images.githubusercontent.com/106216912/213209651-4798bb47-bed5-43d7-be6e-38a27cf7eb37.png">

</br>

→ P2가 S2를 수행하는 것은 P1이 `signal(synch)` 를 호출한 후에만 가능하다.

- 또한, 이 호출은 S1을 실행한 이후에만 가능하다.

</br>

### 세마포 구현

→ ***세마포 연산 `wait()` 와 `signal()` 도 바쁜 대기 문제를 가지고 있다.***

</br>

> **문제를 극복하기 위해, `wait()` 와 `signal()` 연산을 변경할 수 있다.**

- 프로세스가 `wait()` 연산을 실행하고 세마포 값이 양수가 아닌 것을 발견하면, 프로세스는 반드시 대기해야 한다.
    - 하지만, 바쁜 대기 대신에 프로세스는 자신을 **일시 중지**시킬 수 있다.
    - 일시 중지 연산은 **프로세스를 세마포에 연관된 대기 큐에 넣고, 프로세스의 상태를 대기 상태로 전환**한다.
    - 그 후 제어가 CPU 스케줄러로 넘어가고, 스케줄러는 다른 프로세스를 실행하기 위하여 선택한다.

</br>

- 세마포를 대기하면서 일시 중지된 프로세스는 다른 프로세스가 `signal()` 연산을 실행하면 재시작되어야 한다.
    - 프로세스는 `wakeup()` 연산에 의하여 재시작되는데, **프로세스의 상태를 대기상태에서 준비 완료 상태로 변경**한다.
    - 그리고, 프로세스는 준비 완료 큐에 넣어진다.

</br>

→ 세마포를 다음과 같이 정의한다.

<img width="239" alt="image" src="https://user-images.githubusercontent.com/106216912/213209925-517851a2-fd56-4ecc-85e9-453c0b86f7a7.png">

- 프로세스가 세마포를 기다려야 한다면, **프로세스가 세마포의 프로세스 리스트에 추가**된다.
    - `signal()` 연산은 프로세스 리스트에서 **한 프로세스를 꺼내서 그 프로세스를 깨워준다**.

</br>

- `wait()` 연산은 다음과 같이 정의될 수 있다.

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213210029-983f9a1b-da02-44bb-bcca-fe3dc79265f5.png">

</br>

- `signal()` 연산은 다음과 같이 정의될 수 있다.

<img width="344" alt="image" src="https://user-images.githubusercontent.com/106216912/213210103-bffbeb43-f0c6-4f73-91fe-0c112ae004cd.png">

</br>

- `sleep()` 연산은 **자기를 호출한 프로세스를 일시 중지**시킨다.
    - `wakeup()` 연산은 **일시 중지된 프로세스의 실행을 재개**시킨다.

</br>

→ **이들 두 연산은 운영체제의 기본적인 시스템 콜로 제공된다!**

</br>

> **하지만, `wait()` 와 `signal()` 연산에서 바쁜 대기를 완전하게 제거하지 못하고, 오히려 바쁜 대기를 진입 코드에서 응용 프로그램의 임계구역으로 이동하였다.**
> 
- 그리고, 바쁜 대기를 `wait()` 와 `signal()` 연산의 임계구역에만 국한하였으며, 이 구역은 매우 짧다.
    - 따라서 **임계구역은 거의 항상 비어 있고, 바쁜 대기는 드물게 발생하고, 발생하더라도 시간이 아주 짧다.**

</br>

- 임계구역이 매우 길거나, 거의 항상 점유된 응용 프로그램들을 갖는 전혀 다른 환경에서 바쁜 대기는 극도로 비효율적이다.

---

## 7. 모니터

→ ***세마포가 프로세스 간의 동기화를 위해서 편리하고 효과적으로 쓰일 수 있지만, 자칫 잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있다.***

- 프로그램의 세마포에 대한 `wait()` 와 `signal()` 연산의 순서가 뒤바뀌어 다음과 같은 코드가 되었다고 가정한다.

<img width="139" alt="image" src="https://user-images.githubusercontent.com/106216912/213230366-74121285-eb6f-4ff3-88f7-1d0bb5598717.png">

→ **여러 프로세스가 동시에 임계구역 안에서 실행될 수 있어, 상호 배제 요구 조건을 위반**하게 된다.

</br>

- 프로그램이 `signal(mutex)` 를 써야할 곳에 잘못해서 `wait(mutex)` 를 썼다고 가정한다.

<img width="136" alt="image" src="https://user-images.githubusercontent.com/106216912/213230537-94497e27-4040-4de0-bcbd-85c1b0fb2ef0.png">

→ 세마포를 사용할 수 없으므로, **프로세스는 두 번째 `wait()` 호출에서 영구적으로 봉쇄**된다.

</br>

- 프로세스가 `wait(mutex)` 나 `signal(mutex)` , 또는 둘 다를 빠뜨렸다고 가정한다.
    - **상호 배제 요구 조건을 위반하든지 프로세스는 영원히 봉쇄**된다.

</br>

> **세마포를 잘못 사용하면, 다양한 유형의 오류가 너무나도 쉽게 발생할 수 있다.**

→ **간단한 동기화 도구를 통합하여 고급 언어 구조물을 제공한다.**

- **모니터(monitors)**

</br>

### 모니터 사용법

→ ***추상화된 데이터 형(ADT)은 데이터와 이 데이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호한다.***

- **모니터 형** : 모니터 내부에서 상호 배제가 보장되는 프로그래머가 정의한 일련의 연산자 집합을 포함하는 ADT
    - 변수들의 선언을 포함하고 있는데, 변수들이 값은 그 형에 해당하는 한 인스턴스의 상태를 정의한다.
    - 변수들을 조작할 수 있는 프로시저, 또는 함수들의 본체도 같이 포함하고 있다.

</br>

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213230941-311e251c-dbee-4ee2-ab63-3c6242676193.png">

- 모니터 형의 표현은 다른 프로세스들이 직접 사용할 수 없고, 모니터 내에 정의된 함수만이 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있다.
    - 모니터 내의 지역 변수는 오직 지역 함수만의 접근할 수 있다.

</br>

> **모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화되도록 보장해 준다.**

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/213231259-d9e75435-14bc-4a61-bbf9-4c4433b121a5.png">

- 따라서, 프로그래머들은 동기화 제약 조건을 명시적으로 코딩할 필요가 없다.

</br>

> **모니터 구조물이 동기화 기법을 모델링하기 위해 부가적인 동기화 기법을 정의해야 한다.**

→ 이 동기화 기법들은 `condition` 이라는 구조물로 제공될 수 있다.

- 자신의 주문형 동기화 기법을 작성할 필요가 있는 프로그래머는 하나 이상의 `condition` 형의 변수를 정의할 수 있다.

<img width="145" alt="image" src="https://user-images.githubusercontent.com/106216912/213231456-2e5a948d-1fdd-4315-b569-c5a21c243665.png">

</br>

- 이 `condition` 변수에 호출될 수 있는 연산은 오직 `wait()` 와 `signal()` 이다.
    - 연산 `x.wait()` 는 이 연산을 호출한 프로세스는, 다른 프로세스가 `x.signal()` 을 호출할 때까지 일시 중지 되어야 한다는 것을 의미한다.

</br>

- `x.signal()` 연산은 정확히 하나의 일시 중지 프로세스를 재개한다.

<img width="389" alt="image" src="https://user-images.githubusercontent.com/106216912/213231779-61d7bd53-7290-4e4e-9534-5c53986f1372.png">

- 만약 일시 중지된 프로세스가 없으면, `signal()` 연산은 아무런 효과가 없다.
    - 즉, `x` 의 상태는 연산이 전혀 실행되지 않는 것과 같다.

</br>

> **일시 중지된 스레드 Q가 실행을 재개하도록 허용한다면, `signal` 을 보낸 스레드 P는 반드시 대기해야 한다.**

→ 그렇지 않으면, **P와 Q는 모니터 안에서 동시에 활성화된다.**

</br>

- 두 가지 가능성이 존재한다.
    1. **Signal and wait** : P는 Q가 모니터를 떠날 때까지 기다리거나, 다른 조건을 기다린다.
    2. **Signal and continue** : Q는 P가 모니터를 떠날 때까지 기다리거나, 다른 조건을 기다린다.

</br>

### 세마포를 이용한 모니터의 구현

→ ***모니터 구현 시 `signal-and-wait` 기법을 사용한다.***

- Signaling 프로세스는 실행 재개되는 프로세스가 모니터를 떠나든지, 아니면 `wait()` 할 때까지 그 자신이 다시 기다려야 하므로, `next` 라는 이진 세마포가 추가로 필요하고 0으로 초기화된다.
    - 따라서, 각 외부 프로시저 `F` 는 다음과 같이 대체된다.

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/213232131-2da3275c-3d7e-496b-bb2c-eefde6c81e86.png">

→ 모니터 안에서의 상호 배제는 보장된다.

</br>

> **조건 변수를 세마포로 구현하는 방법**

- 각 조건 `x` 마다 `x_sem` 이라는 이진 세마포와 `x_count` 라는 정수형 변수를 도입하고, 초기값을 0으로 준다.
    - `x.wait()` 연산은 다음과 같이 구현할 수 있다.

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/213232341-9a1c3d17-af1f-4625-b26f-2f9ce5233607.png">

</br>

- `x.signal()` 연산은 다음과 같이 구할 수 있다.

<img width="140" alt="image" src="https://user-images.githubusercontent.com/106216912/213232546-a02abc13-3f53-4a90-ba90-3ea85e858644.png">

</br>

### 모니터 내에서 프로세스 수행 재개

→ ***일시 중지 되었던 프로세스 중 어느 프로세스가 수행 재개될 것인가를 어떻게 결정할까?***

- `condition-wait` 구조물을 사용한다.

<img width="102" alt="image" src="https://user-images.githubusercontent.com/106216912/213232778-4d50762b-f903-4ca9-a9f2-dc4def8ec6ad.png">

</br>

- `c` 는 정수 수식이고, `wait()` 연산이 호출될 때 값이 계산된다.
    - `c` 의 값은 우선순위 번호라고 불리며, 일시 중지 되는 프로세스의 이름과 함께 저장된다.
    - `x.signal()` 이 수행되면 가장 작은 **우선순위 번호**를 가진 프로세스가 다음번에 수행 재개 된다.

</br>

> **ex) `ResourceAllocator` 모니터**

<img width="197" alt="image" src="https://user-images.githubusercontent.com/106216912/213232982-a8a30ebc-3c9d-483b-9573-48b19c069f47.png">

</br>

> **불행하게도, 모니터의 개념은 순서가 그대로 지켜지는 것을 보장해주지 않고, 특히 다음과 같이 문제가 발생할 수 있다.**

- 프로세스가 자원에 대한 허락을 받지 않고 자원을 액세스할 경우
- 프로세스가 자원에 대한 허락을 받은 다음 그 자원을 방출하지 않을 경우
- 프로세스가 자원에 대한 허락을 받지 않았는데도 그 자원을 방출할 경우
- 프로세스가 자원에 대한 허락을 받은 다음 방출하지 않은 상태에서 또 그 자원을 요청할 경우

</br>

→ **이러한 검사는 작은 규모와 정적인 시스템에서는 가능할지라도, 규모가 크거나 동적인 시스템에서는 비합리적이다.**

---

## 8. 라이브니스(Liveness)

→ ***동기화 도구를 사용하는 것의 한 가지 결과는, 임계구역에 들어가려고 시도하는 프로세스가 무기한 대기할 가능성이 있다는 것이다.***

- **라이브니스** : 프로세스가 실행 주명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성

</br>

> **라이브니스 실패로 이어질 수 있는 두 가지 상황**

- **교착 상태(deadlock)**
- **우선순위 역전(priority inversion)**

</br>

### 교착 상태(Deadlock)

- **교착 상태**
    - **두 개 이상의 프로세스들이 대기 중인 프로세스들 중 하나의 의해서만 야기될 수 있는 사건을 무한정 기다리는 상황**
    - 다중 프로그래밍 환경에서는 여러 프로세스들이 한정된 자원을 사용하려고 서로 경쟁할 수 있다.

<img width="205" alt="image" src="https://user-images.githubusercontent.com/106216912/213240442-b04ba851-b1d4-4adf-8fe7-6de5784536f8.png">

</br>

### 우선순위 역전

→ ***높은 우선순위 프로세스가 현재 낮은 우선순위 프로세스, 또는 연속된 낮은 우선순위 프로세스에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 스케줄링에 어려움이 생긴다.***

- 커널 데이터는 락에 의해 보호되기 때문에, 낮은 우선순위 프로세스가 자원의 사용을 마칠 때까지 높은 우선순위 프로세스가 기다려야 한다.

</br>

- ex) 우선순위가 L < M < H 인 3개의 프로세스 L, M, H
    - H는 L이 사용중인 자원 R을 필요로 하고, M이 실행가능 상태가 되어 L을 선점한다.
    - M은 H가 L이 자원을 양도할 때까지 기다려야 하는 시간에 영향을 준다.

</br>

→ **우선순위 역전(priority inversion) 문제**

- 셋 이상의 우선순위를 가진 시스템에서만 발생한다.

</br>

→ **우선순위 상속 프로토콜(priority-inheritance protocol)** 을 구현하여 해결한다.

- **더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는, 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속**받는다.
    - 자원 사용이 끝나면 원래 우선순위로 되돌아간다.

---

## 9. 평가

→ ***특정 동기화 도구를 사용할 시기를 결정하는 간단한 전략을 제시한다.***

- 하드웨어 솔루션은 매우 낮은 수준으로 간주하며, **일반적으로 mutex 락과 같은 다른 동기화 도구를 구성하기 위한 기초로 사용**된다.

</br>

- 최근, 락 오버헤드 없이 경쟁 조건으로부터 보호하는 **락 없는(lock-free) 알고리즘**을 구현하기 위해 CAS 명령을 사용하는 데 중점을 두고 있다.
    - 오버헤드가 낮고 확장성이 있지만, 개발 및 테스트가 어렵다.

</br>

> **다앙한 경합 부하에서 CAS 기반 동기화와 기존 동기화간의 성능 차이와 관련된 일반적인 규칙**

- **경합 없음**
    - 두 옵션 모두 일반적으로 빠르지만, CAS 보호는 기존 동기화보다 다소 빠를 수 있다.

</br>

- **적당한 경합**
    - CAS 동기화는 기존 동기화보다 빠를 것이고, 아마도 훨씬 빠르게 작동할 것이다.

</br>

- **심한 경합**
    - 경합이 치열한 상황에서는 기존 동기화가 기본적으로 CAS 기반 동기화보다 빠르다.