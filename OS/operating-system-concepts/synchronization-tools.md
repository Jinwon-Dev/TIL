> **협력적 프로세스**

→ ***시스템 내에서 실행 중인 다른 프로세스의 실행에 영향을 주거나, 영향을 받는 프로세스***

- 논리 주소 공간을 직접 공유하거나, 공유 메모리 또는 메시지 전달을 통해서만 데이터를 공유할 수 있다.
    - 하지만, **데이터를 공유 데이터를 동시에 접근하면 데이터의 일관성이 깨질 수 있다.**

</br>


> **논리 주소 공간을 공유하는 협력적 프로세스의 질서 있는 실행을 보장하고, 데이터의 일관성을 유지하는 방법을 알아보자!**

</br>

## 1. 배경

→ ***이번 절에서는 프로세스가 병행, 또는 병렬로 실행될 때 여러 프로세스가 공유하는 데이터의 무결성에 어떤 문제를 일으키는지 알아본다.***

</br>

> **유한 버퍼 문제**

→ ***0으로 초기화되어 있는 `count` 라는 정수형 변수를 추가한다.***

- 버퍼에 새 항목을 추가할 때마다 값을 증가시키고, 한 항목을 꺼낼 때마다 값을 감소시킨다.

</br>

- **생산자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156150-b9ba1d1d-5e51-4c98-bc66-ebd80ea16013.png">

</br>

- **소비자**를 위한 코드

<img width="339" alt="image" src="https://user-images.githubusercontent.com/106216912/213156241-5f697ed4-7f12-4597-ad06-1add92c99d65.png">

</br>

> **생산자와 소비자 코드는 개별적으로는 올바를지라도, 병행적으로 수행시키면 올바르게 동작하지 않는다!**

- ex) `count` = 5, 생산자와 소비자는 `count++` 과 `count--` 를 병행하게 실행하는 상황
    - 수행 후의 결과는 `5` 가 아닌 `4` 나 `5` , `6` 이 된다.

</br>

> **`count` 변수 접근 연산의 기계어 구현**

<img width="155" alt="image" src="https://user-images.githubusercontent.com/106216912/213156424-8ae84027-6cfa-4315-8366-636b213f9927.png">

→ `register1` , `register2` 는 한 CPU만 접근할 수 있는 레지스터 중 하나이다.

</br>

- `count++` 와 `count--` 를 병행하게 실행하는 것은, 저수준의 문장들을 임의의 순서로 뒤섞어 순차적으로 실행하는 것과 같다.
    - 두 개의 프로세스가 동시에 변수 `count` 를 조작하도록 허용해서 **부정확한 상태**에 도달하였다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/106216912/213156555-66328c13-e078-4f63-8fc2-a0ad697050d3.png">

</br>

> **경쟁 상황**

→ ***동시에 여러 개의 프로세스가 동일한 자료를 접근해서 조작하고, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황***

- 따라서, 한 순간에 하나의 프로세스만이 `count` 를 조작하도록 보장해야 한다.
    - 프로세스들이 **동기화되도록** 해야 한다!

---

## 2. 임계구역 문제

> **임계구역(critical section)** 

→ ***각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서는 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고, 갱신할 수 있다.***

- **특징 : 한 프로세스가 자신의 임계구역에서 수행하는 동안은, 다른 프로세스들은 그들의 임계구역에 들어갈 수 없다!**
    
    → **즉, 동시에 두 프로세스는 그들의 임계구역 안에서 실행할 수 없다.**
    
</br>

> **임계구역 문제 : 프로세스들이 데이터를 협력적으로 공유하기 위해, 자신들의 활동을 동기화할 때 사용할 수 있는 프로토콜을 설계하는 것**

</br>

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/213166520-a3f08a2d-96d8-43d6-9992-ac5bca4f13a5.png">

- **진입 구역(entry section)**
    - 각 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 한다.

</br>

- **나머지 구역(remainder section)**
    - 코드의 나머지 부분

</br>

> **임계구역 문제에 대한 해결안은 세 가지 요구 조건을 충족해야 한다.**

1. **상호 배제(mutual exclusion)**
    - 한 프로세스가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.

</br>

2. **진행(progress)**
    - 자기의 임계구역에서 실행되는 프로세스가 없고 그들 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, 나머지 구역에서 실행 중이지 않은 프로세스들만 다음에 임계구역에 진입할 프로세스를 결정하는 데 참여할 수 있다.
        - 이 선택은 무한정 연기될 수 없다.

</br>

3. **한정된 대기(bounded waiting)**
    - 프로세스가 자기의 임계구역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때까지, 다른 프로세스들이 그들의 임계구역에 진입하도록 허용하는 횟수에 한계가 있어야 한다.

</br>

> **임의의 한 순간에 많은 커널 모드 프로세스들이 운영체제 안에서 활성화될 수 있다.**

→ ***운영체제를 구현하는 코드는 경쟁 조건이 발생하기 쉽다!***

- ex) 두 프로세스가 동시에 파일을 열려고 하면, 리스트에 대한 개별적인 갱신은 경쟁 조건을 일으킬 수 있다.

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/213166834-c81ee87d-a0da-478b-bef4-07c10deb1a90.png">

- ex) 두 프로세스가 `fork()` 시스템 콜을 호출하여 자식 프로세스를 생성하고, `pid` 를 부모 프로세스로 반환하는 상황
    - 상호 배제가 제공되지 않으면, 동일한 프로세스 식별자 번호가 두 개의 다른 프로세스에 배정될 수 있다.

</br>

- 경쟁 조건이 발생하기 쉬운 커널 자료구조
    - 메모리 할당을 관리하는 자료구조
    - 프로세스 리스트를 유지하는 자료구조
    - 인터럽트 처리를 위한 자료구조

</br>

> **단일 코어 환경에서는 공유 변수를 수정하는 동안 인터럽트가 발생하는 것을 막을 수 있다면, 임계구역 문제는 간단히 해결된다.**

→ 하지만, 다중 처리기 환경에서는 실현할 수 없다!

</br>

> **임계구역을 다루기 위해 선점형 커널, 비선점형 커널 두 가지 일반적인 접근법이 사용된다.**

- **선점형 커널**
    - **프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용**한다.
    - 경쟁 조건이 발생하지 않는다는 것을 보장하도록 신중하게 설계되어야 한다.

</br>

- **비선점형 커널**
    - **커널 모드에서 수행되는 프로세스의 선점을 허용하지 않는다.**
    - 커널 모드 프로세스는 커널을 빠져 나가거나 봉쇄될 때까지, 또는 자발적으로 CPU의 제어를 양보할 때까지 계속 수행된다.
    - 한순간에 커널 안에서 실행 중인 프로세스는 하나밖에 없으므로, 경쟁 조건을 염려할 필요가 없다.

</br>

→ **그렇다면 왜 비선점형 커널보다 선점형 커널이 선호되는가?**

- 커널 모드 프로세스가 대기 중인 프로세스에 처리기를 양도하기 전에 오랫동안 실행할 위험이 적기 때문에, **응답이 더 민첩**할 수 있다.
    - 실시간 프로세스가 현재 커널에서 실행 중인 프로세스를 선점할 수 있기 때문에, **실시간 프로그래밍에 더 적당**하다.

---