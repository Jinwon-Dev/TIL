→ ***운영체제는 프로그램이 실행되는 환경을 제공해 준다.***

- 내부적으로 운영체제는 다양한 노선을 따라 구성되므로, 운영체제의 구조는 매우 다양하다.

</br>

> **운영체제를 살펴보기 위한 몇 가지 유리한 관점이 있다.**

1. **운영체제가 제공하는 서비스**에 초점을 맞추는 것
2. **운영체제가 사용자와 프로그래머에게 제공하는 인터페이스**에 초점을 맞추는 것
3. **시스템의 구성요소와 그들의 상호 연결**에 초점을 맞추는 것

</br>

![image](https://user-images.githubusercontent.com/106216912/209763759-48a01189-c5b9-4ecb-a714-e202c36e9337.png)

→ **사용자, 프로그래머, 운영체제 설계자**의 관점에서 운영체제의 세 가지 측면을 모두 살펴본다.

---

## 1. 운영체제 서비스

→ ***운영체제는 프로그램 실행 환경을 제공한다.***

- 또한, 운영체제는 프로그램과 그 프로그램의 사용자에게 **특정 서비스를 제공**한다.
    - 서비스들은 프로그래머가 **프로그래밍 작업을 더 쉽게 수행할 수 있도록** 해준다.

</br>

> **사용자 인터페이스(user interface)**

- 거의 모든 운영체제는 여러 형태인 **사용자 인터페이스(UI)** 를 제공한다.
    - 그래픽 사용자 인터페이스(GUI)
    - 터치 스크린 인터페이스
    - 명령어 라인 인터페이스(CLI)

</br>

> **프로그램 수행(program execution)**

- 시스템은 프로그램을 **메모리에 적재해 실행**할 수 있어야 한다.
    - 또한 정상적이든, 비정상적이든 **프로그램 실행을 끝낼 수 있어야** 한다.

</br>

> **입출력 연산(I/O operation)**

- 수행 중인 프로그램은 **입출력**을 요구할 수 있다.
    - 하지만 사용자들은 효율과 보호를 위해 입출력 장치를 직접 제어할 수 없다.
    
    → 운영체제가 **입출력 수행의 수단을 제공**해야 한다.

</br>

> **파일 시스템 조작(file system manipulation)**
 
- 프로그램은 **파일을 읽고 쓰고, 또한 이름에 의해 파일을 생성하고 삭제하고 찾을 수** 있어야 한다.
    - 몇몇 프로그램은 파일이나 디렉터리의 접근을 허가하거나 거부할 수 있다.
    
    → 운영체제는 개인의 선택에 따라, 그리고 특정 특성을 제공하기 위해 **다양한 파일 시스템을 제공**한다.

</br>

> **통신(communication)**

- 한 프로세스가 **다른 프로세스와 정보를 교환**해야 할 필요가 있다.
    - 동일한 컴퓨터에서 수행되고 있는 프로세스들 사이에서 일어날 수도 있고,
    - 네트워크에 의해 함께 묶여 있는 서로 다른 컴퓨터 시스템상에서 수행되는 프로세스들 사이에서 일어날 수도 있다.
    
    → 통신은 **공유 메모리, 또는 메시지 전달 기법**을 사용하여 구현된다.

</br>

> **오류 탐지(error detection)**

- 운영체제는 모든 가능한 **오류**를 항상 의식하고 있어야 한다.
    - 오류는 CPU, 메모리 하드웨어, 입출력 장치, 사용자 프로그램에서 일어날 수 있다.
    
    → 운영체제는 올바르고 일관성 있는 계산을 보장하기 위해 **각 유형의 오류에 대해 적절한 조치**를 해야 한다.

</br>

> **사용자에게 도움을 주는 것이 목적이 아닌 시스템 자체의 효율적인 동작을 보장하기 위한 운영체제 기능들도 존재한다.**

→ **다수의 프로세스가 사용하는 시스템에서는 프로세스들 간에 컴퓨터 자원을 공유하게 함으로써 효율성을 얻을 수 있다.**

</br>

> **자원 할당(resource allocation)**

- **다수의 프로세스나 다수의 작업이 동시에 실행될 때**, 각각 **자원을 할당**해 주어야 한다.
- 운영체제는 여러 가지 다른 종류의 자원을 관리한다.
    - CPU 사이클, 메인 메모리, 파일 저장장치, 입출력 장치 등

</br>

> **기록 작성(logging)**

- 어떤 사용자들은 프로그램이 **어떤 종류의 자원을 얼마나 많이 사용하는지**를 추적할 수 있길 원한다.
    - 기록 관리는 회계, 또는 단순히 사용 통계를 내기 위해 사용된다.
    - 사용 통계는 컴퓨팅 서비스를 개선하기 위해 시스템을 재구성하고자 하는 시스템 관리자에게 귀중한 자료가 될 수 있다.

</br>

> **보호(protection)와 보안(security)**

- 다중 사용자 컴퓨터 시스템 또는 네트워크로 연결된 컴퓨터 시스템에 저장된 정보의 소유자는 **정보의 사용을 통제**하기를 원한다.
    - 서로 다른 여러 프로세스가 병행될 때, 한 프로세스가 다른 프로세스나 운영체제를 방해해서는 안 된다.
    - **보호** : **시스템 자원에 대한 모든 접근이 통제되도록** 보장하는 것이 목표이다.
    - **보안** : 각 사용자가 자원에 대한 접근을 원할 때 패스워드를 이용해서 **자기 자신을 인증**한다.

---

## 2. 사용자와 운영체제 인터페이스

→ ***사용자가 운영체제와 접촉하는 방식에는 세 가지 기본적인 방법이 있다.***

1. 명령어 라인 인터페이스, 명령 인터프리터
2. 그래픽 기반 사용자 인터페이스
3. 터치 스크린 인터페이스

</br>

### 명령 인터프리터(Command-Interpreter)

→ ***운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나, 사용자가 처음 로그온 할 때 수행되는 특수한 프로그램으로 취급한다.***

- 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서는 이 해석기를 **셸(shell)** 이라고 부른다.

</br>

<img width="384" alt="image" src="https://user-images.githubusercontent.com/106216912/209769966-b7617ba0-c09b-4ca8-96b4-3ecef96ea3ba.png">

- 명령 인터프리터의 주요 기능은 다음과 같다.
    - **사용자가 지정한 명령을 가져와서 그것을 수행**하는 것
    - **명령을 통해 파일을 조작(생성, 삭제, 리스트, 프린트, 복사, 수행)** 하는 것

</br>

> **명령어들은 두 가지 일반적인 방식으로 구현될 수 있다.**

1. **명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우**
    - 명령 인터프리터는 명령을 자신의 코드의 한 부분으로 분기하고, 매개변수를 설정하고 적절한 **시스템 콜**을 한다.
    - 이 경우에는 제공될 수 있는 명령의 수가 명령 인터프리터의 크기를 결정한다.
        - 각 명령이 자신의 구현 코드를 요구하기 때문이다.

</br>

2. **시스템 프로그램에 의해 대부분의 명령을 구현하는 경우**
    - **명령 인터프리터는 전혀 명령을 알지 못한다.**
    - **메모리에 적재되어 실행될 파일을 식별하기 위해** 명령을 사용한다.
    - 프로그래머는 적합한 프로그램 로직을 가진 새로운 파일을 생성함으로써, 시스템에 새로운 명령을 쉽게 추가할 수 있다.

</br>

### 그래픽 기반 사용자 인터페이스(Graphical User Interface)

→ ***운영체제와 접촉하는 두 번째 방식은 사용자 친화적인 그래픽 기반 사용자 인터페이스(GUI)를 통한 방식이다.***

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/209770117-be05b262-07f3-495c-ba0a-f23d9e50f5f5.png">

- 사용자가 직접 명령어를 입력하는 것이 아니라, **마우스를 기반으로 하는 윈도 메뉴 시스템**을 사용한다.
    - 사용자는 마우스를 움직여 마우스 포인터를 화면상의 아이콘에 위치시킨다.
    - 마우스 포인터에 따라, 마우스 버튼을 누름으로써 프로그램을 호출하거나 파일을 선택할 수도 있고, 메뉴를 잡아당길 수도 있다.

</br>

### 터치스크린 인터페이스(Touch-Screen Interface)

→ ***스마트폰 및 휴대용 태블릿 컴퓨터는 일반적으로 터치스크린 인터페이스를 사용한다.***

<img width="192" alt="image" src="https://user-images.githubusercontent.com/106216912/209770191-a4a23dc1-38f1-4a0f-b489-a707000e0266.png">

- 사용자는 **터치스크린에서 손가락을 누르거나, 스와이프 하는 등의 제스처를 취하여 상호 작용**한다.
    - 초기 스마트폰에는 물리적 키보드가 포함되어 있었지만, 이제 스마트폰과 태블릿의 대부분은 터치스크린에서 키보드를 시뮬레이션 한다.

</br>

### 인터페이스의 선택

→ ***어떤 인터페이스를 사용할 것인지는 개인의 선호에 달려 있다.***

- 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워 유저들은 명령어 라인 인터페이스를 사용한다.
    - **하고자 하는 작업에 대해 더 빨리 접근**할 수 있으므로, 명령어 라인 인터페이스가 효율적이다.
    - 명령어 라인을 사용해야만 사용할 수 있는 기능이 있다.
    - 프로그래밍이 가능하여 **반복적으로 해야 하는 작업**을 쉽게 할 수 있다.

</br>

> **사용자 인터페이스는 시스템마다, 심지어는 한 시스템의 사용자마다 다를 수 있다.**

---

## 3. 시스템 콜(System Calls)

→ ***시스템 콜은 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공한다.***

</br>

### 예제

→ ***한 파일로부터 데이터를 읽어서 다른 파일로 복사하는 프로그램을 작성한다고 가정한다.***

</br>

1. **명령의 일부로 두 파일의 이름을 전달하는 방법**
- UNIX의 `cp` 명령

```bash
cp in.txt out.txt
```

→ 이 명령은 입력 파일 `in.txt` 를 출력 파일 `out.txt` 에 복사한다.

</br>

2. **프로그램이 사용자에게 이름을 요청하는 방법**
- 대화형 시스템에서 이 방법은 **일련의 시스템 콜**이 필요하다.
    - 메시지를 작성하고, 키보드에서 문자를 읽고, 파일 이름 메뉴가 창에 표시되고, 소스 이름을 선택하고 지정하는 등 많은 **I/O 시스템 콜**이 필요하다.

</br>

<img width="384" alt="image" src="https://user-images.githubusercontent.com/106216912/209806722-1b2e3a6f-e39f-4dc2-814c-a28e2d7c784a.png">

- 두 개의 파일 이름이 얻어지면, 프로그램은 입력 파일을 오픈하고 출력 파일을 생성한 후 오픈한다.
    - 각각의 이러한 연산은 **또 다른 시스템 콜을 필요**로 하며, 각 **시스템 콜에서 오류가 발생하면 처리**되어야 한다.
        - ex) 파일이 존재하지 않거나, 파일에 대한 접근이 금지되어 있을 때 에러 메시지를 출력하고, 비정상적으로 종료한다.
        - ex) 동일한 이름을 가진 출력 파일이 이미 존재하면 프로그램을 중단하게 하거나, 기존 파일을 삭제한 후 새로운 파일을 생성할 수도 있다.
        - 대화형 시스템에서 또 다른 방법은 기존의 파일을 대체할 것인지, 혹은 프로그램을 중단할 것인지를 사용자에게 물어보는 것이다.
        
        → **모든 것이 또 다른 시스템 콜이다!**

</br>        

- 두 개의 파일이 준비되면, **입력 파일로부터 읽어서, 출력 파일에 기록하는 루프**에 들어간다.
    - 이 경우에 여러 오류가 발생할 수 있다.

</br>

- 전체 파일이 복사된 후, 프로그램은 두 개의 파일을 닫고, 콘솔이나 윈도우에 메시지를 기록하고 정상적으로 종료한다.
    - **이 단계도 모두 시스템 콜이다!**

</br>

### 응용 프로그래밍 인터페이스

→ ***대부분의 개발자들은 응용 프로그래밍 인터페이스(API)에 따라 프로그램을 설계한다.***

- **API는 각 함수에 전달되어야 할 매개변수들과 기대할 수 있는 반환 값**을 포함하여 응용 프로그래머가 사용 가능한 함수의 집합을 명시한다.
    - API를 구성하는 함수들은 **응용 프로그래머를 대신하여, 실제 시스템 콜을 호출**한다.

</br>

> **왜 응용 프로그래머는 실제 시스템 콜을 부르는 것보다 API에 따라 프로그래밍 하는 것을 선호할까?**

→ **프로그램과의 호환성이 좋다!**

- 자신의 프로그램이 같은 API를 지원하는 어느 시스템에서건 컴파일 되고, 실행된다는 것을 기대한다.
    - 게다가, 실제 시스템 콜은 좀 더 자세한 명세가 필요하고 프로그램상에서 작업하기가 API보다 더 어렵다.

</br>

> **시스템 콜을 처리하는 데 있어 또 다른 중요한 요소는 실행시간 환경(RTE)이다.**
> 

→ 컴파일러, 인터프리터를 포함하여 특정 프로그래밍 언어로 작성된 응용 프로그램을 실행하는 데 필요한 전체 소프트웨어 제품군과 라이브러리, 또는 로더와 같은 다른 소프트웨어를 함께 가리킨다.

- RTE는 **운영체제가 제공하는 시스템 콜에 대한 연결고리 역할을 하는 시스템 콜 인터페이스를 제공**한다.
    - 이 시스템 콜 인터페이스는 **API 호출을 가로채어 필요한 운영체제 시스템 콜**을 부른다.

</br>

> **호출자는 시스템 콜이 어떻게 구현되고, 실행 중 어떤 작업을 하는지 알 필요가 없다.**

<img width="427" alt="image" src="https://user-images.githubusercontent.com/106216912/209807019-9dd60d8e-0ff0-427b-bdff-e60b6d224841.png">

- 단지 API를 준수하고, 결과로 운영체제가 무엇을 할 것인지만 이해하면 된다.
    - 대부분의 자세한 내용은 API에 의해 숨겨지고, RTE에 의해 관리된다.

</br>

> **시스템 콜은 사용되는 컴퓨터에 따라 다른 방법으로 발생한다.**

- 단순히 원하는 시스템 콜이 무엇인지보다 더 많은 정보가 요구될 수도 있다.
    - 필요한 정보의 유형과 양은 특정 운영체제와 호출에 따라 다양하다.

</br>

> **운영체제에 매개변수를 전달하기 위해서 세 가지의 일반적인 방법을 사용한다.**

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/209807135-653b3b40-bebe-4e7b-9bf2-f9e76a8789cb.png">

1. **매개변수를 레지스터 내에 전달**하는 방법
2. **매개변수를 메모리 내의 블록이나 테이블에 저장하고, 블록의 주소를 매개변수로 전달**하는 방법
3. 매개변수의 개수가 5개가 넘으면, **프로그램에 의해 스택에 넣고, 운영체제에 의해 꺼내지는** 방법

</br>

### 시스템 콜의 유형

→ ***시스템 콜은 다섯 가지의 중요한 범주로 묶을 수 있다.***

- **프로세스 제어**
- **파일 조작**
- **장치 조작**
- **정보 유지 보수**
- **통신과 보호**

</br>

> **프로세스 제어(Process Control)**

→ ***실행 중인 프로그램은 수행을 정상적으로(`end()`) 또는 비정상적으로(`abort()`) 종료할 수 있어야 한다.***

- 프로그램을 비정상적으로 중지하기 위해 시스템 콜이 호출되거나 문제가 발생해 오류 트랩을 유발할 경우, 오류 메시지가 생성된다.
    - 이 때 일어나는 덤프는 특별한 로그 파일이나 디스크에 기록되고, 문제의 원인을 결정하기 위해 디버거에 의해 검사될 수 있다.

</br>

- 운영체제는 **명령 인터프리터로 제어를 전달**해야 한다.
    - 대화식 시스템에서 명령 인터프리터는 단순히 다음 명령을 계속 수행하며, 사용자가 오류에 응답하는 적절한 명령을 내릴 것을 가정한다.
    - 명령 인터프리터나 프로그램은 정의한 오류 등급을 사용해서 다음 행동을 **자동으로 결정**할 수 있다.

</br>

- 한 프로그램을 실행하고 있는 프로세스가 **다른 프로그램을 적재(`load()`)하고 실행(`execute()`)** 하기를 원할 수 있다.
    - 이 기능은 명령 인터프리터가 사용자 명령 또는 마우스 클릭을 통해 지시된 프로그램을 실행하는 것을 허용한다.

</br>

→ **여기서 흥미있는 것은 적재된 프로그램이 종료되었을 때 어디로 제어를 되돌려 주느냐 하는 것이다!**

- 기존 프로그램이 유실될지, 보관될지, 새로운 프로그램과 병행하게 실행을 계속하도록 허용할 것인지 하는 문제이다.

</br>

- 만약 **새로운 프로그램이 종료되었을 때 제어가 기존 프로그램으로 되돌아간다면?**
    - **반드시 기존 프로그램 메모리 이미지를 보관**해야 한다.
    - 실질적으로 한 프로그램이 다른 프로그램을 호출하는 기법을 만든 셈이다.
    - 두 프로그램이 병행하게 수행된다면, 다중 프로그래밍 될 새로운 프로세스를 생성한 것이다!
        - ex) `create_process()`

</br>

- 만약 **새로운 잡이나 프로세스, 혹시 잡들이나 프로세스들의 집합을 생성한다면?**
    - 그들의 **실행을 제어**할 수 있어야 한다.
    - 잡의 우선순위, 최대 허용 실행 시간 등을 포함하여 **프로세스들의 속성들을 결정하고, 재설정**해야 한다.
        - `get_process_attributes()` , `set_process_attributes()`
    - 또한, 새로 생성한 프로세스가 잘못되거나 필요 없다면 **종료**할 수 있다.
        - `terminate_process()`

</br>

- 새로운 프로세스를 생성한 후에는, **이들의 실행이 끝나기를 기다려야 할 필요**가 있을 수 있다.
    - 일정 시간만큼 기다리기를 원할 수 있다(`wait_time()`).
    - 특정 이벤트가 일어날 때까지 기다려야 할 수도 있다.
        - `wait_event()`

</br>

- 빈번하게 둘 이상의 프로세스들은 **데이터를 공유**한다.
    - 공유되는 데이터의 일관성을 위해 운영체제는 프로세스가 공유 데이터를 잠글 수 있는 시스템 콜을 제공한다.
        - `acquire_lock()` , `release_lock()`

</br>

→ 프로세스 제어는 많은 측면과 다양성이 있으므로, 이러한 개념들을 **단일 태스킹 시스템과 다중 태스킹 시스템**을 예로 들어본다!

</br>

1. **단일 태스킹 시스템**
- Arduino는 **마이크로 컨트롤러와 다양한 이벤트에 반응하는 입력 센서로 구성된 간단한 하드웨어 플랫폼**이다.
    - Arduino를 작성하려면 먼저 PC에서 프로그램을 작성하고, USB 연결을 통해 컴파일 된 프로그램(스케치)을 Arduino의 플래시 메모리로 업로드한다.

</br>

<img width="283" alt="image" src="https://user-images.githubusercontent.com/106216912/209807356-6fca9c0b-6699-4144-9cae-0c48490ba405.png">

- 표준 Arduino 플랫폼은 운영체제를 제공하지 않는다.
    - 대신, **부트 로더**라고 불리는 작은 소프트웨어가 스케치를 Arduino 메모리의 특정 영역으로 적재한다.
    - 스케치가 적재되면 **실행되기 시작하고 반응하도록 프로그램된 이벤트를 기다린다.**

</br>

→ **Arduino는 한순간에 하나의 스케치만 메모리에 존재할 수 있으므로 단일 태스킹 시스템이다.**

</br>

2. **다중 태스킹 시스템**

<img width="194" alt="image" src="https://user-images.githubusercontent.com/106216912/209807562-d5ee9e00-558d-42ac-81e0-099d3e4c8fba.png">

- FreeBSD는 **다중 태스킹 시스템**의 예로, 사용자가 시스템에 로그인할 때 사용자가 선택한 셸이 수행되어 명령을 기다렸다가 사용자가 요청한 프로그램을 수행한다.
    - 하지만 FreeBSD는 **다중 태스킹 시스템**이기 때문에, **명령 인터프리터는 다른 프로그램이 실행되는 동안 수행을 계속할 수 있다.**

</br>

- 새로운 프로세스를 시작하기 위해 셸은 `fork()` 시스템 콜을 실행한다.
    - 그 후, 선택된 프로그램이 `exec()` 시스템 콜을 통해 메모리에 적재되고, 수행된다.

</br>

- 프로세스가 끝나면 종료하기 위해 `exit()` 시스템 콜을 수행하며, 호출한 프로세스에게 상태 코드 `0` 을 돌려주거나 오류 코드를 돌려준다.

</br>

> **파일 관리(File Management)**

→ ***파일을 다루는 몇 가지 공통적인 시스템 콜을 알아보자.***

- 파일을 생성(`create()`)하고, 삭제(`delete()`)할 수 있어야 한다.
    - 파일이 생성되면 열고(`open()`), 읽고(`read()`), 쓰고(`write()`), 위치 변경(`reposition()`)할 수 있어야 한다.
    - 또한, 파일을 더 이상 사용하지 않을 때 파일 닫기(`close()`)가 필요하다.

</br>

- 파일 시스템이 **디렉터리 구조**를 가진다면, 디렉터리에 대해서도 위와 같은 연산이 필요하다.
    - 또한 파일이나 디렉터리에 대해 속성들의 값을 결정할 수 있어야 하고, 재설정할 수 있어야 한다.

</br>

- 몇몇 운영체제는 파일 이동(`move()`)과 복사(`copy()`)등의 훨씬 더 많은 시스템 콜을 제공한다.

</br>

> **장치 관리(Device Management)**

→ ***프로세스는 작업을 계속 수행하기 위해 추가 자원(주 기억장치, 디스크 드라이브, 파일에 접근)이 필요할 수 있다.***

- 운영체제에 의해 제어되는 **다양한 자원들은 장치로 간주**될 수 있다.
    - 이 장치들의 일부는 물리 장치이고 다른 장치들은 추상적이나 가상적 장치로 생각할 수 있다.

</br>

- 다수의 사용자가 동시에 사용하는 시스템은 독점적인 장치 사용을 보장받기 위해 그 장치를 요청(`request()`)하는 것을 요구한다.
    - 사용이 끝나면, 반드시 방출(`release()`)해야 한다.

</br>

> **정보 유지 관리(Information Maintenance)**

→ ***많은 시스템 콜은 단순히 사용자 프로그램과 운영체제 간의 정보 전달을 위해 존재한다.***

- ex) 현재 시간(`time()`)과 날짜를 되돌려 주는(`date()`) 시스템 콜

</br>

- 다른 시스템 콜 집합은 **프로그램 디버깅**에 도움이 된다.
    - 많은 시스템이 메모리를 덤프(`dump()`)하기 위한 시스템 콜을 제공한다.

</br>

- 많은 운영체제는 **프로그램의 시간 프로파일**을 제공한다.
    - 시간 프로파일은 그 **프로그램이 특정 위치나 위치의 집합에서 수행한 시간의 양**을 나타낸다.
    - 시간 프로파일은 추적 설비나 정규 타이머 인터럽트가 필요하다.

</br>

- 운영체제는 **현재 운영되고 있는 모든 프로세스에 관한 정보**를 가지고 있으며, 이러한 정보에 접근하기 위한 시스템 콜이 있다.

</br>

> **통신(Communication)**

→ ***통신 모델에는 메시지 전달과 공유 메모리 두 가지 일반적인 모델이 있다.***

<img width="428" alt="image" src="https://user-images.githubusercontent.com/106216912/209807868-2f37f4d7-2b68-48f6-a236-aa8d847c2d96.png">

</br>

- **메시지 전달 모델**
    - 통신하는 두 프로세스가 **정보를 교환하기 위해서 서로 메시지를 주고받는다.**
    - 메시지는 **직접 교환되거나, 우편함을 통해서 간접적으로 교환**될 수 있다.
    - 통신이 이루어지기 전에 연결이 반드시 열려야 한다.
    - 상대 통신자의 이름을 반드시 알고 있어야 한다.
    - 연결을 받아들일 프로세스들의 대부분은 **특수 목적의 데몬(daemon)** 으로, 그러한 목적을 위해 제공된 시스템 프로그램이다.
    - 클라이언트로 알려진 통신의 출발지와 서버로 알려진 수신 데몬은 시스템 콜에 의해 메시지를 교환한다.

</br>

- **공유 메모리 모델**
    - **프로세스는 다른 프로세스가 소유한 메모리 영역에 대한 접근을 위해 시스템 콜을 사용**한다.
    - 정상적으로, **운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 막으려 한다.**
        - 공유 메모리는 프로세스가 이러한 제한을 제거하는 데 동의해야 구현할 수 있다.
        - 동의가 있다면, **공유 영역에서 데이터를 읽고 씀으로써 정보를 교환**할 수 있다.
        - 데이터의 형식은 운영체제의 제어가 아닌 이들 프로세스에 의해 결정된다.

</br>

→ **이러한 두 가지 방법은 운영체제에서 보편적이며, 시스템 대부분은 둘 다 구현한다.**

- **메시지 전달은 소량의 데이터를 교환할 때 유용**하다. → 피해야 할 충돌이 없기 때문이다.
    - 또한, **컴퓨터 간의 통신을 위해 메모리 공유보다 구현하기 쉽다.**
- **공유 메모리는 한 컴퓨터 안에서는 메모리 전송 속도로 수행할 수 있으므로, 최대 속도와 편리한 통신을 제공**한다.
    - 하지만 **보호와 동기화 부분에서 여러 문제점**이 있다.

</br>

> **보호(Protection)**

→ ***보호는 컴퓨터 시스템이 제공하는 자원에 대한 접근을 제어하기 위한 기법을 지원한다.***

- 이제는 다중 프로그램 시스템에서만 고려되는 것이 아닌, 서버에서 휴대용 컴퓨터까지 **모든 시스템에서 보호를 고려**해야 한다.
    - 통상 보호를 지원하는 시스템 콜은 파일과 디스크와 같은 자원의 허가 권한을 설정하는 데 이용된다.

---

## 4. 시스템 서비스(System Services)

→ ***현대 시스템의 또 다른 면은 시스템 서비스의 집합체이다.***

- 최하위 수준은 하드웨어, 다음은 운영체제, 그다음은 시스템 서비스, 마지막으로 응용 프로그램이다.

</br>

- 시스템 서비스는, **시스템 유틸리티로도 알려진 프로그램 개발과 실행을 위해 더 편리한 환경을 제공**한다.
    
    → 이들을 몇 가지 범주로 분류할 수 있다.

</br>

- **파일 관리**
    - 파일과 디렉터리를 **생성, 삭제, 복사 개명, 인쇄, 열거, 조작**한다.

</br>

- **상태 정보**
    - 어떤 프로그램들은 시스템에게 **날짜, 시간, 사용 가능한 메모리와 디스크 공간의 양, 사용자 수, 상태 정보**를 묻는다.
    - 다른 프로그램들은 더 복잡하여 **상세한 성능, 로깅 및 디버깅 정보**를 제공한다.
    - 몇몇 시스템은 환경 설정 정보를 저장하고 검색할 수 있는 **등록** 기능을 지원하기도 한다.

</br>

- **파일 변경**
    - 디스크나 다른 저장 장치에 저장된 **파일의 내용을 생성하고 변경하기 위해 다수의 문장 편집기**를 사용할 수 있다.
    - 파일의 내용을 검색하거나 변환하기 위한 특수 명령어가 제공되기도 한다.

</br>

- **프로그래밍 언어 지원**
    - 일반적인 **프로그래밍 언어들에 대한 컴파일러, 어셈블러, 디버거 및 해석기**가 종종 운영체제와 함께 사용자에게 제공되거나, 별도로 다운로드 받을 수 있다.

</br>

- **프로그램 적재와 수행**
    - 프로그램이 어셈블되거나 컴파일된 후, 수행되려면 반드시 **메모리에 적재**되어야 한다.
    - 시스템은 절대 로더, 재배치 가능 로더, 링키지 에디터와 중첩 로더 등을 제공할 수 있다.

</br>

- **통신**
    - 이들 프로그램은 **프로세스, 사용자, 그리고 다른 컴퓨터 시스템들 사이에 가상 접속을 이루기 위한 기법**을 제공한다.
    - 이들 프로그램은 다른 사용자 화면으로 메시지를 전송하거나, 원거리에서 로그인하거나, 파일을 전송할 수 있게 한다.

</br>

- **백그라운드 서비스**
    - 모든 범용 시스템은 부트할 때 특정 시스템 프로그램을 시작시킬 수 있는 방법을 가지고 있다.
    - 이러한 프로세스 중 일부는 작업이 끝나면 종료하는 반면에, **일부는 시스템이 정지될 때까지 계속해서 실행**된다.
        - 항상 실행되는 시스템 프로그램 프로세스는 **서비스, 서브시스템, 데몬**으로 알려져 있다.

</br>

→ 운영체제 대부분은 **시스템 프로그램과 함께 일반적인 문제점을 해결하거나, 일반적인 연산을 수행하는 데 유용한 프로그램들도 제공**한다.

- 이러한 응용 프로그램들은 웹 브라우저, 워드프로세서, 스프레드시트, 데이터베이스 시스템, 컴파일러 등이다.

</br>

> **사용자 대부분이 보는 운영체제의 관점은 실제의 시스템 콜에 의해서보다는 시스템 프로그램과 응용에 의해 정의된다.**

- GUI와 CLI는 동일한 시스템 콜을 사용하지만, 다르게 보이고 다른 방법으로 동작한다.
    - **같은 하드웨어상에서 사용자는 여러 사용자 인터페이스에 순차적 또는 병행하게 노출**된다.

---

## 5. 링커와 로더

→ ***일반적으로 프로그램은 디스크에 이진 실행 파일로 존재한다.***

- CPU에서 실행하려면 **프로그램을 메모리로 가져와 프로세스 형태로 배치**되어야 한다.
    - 이번 절에서는 **프로그램을 컴파일하고 메모리에 배치하여 사용 가능한 CPU에서 실행하기 까지**의 절차를 단계별로 알아보자.

</br>

<img width="391" alt="image" src="https://user-images.githubusercontent.com/106216912/209817237-f0c08d0f-cb0d-4eb4-93c3-111b4f7a10bf.png">

- 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 **오브젝트 파일로 컴파일** 된다.
    - 이러한 형식을 **재배치 가능 오브젝트 파일**이라고 한다.

</br>

- 다음으로 링커는 **재배치 가능 오브젝트 파일을 하나의 이진 실행 파일로 결합**한다.
    - 링킹 단계에서 표준 C 또는 수학 라이브러리와 같은 다른 오브젝트 파일 또는 라이브러리도 포함될 수 있다.

</br>

- 로더는 **이진 실행 파일을 메모리에 적재**하는 데 사용되며, **CPU 코어에서 실행할 수 있는 상태**가 된다.
    - 링크 및 로드와 관련된 활동은 **재배치**로, 프로그램 부분에 **최종 주소를 할당하고, 프로그램 코드와 데이터를 해당 주소와 일치하도록 조정**한다.

</br>

- 로더를 실행하려면 **명령어 라인에 실행 파일의 이름을 입력**하기만 하면 된다.
    - ex) UNIX 시스템의 명령어 라인에 프로그램 이름을 입력하면, 셸은 `fork()` 시스템 콜을 사용해서 새 프로세스를 생성한다.
    - 다음, `exec()` 시스템 콜로 로더를 호출하고, 실행 파일 이름을 전달한다.
    - 그 후, 로더는 새로 생성된 프로세스의 주소 공간을 사용해서 지정된 **프로그램을 메모리에 적재**한다.

</br>

- 시스템 대부분에서는 **프로그램이 적재될 때 라이브러리를 동적으로 링크**할 수 있게 한다.
    - ex) Windows는 **동적 링킹 라이브러리(DLL)** 를 지원한다.
    - 장점 : **실행 파일에서 사용되지 않을 수 있는 라이브러리를 링크하고 로드하지 않아도 된다.**
        - 대신, 라이브러리는 조건부로 링크되며, 프로그램 실행 시간에 필요한 경우 적재된다.

</br>

- 오브젝트 파일 및 실행 파일은 **일반적으로 표준화된 형식**을 가진다.
    - 표준 형식은 컴파일된 기계 코드 및 프로그램에서 참조되는 함수 및 변수에 대한 메타데이터를 포함하는 기호 테이블을 포함한다.
        - ex) UNIX 및 Linux 시스템의 경우 이 표준 형식을 ELF(Executable and Linkable Format)라고 한다.
        - ex) Windows 시스템은 PE(Portable Executable) 형식을 사용하고, macOS는 Mach-O 형식을 사용한다.

---

## 6. 응용 프로그램이 운영체제마다 다른 이유

→ ***기본적으로 한 운영체제에서 컴파일된 응용 프로그램은 다른 운영체제에서 실행할 수 없다.***

- 각 운영체제는 **고유한 시스템 콜 집합**을 제공한다.
    - 시스템 콜은 응용 프로그램이 사용할 수 있도록, 운영체제가 제공하는 서비스 집합의 일부이다.
    - 시스템 콜은 어느 정도 같더라도, **다른 장벽으로 인해 응용 프로그램을 다른 운영체제에서 실행하기 어렵다.**

</br>

→ **다음 세 가지 방법을 사용해서, 응용 프로그램이 여러 운영체제에서 실행될 수 있게 만들 수 있다.**

</br>

1. **응용 프로그램은 운영체제마다 인터프리터가 제공되는 인터프리터 언어로 작성될 수 있다.**
    - 인터프리터는 소스 프로그램의 각 라인을 읽고, 상응하는 기계어 명령을 실행하고, **해당 운영체제의 시스템 콜을 호출**한다.
    - 기계어 코드로 구성된 응용 프로그램에 비해 **성능이 떨어지고**, 인터프리터는 각 운영체제 기능의 일부만 제공하므로 **관련 응용 프로그램의 기능도 제한**될 수 있다.

</br>

2. **응용 프로그램은 실행 중인 응용 프로그램을 포함하고 있는 가상 머신을 가진 언어로 작성될 수 있다.**
    - 가상 머신은 언어 RTE 중 일부이다.
    - ex) Java는 로더, 바이트코드 검증기 및 응용 프로그램을 Java 가상 머신으로 적재하는 기타 구성요소를 RTE로 가지고 있다.
        - 모든 Java 앱의 RTE가 제공되는 어디서나 실행될 수 있다.

</br>

3. **응용 프로그램 개발자는 컴파일러가 기기 및 운영체제 고유의 이진 파일을 생성하는 표준 언어 또는 API를 사용할 수 있다.**
    - 이 방법은 많은 시간이 소요될 수 있으며, 많은 시험과 디버깅을 거쳐 응용 프로그램의 새 버전마다 수행되어야 한다.

</br>

- 이론적으로 이 세 가지 접근 방식은 다양한 운영체제에서 실행될 수 있는 응용 프로그램을 개발하기 위한 간단한 솔루션을 제공하는 것 같다.
    
    → 하지만 **일반적으로 응용 프로그램의 이동성이 부족한 데에는 여러 원인이 있고, 이로 인해 여전히 크로스 플랫폼 응용 프로그램을 개발하는 것은 어렵다.**

</br>

> **시스템의 낮은 수준에는 다른 어려운 점이 존재한다.**

- **각 운영체제에는 헤더, 명령어 및 변수의 배치를 강제하는 응용 프로그램 이진 형식이 있다.**
    - 이러한 구성요소는 명시된 구조 형태로 실행 파일 내에 특정 위치에 있어야 운영체제가 파일을 열고, 응용 프로그램을 적재하여 올바르게 실행할 수 있다.

</br>

- **CPU는 다양한 명령어 집합을 가지며, 해당 명령어가 포함된 응용 프로그램만 올바르게 실행할 수 있다.**

</br>

- **운영체제는 응용 프로그램이 파일 생성과 네트워크 연결 열기와 같은 다양한 활동을 요청할 수 있는 시스템 콜을 제공한다.**
    - 이러한 **시스템 콜은 여러 측면에서 운영체제 마다 다르다.**

</br>

> **이러한 구조적 차이점을 완전히 해결하지는 못했지만, 해결하는데 도움이 되는 몇 가지 방법이 있다.**

- ex) Linux와 거의 모든 UNIX 시스템에서 이진 실행 파일은 ELF 형식을 채택하였다.
    - 공통 표준을 제공하지만, ELF 형식은 특정 컴퓨터 아키텍처와 연관되어 있지 않으므로, 실행 파일이 다른 하드웨어 플랫폼에서 실행될 것이라는 보장은 없다.

</br>

- API는 응용 프로그램 수준에서 특정 기능을 지정한다.
    - 아키텍처 수준에서 이진 코드의 여러 구성요소가 주어진 아키텍처에서 특정 운영체제와 상호 작용할 수 있는 방법을 정의하는데 **ABI(Application Binary Interface)** 가 사용된다.
    - 이진 실행 파일이 특정 ABI에 따라 컴파일되고 링크된 경우, 해당 ABI를 지원하는 다른 시스템에서 실행될 수 있어야 한다.
        - 하지만, ABI는 플랫폼 간 호환성을 거의 제공하지 않는다.

</br>

> **요약 : 이러한 모든 차이점은, 특정 CPU 유형의 특정 운영체제에서 인터프리터, RTE 또는 이진 실행 파일을 저장하고 컴파일하지 않으면 응용 프로그램이 실행되지 않는다는 것을 의미한다.**

---

## 7. 운영체제 설계 및 구현

→ ***이번 절에서는 운영체제를 설계하고 구현할 때, 우리가 직면하는 문제점을 논의한다.***

- 이들 설계 문제점에 대한 완전한 해결책은 없지만 성공적인 접근 방법들이 있다.

</br>

### 설계 목표

→ **시스템을 설계할 때 첫 번째 문제점은 시스템의 목표와 명세를 정의하는 일이다.**

- 시스템 설계는 최상위 수준에서는 **하드웨어와 시스템 유형의 선택에 의해** 영향을 받을 것이다.

</br>

- 이 최상위 설계 수준을 넘어서면 요구 조건들을 일일이 명시하는 것이 어려워진다.
    - 하지만 이러한 요구 조건은 근본적으로 **사용자 목적**과 **시스템 목적**의 두 가지 기본 그룹으로 나눌 수 있다.

</br>

- **사용자들이 시스템에 기대하는 특징**들이 존재한다.
    - 시스템은 사용하기 쉽고, 편리하고, 배우기 쉽고, 믿을 수 있고, 안전하고, 신속해야 한다.
    - 운영체제는 설계, 구현, 유지 보수가 쉬워야 하며, 또한 적응성, 신뢰성, 무오류, 효율성을 가져야 한다.

</br>

> **요약 : 운영체제에 대한 요구를 정의하는 문제를 해결하는 유일한 해법은 없다.** </br>
→ 많은 시스템에서 다른 요구 조건들이 다른 환경을 위해 다양한 해결 방법을 낳을 수 있음을 보여준다.

</br>

### 기법과 정책

→ ***한 가지 중요한 원칙은 기법으로부터 정책을 분리하는 것이다.***

- **기법** : **어떤 일을 어떻게 할 것인가**를 결정하는 것
- **정책** : **무엇을 할 것인가**를 결정하는 것
    - ex) 타이머 구조는 CPU 보호를 보장하기 위한 기법이지만, 특정 사용자들 위해 타이머를 얼마나 오랫동안 설정할지를 결정하는 것은 정책이다.

</br>

- **정책과 기법의 분리는 융통성을 위해 아주 중요**하다.
    - 정책은 장소가 바뀌거나 시간이 흐름에 따라 변경될 수 있다.
    - 최악의 경우에는 정책의 각 변경이 저변에 깔린 기법의 변경을 요구하게 된다.
    - 여러 정책에서 사용되기에는 **충분한 융통성 있는 일반적인 기법이 바람직**하다.

</br>

- 마이크로 커널 기반 운영체제는 프리미티브 빌딩 블록의 기본 집합을 구현함으로써, 기법과 정책의 분리를 극단적으로 추구한다.
    - 이 블록들은 정책으로부터 거의 자유로우며, 더 고급의 기법과 정책들이 사용자 생성 커널 모듈이나 사용자 프로그램 자체를 통해 첨가될 수 있도록 한다.

</br>

- **정책 결정은 모든 자원 할당 문제에 있어서 중요**하다.
    - 자원의 할당 여부를 결정할 필요가 있을 때마다 정책 결정을 해야 한다.
    - 질문이 **무엇이 아니라 어떻게일때마다, 반드시 결정되어야 하는 것은 기법**이다.

</br>

### 구현

→ ***운영체제의 설계가 완료되면 구현되어야 한다.***

- 운영체제는 많은 사람에 의해 오랫동안 개발된 많은 프로그램의 집합체이기 때문에, **구현 방법에 대해 일반적인 언급을 하는 것은 어렵다.**

</br>

- 초기 운영체제는 **어셈블리 언어**로 작성되었다.
    - 이제 대부분은 C 또는 C++과 같은 고급 언어로 작성되며, 극히 일부의 시스템만이 어셈블리 언어로 작성된다.

</br>

- 실제로, 둘 이상의 고급 언어가 종종 사용된다.
    - 커널의 최하위 레벨은 어셈블리 언어 및 C로 작성될 수 있다.
    - 상위 레벨 루틴은 C 및 C++로 작성될 수 있으며, 시스템 라이브러리는 C++ 또는 상위 레벨 언어로 작성될 수 있다.

</br>

- Android가 좋은 예이다.
    - 커널은 대부분 약간의 어셈블리 언어를 함께 사용하고, C로 작성되었다.
    - Android 시스템 라이브러리는 C 또는 C++로 작성되었고, 시스템에 개발자 인터페이스를 제공하는 프레임워크는 대부분 Java로 작성된다.

</br>

- **운영체제를 구현하기 위해 고급 언어나 최소한 시스템 구현 언어를 사용함으로써 생기는 장점**이 있다.
    - **코드를 빨리 작성할 수 있으며, 간결하고, 이해하기 쉽고, 디버그하기도 쉽다.**
    - 컴파일러 기술의 향상은 단순한 재 컴파일에 의해 전체 운영체제를 위해 생성된 코드를 향상시킬 것이다.
    - 운영체제가 고급 언어로 작성된 경우, **다른 하드웨어로 이식하기 훨씬 쉽다.**

</br>

- **운영체제를 고급 수준 언어로 구현하는 것에 대한 단점**도 존재한다.
    - **속도가 느리고 저장 장치가 많이 소요**된다.
    - 하지만 현재의 시스템에서는 주된 문제가 될 수 없다.

</br>

> **운영체제의 주요 성능 향상은 우수한 어셈블리어 코드보다는, 좋은 자료구조와 알고리즘의 결과일 가능성이 크다.**

---

## 8. 운영체제 구조

→ ***운영체제와 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있으려면 신중히 제작되어야 한다.***

- 일반적인 접근 방법은 **한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분할**하는 것이다.
    - 이번 절에서는 구성요소들이 어떤 방법으로 상호 연결되고, 하나의 커널로 결합되는지를 알아본다.

</br>

### 모놀리식 구조(Monolithic Structure)

→ ***운영체제를 구성하는 가장 간단한 구조는 구조가 아예 없는 것이다.***

- 즉, **커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는 것**이다.
    - **모놀리식 구조**라고 하는 이 방법은 운영체제를 설계하는 일반적인 기술이다.

</br>

- 제한적인 구조를 가진 운영체제의 예는 최초의 UNIX 운영체제로, 커널과 시스템 프로그램의 두 부분으로 구성된다.
    - 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데, 이들은 UNIX가 발전해 오면서 여러 해 동안 추가되고 확장된 것이다.

</br>

<img width="483" alt="image" src="https://user-images.githubusercontent.com/106216912/209856166-16316ce5-3c3e-49f4-aacf-b8499ac1ad37.png">

- 전통적인 UNIX 운영체제는 **계층**들로 이루어졌다.
    - 시스템 콜 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널로, 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 등의 기능을 제공한다.
        - **하나의 주소 공간으로 결합하기에는 너무 많은 기능**이다.

</br>

<img width="247" alt="image" src="https://user-images.githubusercontent.com/106216912/209856348-cbc6dd03-8252-40f0-a89e-ea359d82882f.png">

- Linux 운영체제는 UNIX에 기반을 두고 있다.
    - Linux 커널은 단일 주소 공간에서 커널 모드로 전부 실행된다는 점에서 모놀리식이지만, **런타임 중에 커널을 수정할 수 있는 모듈식 설계**이다.

</br>

→ **모놀리식 커널은 구현 및 확장하기 어렵다.**

</br>

> **모놀리식 커널은 성능 면에서 뚜렷한 이점이 있다.**

- **시스템 콜 인터페이스에는 오버헤드가 거의 없고, 커널 안에서의 통신 속도가 빠르다!**

</br>

### 계층적 접근(Layered Approach)

→ ***모놀리식 구조는 한 부분을 변경하면, 다른 부분에 광범위한 영향을 줄 수 있으므로 밀접하게 결합된 시스템으로 불린다.***

- 대안으로 **느슨하게 결합된 시스템**을 설계할 수 있다.

</br>

- 이러한 시스템은 기능이 **특정 기능 및 한정된 기능을 가진 개별적이며 작은 구성요소로 나뉜다.**
    - 이 모든 구성요소가 합쳐져 커널을 구성한다.

</br>

> **모듈 방식의 장점 : 한 구성요소의 변경이 해당 구성요소에만 영향을 미치고, 다른 구성요소에는 영향을 미치지 않는다.**

→ 시스템 구현자가 시스템 내부 작동을 더 자유롭게 생성하고 변경할 수 있다!

</br>

<img width="296" alt="image" src="https://user-images.githubusercontent.com/106216912/209856680-e461e102-3563-42b1-a630-45aa2f709571.png">

- 시스템은 다양한 방식으로 **모듈화**될 수 있다.
    - 한 가지 방식이 **계층적 접근 방식**인데, 이 방식에서는 **운영체제가 여러 층**으로 나뉜다.

</br>

- 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상된 객체의 구현이다.
    - 전형적인 운영체제 층은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성된다.
    - 운영체제 층은 다시 하위층에 대한 연산을 호출할 수 있다.

</br>

> **계층적 접근 방식의 장점 : 구현과 디버깅이 간단하다.**

- **층들은 단지 자신의 하위층들의 서비스와 기능들만을 사용하도록 선택**된다.
    - 이러한 접근 방법은 시스템의 검증과 디버깅 작업을 단순화한다.

</br>

- 첫 번째 층은 하드웨어만을 사용하여 이 층의 기능을 구현하기 때문에, **나머지 시스템에 아무런 신경을 쓰지 않고 디버깅**할 수 있다.
    - 첫 번째 층의 디버깅이 끝나면 두 번째 층을 디버깅하는 동안 그것이 정확하게 동작한다고 가정할 수 있다.
    - 또한 이러한 과정이 반복된다.
    - 만약 **어느 층의 디버깅 중 오류가 발견되면, 그 하위의 층은 이미 디버깅되었기 때문에 오류는 반드시 그 층에 있다.**
        
        → **시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해진다!**

</br>
        

- 각 층은 **자신보다 하위 수준의 층에 의해 제공된 연산들만 사용해 구현**한다.
    - 한 층은 이러한 연산들이 어떻게 구현되었는지 알 필요가 없고, 무엇을 하는지만 알면 된다.
        
        → 각 층은 특정 데이터 구조, 연산, 그리고 하드웨어의 존재를 상위층에게 숨기게 된다.
        
</br>

- 계층화된 시스템은 컴퓨터 네트워크 및 웹 응용 프로그램에서 성공적으로 사용됐다.
    - 하지만 **순수한 계층 접근 방식을 사용하는 운영체제는 비교적 적다.**

</br>

> **계층적 접근 방식의 단점**
> 
- **각 계층의 기능을 적절히 정의해야 하는 문제**와 관련이 있다.
- 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하므로 **오버헤드가 발생할 수 있다.**

</br>

→ **하지만 어느 정도의 계층화는 현대 운영체제에서 공통적**이다.

- 시스템의 발달로 인해 층 기능의 정의 및 상호작용의 문제를 피하면서, 모듈화된 코드의 장점을 최대한 활용할 수 있다.

</br>

### 마이크로커널(MicroKernels)

→ ***초기 UNIX가 모놀리식 구조를 이용했지만, UNIX가 확장함에 따라 커널이 커지고 관리하기 힘들어졌다.***

- 따라서, 대학교의 연구자 들이 **마이크로커널 접근 방식**을 사용해서 커널을 모듈화한 Mach라 불리는 운영체제를 개발하였다.
    - 이 방법은 **모든 중요치 않은 구성요소를 커널로부터 제거하고, 그들을 별도의 주소 공간에 존재하는 사용자 수준 프로그램으로 구현하여 운영체제를 구성하는 방법**이다.
        - 결과는 **더 작은 커널**이다.

</br>

> **마이크로커널의 주 기능은 클라이언트 프로그램과 사용자 공간에서 수행되는 다양한 서비스 간에 통신을 제공하는 것이다.**

- 클라이언트와 서비스는 직접 상호 작용하지 않고, **마이크로커널과 메시지를 교환함으로써 간접적으로 상호 작용** 한다.

</br>

> **마이크로커널 접근법의 한 가지 장점 : 운영체제의 확장이 쉽다.**

- **모든 새로운 서비스는 사용자 공간에 추가되며, 커널을 변경할 필요가 없다.**
    - 마이크로커널이 작은 커널 이기 때문에 커널이 변경되어야만 할 때는, 변경할 대상이 비교적 적다.
        - **결과적으로 한 하드웨어로부터 다른 하드웨어로의 이식이 쉽다.**

</br>

- 마이크로 커널은 서비스 대부분이 커널이 아니라 사용자 프로세스로 수행되기 때문에, **더욱 높은 보안성과 신뢰성을 제공**한다.
    - 서비스가 잘못되더라도 운영체제의 다른 부분은 아무런 영향을 받지 않는다.

</br>

- 마이크로커널 운영체제의 예시
    - ex) macOS 및 iOS 운영체제의 커널 구성요소인 Darwin
    - ex) 실시간 운영체제인 QNX

</br>

> **마이크로커널 접근법의 단점 : 가중된 시스템 기능 오버헤드 때문에 성능이 나빠진다.**

- 두 개의 사용자 수준 서비스가 통신해야 하는 경우, 별도의 주소 공간에 서비스가 존재하기 때문에 메시지가 복사되어야 한다.
    - 운영체제는 메시지를 교환하기 위해 한 프로세스에서 다음 프로세스로 전환해야 할 수도 있다.

</br>

### 모듈(Modules)

→ ***운영체제를 설계하는 데 이용되는 최근 기술 중 최선책은 적재가능 커널 모듈(LKM) 기법의 사용이다.***

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/209856970-dada2e56-2e1f-49c8-bcb6-ce0478278eab.png">

- 이 접근법에서 **커널은 핵심적인 구성요소의 집합을 가지고 있고, 부팅 때 또는 실행 중에 부가적인 서비스들을 모듈을 통하여 링크**할 수 있다.

</br>

- 설계의 주안점은 **커널은 핵심 서비스를 제공하고, 다른 서비스들은 커널이 실행되는 동안 동적으로 구현하는 것**이다.
    - 서비스를 동적으로 링크하는 것은 새로운 기능을 직접 커널에 추가하는 것보다 바람직하다.
        - 이 경우, 수정 사항이 생길 때마다 커널을 다시 컴파일해야 한다.

</br>

- 전체적인 결과는 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조를 닮았다.
    - 그러나 **모듈에서 임의의 다른 모듈을 호출할 수 있다는 점에서 계층 구조보다 유연하다!**

</br>

- 중심 모듈은 단지 핵심 기능만 가지고, 다른 모듈의 적재 방법과 모듈들과 어떻게 통신하는지 안다는 점은 마이크로 커널과 유사하다.
    - 하지만 **통신하기 위해서 메시지 전달을 호출할 필요가 없기 때문에 더 효율적이다!**

</br>

### 하이브리드 시스템(Hybrid Systems)

→ ***엄격하게 정의된 하나의 구조를 채택한 운영체제는 거의 존재하지 않는다.***

- **다양한 구조를 결합해서 성능, 보안 및 편리성 문제를 해결하려는 혼용 구조로 구성**된다.

</br>

> **macOS와 iOS**

→ ***구조적으로 이 둘은 공통점이 많으므로, 공유하는 내용과 서로 다른점을 강조한다.***

<img width="296" alt="image" src="https://user-images.githubusercontent.com/106216912/209857148-cef9f21d-015e-47a6-b9fd-24ac8f26934f.png">

- 다양한 층의 주요 특징은 다음과 같다.

</br>

- **사용자 경험 층(user experience)**
    - 이 층은 사용자가 컴퓨팅 장치와 상호 작용할 수 있는 소프트웨어 인터페이스를 정의한다.
        - macOS는 마우스 또는 트랙패드 용으로 설계된 사용자 인터페이스를 사용하고, iOS는 터치 장치용으로 설계된 사용자 인터페이스를 사용한다.

</br>

- **응용 프로그램 프레임워크 층(application frameworks)**
    - 이 층에는 Cocoa 및 Cocoa Touch 프레임워크가 포함되며, Objective-C 및 Swift 프로그래밍 언어에 대한 API를 제공한다.

</br>

- **핵심 프레임워크(core frameworks)**
    - 이 층은 Quicktime 및 OpenGL을 포함한 그래픽 및 미디어를 지원하는 프레임워크를 정의한다.

</br>

- **커널 환경(kernel environment)**
    - 이 환경에는 Mach 마이크로커널과 BSD UNIX 커널이 포함된다.

</br>

- **응용 프로그램은 사용자 경험 기능을 이용하거나, 그러지 않고 응용 프로그램 프레임워크 또는 핵심 프레임워크와 직접 상호 작용하도록** 설계될 수 있다.
    - 또한 프레임워크를 완전히 버리고, 커널 환경과 직접 통신할 수도 있다.

</br>

> **macOS와 iOS의 중요한 차이점**

- **macOS** : 데스크톱 및 랩톱 컴퓨터 시스템용이므로, Intel 아키텍처에서 실행되도록 컴파일된다.
    - 개발자는 공개적으로 사용할 수 있다.
- **iOS** : 모바일 장치용으로 설계되었으므로, ARM 기반 아키텍처용으로 컴파일 된다.
    - 개발자에게 훨씬 더 제한적이며, 폐쇄적이다.
    - 엄격한 보안 설정이 있다.

</br>

→ 이제 **하이브리드 구조를 사용하는 Darwin**에 초점을 맞춘다.

<img width="246" alt="image" src="https://user-images.githubusercontent.com/106216912/209857250-e81dd92a-d220-4a62-95d3-c76d0f75743a.png">

- Darwin은 주로 **Mach 마이크로커널과 BSD UNIX 커널로 구성된 계층화된 시스템**이다.
    - Mach 시스템 콜(트랩)과 BSD 시스템 콜 두 개의 시스템 콜 인터페이스를 제공한다.
    - 이러한 시스템 콜에 대한 인터페이스는 표준 C 라이브러리뿐만 아니라, 네트워킹, 보안 및 프로그래밍 언어 지원을 제공하는 라이브러리를 포함하는 풍부한 라이브러리 집합이다.

</br>

- 시스템 콜 인터페이스 아래에서 Mach는 메모리 관리, CPU 스케줄링 및 메시지 전달 및 원격 프로시저 호출(RPC)과 같은 프로세스 간 통신 기능을 포함한 기본 운영체제 서비스를 제공한다.
    - Mach에서 제공하는 대부분의 기능은 **커널 추상화**를 통해 사용 가능하다.

</br>

> **Android**

→ ***Android 스마트폰과 태블릿을 위해 개발되었다.***

- Android는 다양한 모바일 플랫폼에서 실행되며, 공개 소스이다.

</br>

<img width="248" alt="image" src="https://user-images.githubusercontent.com/106216912/209857381-2d9eb805-912e-445a-bfb9-896c5e365889.png">

- Android는 **그래픽, 오디오 및 하드웨어 기능을 지원하는 다양한 프레임워크를 제공하는 계층화된 소프트웨어  스택**이라는 점에서 iOS와 유사하다.

</br>

- Android 장치의 소프트웨어 설계자는 Java로 응용 프로그램을 개발하지만, **표준 Java API를 사용하지 않고 별도의 Android API를 설계**하였다.

</br>

- Java 응용 프로그램은 ART에서 실행할 수 있는 형식으로 컴파일된다.
    - ART는 Android용으로 설계되어, 메모리와 CPU 처리 능력이 제한적인 모바일 장치에 최적화된 가상 머신이다.
        - 많은 Java 가상 머신이 JIT(just-in-time) 컴파일을 수행하는 반면, ART는 **AOT(ahead-of-time) 컴파일을 수행**한다.

</br>

- Google은 소프트웨어 스택 맨 아래의 Linux 커널을 모바일 시스템의 특수한 요구를 지원하기 위해 수정하였다.

---

## 9. 운영체제 빌딩과 부팅

→ ***하나의 특정 기기 구성에 맞게 운영체제를 설계, 코딩 및 구현할 수 있다.***

- 하지만, 운영체제는 일반적으로 **모든 종류의 컴퓨터에서 실행되도록** 설계된다.

</br>

> **Linux를 위한 Windows 서브시스템**

<img width="432" alt="image" src="https://user-images.githubusercontent.com/106216912/209897858-96679ebd-69b0-42d6-a95e-d66adca94276.png">

- Windows는 다른 운영체제 환경을 에뮬레이트 하기 위해 **서브시스템을 제공하는 하이브리드 구조**를 사용한다.
    - 이러한 사용자 모드 서브시스템은, 실제 서비스를 제공하기 위해 Windows 커널과 통신한다.
    - Windows 10에는 WSL이 추가되어 네이티브 Linux 응용 프로그램을 Windows 10에서 실행할 수 있다.

</br>

### 운영체제 생성

→ ***일반적으로 컴퓨터 시스템은 구매 시 운영체제가 이미 설치되어 있다.***

- 하지만 운영체제를 바꾸거나, 운영체제가 없는 컴퓨터를 구매하면?

</br>

> **운영체제를 처음부터 생성하는 경우 다음 절차를 밟아야 한다.**

1. 운영체제 소스 코드를 작성하거나, 이전에 작성된 소스 코드를 확보한다.
2. 운영체제가 실행될 시스템의 운영체제를 구성한다.
3. 운영체제를 컴파일한다.
4. 운영체제를 설치한다.
5. 컴퓨터와 새 운영체제를 부팅한다.

</br>

- 시스템을 구성하려면 어떤 기능이 포함되는지 명시해야 하며, 이는 운영체제에 따라 다르다.
    - 시스템 구성 방법을 설명하는 매개변수는 특정 유형의 구성 파일에 저장되고, 이후에는 여러 가지 방법으로 사용할 수 있다.

</br>

- 시스템 관리자가 이 파일을 이용하여 운영체제 소스 코드의 사본을 수정할 수 있고, 그 후 운영체제가 완전히 컴파일 된다(**시스템 빌드**).

</br>

- 상세한 조정을 할 수 없다면 **시스템 설명을 통해 기존 라이브러리에서 사전 컴파일된 오브젝트 모듈을 선택**할 수 있다.
    - 지원되는 모든 I/O 장치의 장치 드라이버를 포함한 라이브러리에서 필요한 것만 선택해서 운영체제에 링크할 수 있다.

</br>

- 완전히 **모듈 방식**으로 시스템을 구성할 수도 있다.

</br>

> **접근 방식의 주요 차이점 : 생성된 시스템의 크기 및 일반성과 하드웨어 구성이 변경될 때 변경이 얼마나 쉬운가?**

- 임베디드 시스템의 경우 첫 번째 방식을 사용한다.
- 컴퓨터와 모바일 장치를 지원하는 대부분의 최신 운영체제는 두 번째 접근 방식을 사용한다.

</br>

→ **운영체제는 여전히 특정 하드웨어 구성을 위해 생성되지만, 적재가능 커널 모듈같은 기술을 사용하면 시스템의 구성 변경을 위한 모듈 방식을 지원할 수 있다.**

</br>

> **Linux 시스템을 처음부터 빌드하는 방법**

1. [http://www.kernel.org](http://www.kernel.org) 에서 Linux 소스 코드를 다운로드 한다.
2. `make menuconfig` 명령을 사용하여 커널을 구성한다.
3. `make` 명령을 사용해서 메인 커널을 컴파일 한다.
4. `make modules` 명령을 사용하여 커널 모듈을 컴파일 한다.
5. `make modules install` 명령을 사용하여 커널 모듈을 vmlinuz에 설치한다.
6. `make install` 명령을 입력해서 시스템에 새 커널을 설치한다.

→ Ubuntu를 사용하는 방법도 있다!

</br>

### 시스템 부트

→ ***운영체제가 생성된 후에는 하드웨어에서 새 운영체제를 사용할 수 있어야 한다.***

- 하지만 **하드웨어는 커널의 위치, 커널을 적재하는 방법을 어떻게 알 수 있을까?**
    - 커널을 적재해서 컴퓨터를 시작하는 과정을 **시스템 부팅**이라고 한다.

</br>

> **시스템 대부분의 부팅 과정**

1. 부트스트랩 프로그램 또는 부트 로더라고 불리는 작은 코드가 커널의 위치를 찾는다.
2. 커널이 메모리에 적재되고 시작된다.
3. 커널은 하드웨어를 초기화한다.
4. 루트 파일 시스템이 마운트 된다.

</br>

- 일부 컴퓨터 시스템은 **다단계 부팅 과정**을 사용한다.
    - 컴퓨터 전원을 처음 켜면 **BIOS**라고 하는 **비휘발성 펌웨어에 있는 소형 부트 로더**가 실행된다.
    - BIOS는 일반적으로 **부트 블록이라고 하는, 디스크에 정해진 위치에 있는 두 번째 부트 로더를 적재하는 작업만** 한다.

</br>

- 많은 최신 컴퓨터 시스템이 BIOS 기반 부팅 과정을 **UEFI(Unified Extensible Firmware Interface)** 로 대체했다.
    - 64비트 시스템을 사용하고, 용량이 큰 디스크를 잘 지원한다.
    - 다단계 BIOS 부팅 과정보다 빠르다.

</br>

- **부트스트랩 프로그램은 다양한 작업을 수행**할 수 있다.
    - 진단을 실시해서 메모리와 CPU를 점검하고, 장치 검색과 같은 시스템 상태를 확인한다.
    - 시스템의 모든 측면을 초기화 할 수 있다.
    - 운영체제를 시작하고 루트 파일 시스템을 마운트 한다.
        - 여기까지 완료가 되면, 시스템이 **실행 중**이라고 할 수 있다.
    - ex) GRUB - Linux와 UNIX 시스템을 위한 공개 소스 부트스트랩 프로그램

</br>

- 모바일 시스템의 부팅 과정은 PC와는 약간 다르다.
    - 커널은 Linux 기반이지만, Android는 GRUB를 사용하지 않고 부트 로더의 제공을 벤더에게 맡긴다.

</br>

> **대부분의 운영체제의 부트 로더는 하드웨어 문제 진단, 손상된 파일 시스템 복구 및 운영체제 재설치 등의 작업을 할 수 있는 복구 모드, 또한 단일 사용자 모드로 부팅할 수 있는 기능을 제공한다.**

---

## 10. 운영체제 디버깅

→ ***디버깅은 하드웨어와 소프트웨어에서의 시스템의 오류를 발견하고 수정하는 행위이다.***

- 성능 문제도 버그로 간주되므로, 시스템에서 처리 중에 발생하는 **병목 현상**을 제거하여 성능을 향상시키려는 성능 조정도 디버깅이다.

</br>

### 장애 분석

→ ***프로세스가 실패했다면, 운영체제 대부분은 시스템 관리자 또는 문제를 발생시킨 사용자에게 경고하기 위해 오류 정보를 로그 파일에 기록한다.***

- 운영체제는 또한, 프로세스가 사용하던 메모리를 캡처한 코어 덤프(core dump)를 취하고, 차후 분석을 위해 파일로 저장한다.

</br>

- 사용자 수준 프로세스 코드를 디버깅하는 것은 도전적인 일이다.
    - 커널의 크기와 복잡도도 그렇고, 하드웨어 제어 및 사용자 수준 디버깅 도구가 없다.
        - 따라서, **운영체제 커널을 디버깅하는 것은 훨씬 복잡**하다.

</br>

- **커널 장애 : 크래시(crash)**
    - 프로세스 장애와 마찬가지로 오류 정보가 로그 파일에 저장되고, 메모리의 상태가 크래시 덤프(crash dump)에 저장된다.

</br>

> **운영체제 디버깅과 프로세스 디버깅은 종종 두 태스크의 근본적인 차이에 의해 서로 다른 도구와 기법을 사용한다.**

→ 파일 시스템 코드 때문에 발생한 커널 장애는 **재부팅 전에 커널의 상태를 파일 시스템에 저장하려는 시도를 위험하게** 한다.

- 일반적인 기법은 **커널의 메모리 상태를 이 용도를 위해 예약된 파일 시스템을 가지지 않은 디스크의 특정 부분에 저장하는 것**이다.
    - 커널이 복구 불가능한 오류를 탐지하면, 메모리의 전체 내용이 아니더라도 적어도 시스템 메모리의 커널이 소유한 부분이라도 이 디스크 영역에 저장한다.
    - 시스템이 재부팅 되면, 프로세스는 이 영역으로부터 데이터를 수집하고 분석을 위해 파일 시스템의 크래시 덤프 파일에 기록한다.

→ **이런 전략은 프로세스를 디버깅 할 때는 필요하지 않다!**

</br>

### 성능 관찰 및 조정

→ ***성능 조정은 처리 병목 지점을 제거함으로써 성능을 향상시킬 수 있다.***

- **병목 지점**을 발견하기 위해 시스템 성능을 감시할 수 있다.
    - 따라서 **시스템 동작을 측정하고 표시할 수 있는 방법**을 가지고 있어야 한다.

</br>

- 도구는 프로세스별, 또는 시스템 전체의 관찰을 제공하느냐로 특징이 묘사될 수 있다.
    - 관찰을 위해 도구는 **카운터**, 또는 **추적**의 두 가지 접근 방식 중 하나를 사용할 수 있다.

</br>

> **카운터(Counters)**

→ ***운영체제는 일련의 카운터를 통해 호출된 시스템 콜 횟수, 네트워크 장치 또는 디스크에 수행된 작업 수와 같은 시스템 활동을 추적한다.***

- ex) **카운터**를 사용하는 Linux 도구
    - 프로세스별
        - `ps` : 하나의 프로세스 또는 선택된 프로세스에 대한 정보를 보고
        - `top` : 현재 프로세스에 대한 실시간 통계를 보고
    - 시스템 전체
        - `vmstat` : 메모리 사용량 통계를 보고
        - `netstat` : 네트워크 인터페이스에 대한 통계를 보고
        - `iostat` : 디스크의 I/O 사용량을 보고

</br>

- Windows 시스템은 **Windows 작업 관리자**를 제공한다.
    - 현재 실행중인 응용 프로그램, 프로세스, CPU, 메모리 사용 및 네트워크 통계를 보여준다.

</br>

> **Kernighan’s 법칙
→ “애초에 디버깅은 코드를 작성하는 것보다 두 배 어렵다. 그러므로 가능한 한 영리하게 코드를 작성한다면, 정의에 따라 디버깅 할 만큼 똑똑할 수는 없다.”**

</br>

### 추적

→ ***카운터 기반 도구는 커널에서 유지 관리하는 특정 통계의 현재 값에 대해 간단히 문의한다.***

- 반면, **추적 도구는 시스템 콜과 관련된 단계와 같은 특정 이벤트에 대한 데이터를 수집**한다.

</br>

- ex) 이벤트를 추적하는 Linux 도구
    - 프로세스별
        - `strace` : 프로세스에 의해 호출된 시스템 콜을 추적
        - `gdb` : 소스 레벨 디버거
    - 시스템 전체
        - `perf` : 리눅스 성능 도구 모음
        - `tcpdump` : 네트워크 패킷을 수집

</br>

> **운영체제가 실행됨에 따라 이해, 디버그 및 조정을 더 쉽게 하는 것은 활발한 연구 및 실무 영역이다.**

- 새로운 세대의 커널 가능 성능 분석 도구는, 이 목표를 달성하는 방법을 크게 개선했다!

</br>

### BCC

→ ***사용자 수준과 커널 코드의 상호 작용을 디버깅하는 것은, 양쪽의 코드를 이해하고 상호작용을 계측할 수 있는 도구 없이는 거의 불가능하다.***

- 그런 도구 집합이 유용하려면?
    - **디버깅을 염두에 두지 않고 작성된 부분을 포함한 시스템의 어느 부분도 디버깅**할 수 있어야 한다.
    - 그 작업을 **시스템의 안정성을 해치지 않고** 할 수 있어야 한다.

</br>

> **이상적으로는 사용하지 않을 경우에는 성능에 전혀 영향을 주지 않고, 사용 중일 때는 그에 비례하게 성능에 영향을 주어야 한다.**

→ **BCC 도구 집합**은 이러한 요구 조건을 만족시키면서, 동적이고 안전하며 낮은 영향력을 미치는 디버깅 환경을 제공한다.

</br>

> **BCC(BPF Complier Collection)**

→ ***Linux 시스템을 위한 추적 기능을 제공하는 풍부한 툴킷이다.***

- BCC는 eBPF 도구에 대한 프론트엔드 인터페이스이다.
    - eBPF 프로그램은 C의 부분집합을 사용하며, eBPF 명령어로 컴파일 된다.
    - eBPF 명령어는 **특정 이벤트를 캡처하거나, 시스템 성능을 관찰**하는 데 사용될 수 있다.
    - eBPF 명령어가 올바르게 작동하는 것을 보장하기 위해 Linux 커널에 삽입하기 전에, **검증기**를 통과해야 한다.