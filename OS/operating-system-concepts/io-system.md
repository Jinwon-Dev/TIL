## 1. 개관

→ ***컴퓨터에 연결된 장치들을 제어하는 일은 운영체제의 주요 관심사이다.***

- 입출력 장치들은 기능이나 속도 면에서 매우 다양한 특성을 보이기 때문에, 각각의 특성에 맞는 제어가 필요하다.
    - 다양한 제어 방법들이 커널의 **입출력 서브시스템**을 형성한다.

</br>

> **입출력 장치 관련 기술들은 두 가지의 상충하는 궤도를 따라간다.**
> 
- 한편으로는 관련 인터페이스의 표준화가 늘어나고 있다는 것이다.
    - 이런 경향은, 새로 나오는 장치들이 기존 시스템에 쉽게 결합할 수 있도록 하기 위함이다.
- 다른 한 경향으로는, 입출력 장치가 갈수록 다양해진다.
    - 몇몇 장치들을 컴퓨터나 운영체제에 결합하는 것은, 하드웨어와 소프트웨어 기술의 조합에 의해 해결될 수 있다.

</br>

> **장치 드라이버**
> 
- 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이러한 인터페이스를 그보다 상위층인 커널의 입출력 서브시스템에 제공해 준다.

---

## 2. 입출력 하드웨어

> **하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신한다.**
> 
- 이들 장치는 **포트(port)** 라고 불리는 연결점을 통해 컴퓨터와 접속된다.
    - 만약 하나 이상의 장치들이 공동으로 여러 선을 사용한다면, 이러한 선을 **버스(bus)** 라고 부른다.
    - 버스의 정의는, 회선의 집합으로써 이를 통해 어떻게 해야 메시지를 주고받을 수 있는지를 정한 프로토콜까지를 포함한다.

</br>

> **데이지 체인(daisy chain)**

→ ***장치 A가 B에 연결되고, B가 C, 이어 C가 컴퓨터의 포트에까지 연결되어 있는 것***

- 통상 하나의 버스처럼 동작한다.

</br>

> **버스는 컴퓨터 구조에서 널리 사용되고 신호 방식, 속도, 처리량 및 연결 방식에 따라 다양한 종류가 있다.**
> 
<img width="471" alt="image" src="https://user-images.githubusercontent.com/106216912/224350132-942cc145-6986-483c-820e-bbb767312ceb.png">

- **PCI 버스**가 프로세서-메모리 서브시스템을 고속 장치와 키보드와 직렬, USB 포트처럼 상대적으로 느린 장치들을 연결하는 **확장 버스**에 연결하는 모습이다.
    - 왼쪽 하단은 네 개의 디스크가 SAS 컨트롤러에 접속된 **직렬 연결 SCSI 버스**에 연결되어 있는 것을 볼 수 있다.

</br>

> **컨트롤러는 포트, 버스 또는 장치를 작동할 수 있는 전자장치 집합체이다.**
> 
- 직렬 포트 컨트롤러는 간단한 장치 컨트롤러이다.
    - 직렬 포트의 전선에 나타나는 전기신호를 제어하는 데 쓰이고, 하나의 칩으로 나온다.
    - 반대로 **광섬유 채널(FC)** 버스 컨트롤러는 간단하지 않다.
        - 복잡하고, PC가 아닌 데이터 센터에서 사용되기 때문에 종종 컴퓨터의 버스에 연결되는 별도의 회로 보드 또는 **호스트 버스 어댑터(HBA)** 로 구현된다.

</br>

### 메모리 맵드 입출력

→ ***입출력 전송을 하기 위해 처리기는 어떻게 명령어와 데이터를 컨트롤러에 전달할까?***

- 모든 컨트롤러는 레지스터를 가지고 있다.
    - 본체의 프로세서는 이들 컨트롤러의 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 수행한다.
    - 이러한 통신을 수행하는 한 방법은 “특별한 입출력 명령어”를 사용하는 것이다.

</br>

> **메모리 맵드 입출력(memory-mapped I/O) 방식**
>
→ ***특수 입출력 명령어를 가지는 대신, 장치 제어 레지스터를 프로세스의 주소 공간으로 사상한다.***

- 이 경우, 각 주변 장치 레지스터들은 메모리 주소와 일대일 대응된다.
    - CPU는 물리 메모리에 사상된 장치-제어 레지스터를 읽고 쓸 때 표준 데이터 전송 명령을 사용함으로써 입출력 요청을 수행하게 된다.

</br>

> **입출력 장치 컨트롤러는 네 개의 레지스터로 구성되어 있다.**
> 
- **입력 레지스터**
    - 호스트가 입력을 얻기 위해 읽기를 수행한다.

</br>

- **출력 레지스터**
    - 호스트가 데이터를 출력하기 위해 쓰기를 수행한다.

</br>

- **상태 레지스터**
    - 호스트가 읽는 용도이며, 현재의 명령이 완료되었는지, 입력 레지스터로부터 한 바이트를 읽어도 되는지, 오류가 있었는가와 같은 상태들을 보고한다.

</br>

- **제어 레지스터**
    - 호스트가 주변 장치에 입출력 명령을 내리거나, 장치의 모드를 변경하기 위해 쓰기를 수행하는 대상이다.

</br>

### 폴링

→ ***호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만, 기본적인 핸드셰이킹 개념은 간단하다.***

- 호스트는 다음과 같은 방법으로 핸드셰이킹을 통해 컨트롤러와 협력하면서, 포트를 통해 출력을 쓴다.
    1. 호스트가 반복적으로 비지 비트를 검사한다.
    2. 호스트가 명령 레지스터에 쓰기 비트를 설정하고, 출력 레지스터에 출력할 바이트를 쓴다.
    3. 호스트가 명령 준비 완료 비트를 설정한다.
    4. 컨트롤러가 명령 준비 완료 비트가 설정된 것을 알아차렸을 때, 자신의 비지 비트를 설정한다.
    5. 컨트롤러는 명령 레지스터를 읽고, 쓰기 명령임을 알게 되고, 출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어  장치로 출력한다.
    6. 컨트롤러는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거한다.

</br>

> **단계 1에서 호스트는 바쁜 대기, 즉 폴링(polling)을 하게 된다.**
> 
- 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복한다.
    - 기간이 짧다면 문제가 없지만, 기다림이 매우 길어지면 호스트는 다른 태스크로 전환하여 다른 일을 하다가 오는 것이 좋다.

</br>

> **인터럽트(interrupt)**
> 
→ ***입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법***

- **하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 그것을 통보해 주는 것이, 반복적으로 폴링을 하는 것보다 효율적이다!**

</br>

### 인터럽트

> **기본 인터럽트 기법**
> 
- CPU 하드웨어는 인터럽트 요청 라인을 하나 갖는데, CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사한다.
    - 입출력 하드웨어 컨트롤러가 이 요청 라인에 신호를 보내면 CPU가 알아차리고 각종 레지스터 값과 상태 정보를 저장한다.
    - 그 후, 메모리상의 인터럽트 핸들러 루틴으로 이동한다.

</br>

- 인터럽트 핸들러는 인터럽트의 발생 원인을 조사하고 필요한 작업을 수행 후, CPU를 인터럽트 전의 실행 상태로 되돌리기 위해 인터럽트 이전으로 복귀 명령을 실행한다.
    - 장치 컨트롤러는 인터럽트 요청 라인에 신호를 보내서 인터럽트를 야기하고, CPU는 인터럽트 상황을 알아차리고 인터럽트 핸들러를 수행한다.

<img width="473" alt="image" src="https://user-images.githubusercontent.com/106216912/224350730-d74e639f-4941-4c59-bec4-99e9bc9c5f98.png">

</br>

> **현대 운영체제에서의 세분된 인터럽트 핸들링 방법**
> 
1. 어떤 특수한 상황에서는 인터럽트 발생을 연기시키는 능력이 필요하다.
2. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 알아내는 방법이 필요하다.
3. 여러 개의 인터럽트가 병행하게 발생할 때, 운영체제는 높은 우선순위와 낮은 우선순위 인터럽트를 구별하고 긴급한 정도에 따라 먼저 응답하기 위한 다수준 인터럽트가 필요하다.
4. 페이지 폴트 및 0으로 나누기 오류와 같은 활동에 대해 운영체제의 주의를 직접 돌릴 수 있는 방법이 필요하다.

</br>

> **현대 컴퓨터는 이들 요소를 CPU와 인터럽트 컨트롤러 하드웨어에 제공하고 있다.**
> 
- 대부분의 CPU는 두 종류의 인터럽트 요청 라인을 가진다.
    - 하나는 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 **마스크 불가 인터럽트**,
    - 다른 하나는 필요하면 인터럽트 기능을 잠시 중단 시켜놓을 수 있는 **마스크 가능 인터럽트**이다.

</br>

> **인터럽트 기법은 보통 주소라고 하는 하나의 작은 정수를 받아들이는데, 이 정수는 특정 인터럽트 핸들링 루틴을 선택하기 위해 사용된다.**
> 
- 대부분의 아키텍처에서 이 주소는 인터럽트 벡터라고 불리는 테이블의 오프셋으로 사용된다.
    - 이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다.

</br>

- 벡터형 인터럽트 기법은 단일 인터럽트 핸들러가 서비스할 인터럽트를 결정하기 위해 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄인다.
    - 컴퓨터는 **인터럽트 벡터** 내에 있는 주소들보다 더 많은 수의 장치가 있다.
    - 문제를 해결하기 위해 **인터럽트 사슬화** 기술을 사용한다.

</br>

> **또한, 인터럽트 기법은 인터럽트 우선순위 수준의 구현을 가능하게 한다.**
> 
- 이러한 수준들은 CPU가 모든 낮은 우선순위 인터럽트를 일일이 마스크 오프시키기 않더라도, 자동으로 높은 우선순위 인터럽트가 낮은 우선순위 인터럽트의 실행을 선점할 수 있게 한다.

</br>

> **대부분의 경우 인터럽트 처리는 시간과 자원이 제한되어 구현하기가 복잡하다.**
> 
→ ***따라서, 시스템은 인터럽트 관리를 1차 인터럽트 처리기(FLIH)와 2차 인터럽트 처리기(SLIH)로 나눈다.***

- **FLIH** : 문맥 교환, 상태 저장 및 처리 작업을 큐에 삽입하는 작업을 수행
- **SLIH** : 요청된 작업 처리를 수행

</br>

> **운영체제는 인터럽트를 다른 용도로도 사용한다.**
> 
- ex) 가상 메모리 페이징을 위해 인터럽트 기법을 사용
- ex) 시스템 콜의 수행

</br>

→ 정리하면, **인터럽트는 모든 현대 시스템에서 비동기적으로 일어나는 이벤트를 처리하고, 커널 내의 슈퍼바이저 루틴으로 달려가기 위한 방도로 사용된다!**

- 또한, 이러한 일 중에서도 가장 급한 일부터 차례로 수행하기 위해 인터럽트 간에도 다른 우선순위를 부여한다.

</br>

### 직접 메모리 접근

→ ***디스크와 같은 많은 데이터를 입출력하는 장치를 위해 비싼 범용 프로세서가 매번 바이트 전송을 제어하게 하는 것은 낭비이다.***

- **PIO(Programmed I/O)**
    - **CPU가 상태 비트를 반복적으로 검사하면서 1바이트씩 옮기는 입출력 방식**

</br>

- 컴퓨터는 CPU의 PIO 작업 중 일부를 **DMA** 컨트롤러라고 불리는 특수 프로세서에 위임함으로써, CPU의 일을 줄여 준다.
    - 호스트는 메모리에 DMA 명령 블록을 쓰는데, 이 블록에는 전송할 데이터가 있는 곳의 포인터, 전송할 장소에 대한 포인터, 전송될 바이트 수를 기록해 놓는다.
        - **분산-수집 방법**을 사용하면 하나의 DMA 명령을 통해 여러 개의 전송을 실행할 수 있다.

</br>

> **대상 주소가 커널 주소 공간에 있는 경우가 가장 간단하다.**
> 
<img width="440" alt="image" src="https://user-images.githubusercontent.com/106216912/224351187-c5168f06-f690-4eb9-9fb1-6efaa9f812c1.png">

- DMA로 전송된 데이터를 스레드가 액세스 할 수 있게 하려면, 커널 메모리에서 사용자 메모리로 두 번째 복사 작업이 필요하다.
    - 이런 **이중 버퍼링은 비효율적**이다.
        - 따라서, 시간이 지남에 따라 운영체제는 장치와 사용자 주소 공간 간에 직접 I/O 전송을 수행하기 위해 메모리 매핑을 사용하게 되었다.

</br>

> **DMA 컨트롤러와 장치 컨틀롤러 간의 핸드셰이킹은 DMA-request와 DMA-acknowledge, 두 개의 선을 통해 수행된다.**
> 
- 장치 컨트롤러는 전송할 자료가 생기면 DMA-request 선에 신호를 보낸다.
    - 이 신호를 받으면 DMA 컨트롤러가 메모리 버스를 얻어 거기에 원하는 주소를 올려놓고, DMA-acknowledge 선에 신호를 보낸다.
    - 장치 컨트롤러가 DMA-acknowledge 신호를 받으면, 컨트롤러는 한 워드를 메모리로 전송하고 DMA-request 신호를 제거한다.

</br>

> **사이클 스틸링은 CPU의 속도를 저하하지만, 입출력 작업을 DMA로 넘기는 것은 시스템 성능을 향상한다.**
> 
- 어떠한 컴퓨터들은 DMA를 할 때 물리 주소를 사용하지만, 다른 컴퓨터들은 **직접 가상 주소 접근(DVMA)** 을 사용하기도 한다.

---

## 3. 응용 입출력 인터페이스

→ ***다른 복잡한 소프트웨어 엔지니어링 문제와 같이, 여기서도 추상화와 캡슐화, 소프트웨어 계층화를 사용한다.***

- 특히, 각 입출력 장치들의 구체적인 차이점을 추상화하여 감출 수 있다.
    - 장치 드라이버라고 부르는 커널 내의 모듈들은, 인터페이스의 표준 함수들을 내부적으로 수행한다.

<img width="484" alt="image" src="https://user-images.githubusercontent.com/106216912/224362631-87e34355-afec-4f19-9221-511537562844.png">

</br>

> **한 가지 문제는 운영체제마다 장치 드라이버 인터페이스에 대한 규격이 다르다는 것이다!**
> 
- 따라서, 새로운 장치는 여러 개의 장치 드라이버와 함께 제공되어야 한다.

</br>

<img width="486" alt="image" src="https://user-images.githubusercontent.com/106216912/224362762-d3df7019-1d20-47f2-a868-8539d397ce84.png">

- **문자 스트림과 블록** : 문자 스트림 장치는 바이트를 하나씩 전송하지만, 블록 장치는 블록 단위로 전송한다.
- **순차 접근과 임의 접근** : 순차 장치는 순차적 순서로만 자료를 전송하지만, 임의 접근 장치는 임의의 위치에 있는 자료도 입출력할 수 있다.
- **동기식과 비동기식** : 동기식 장치는 시스템의 다른 측면과 조율하여 일정한 응답시간을 보이고, 비동기식 장치는 다른 이벤트와 조율 없이 불규칙한 응답 시간을 보인다.
- **공유와 전용** : 공유 가능한 장치는 몇 개의 프로세스나 스레드에 의해 동시에 사용될 수 있으나, 전용 장치는 혼자만 사용해야 한다.
- **읽기/쓰기, 읽기 전용, 한 번만 쓰기** : 몇몇 장치들은 읽기와 쓰기를 모두 수행하지만, 어떤 것들은 하나만 지원한다.

</br>

> **응용의 접근 목적에 따라 운영체제는 장치들의 차이를 숨겨주고, 장치들을 몇 개의 범주로 분류한다.**
> 
- 장치 접근의 분류는 유용하고, 대부분의 운영체제에서 통용된다.
    - 운영체제마다 구체적인 시스템 콜인 다르지만, 장치 범주는 매우 표준적이다.

</br>

> **또한, 대부분의 운영체제는 응용 프로그램이 입출력 장치로 임의의 명령을 전달하도록 하는 `escape` 시스템 콜을 갖고 있다.**
> 
- UNIX에서는 `ioctl()` 에 해당되는데, 새로운 시스템 콜을 만들 필요 없이 응용 프로그램이 임의의 장치 드라이버가 제공하는 임의의 기능을 사용할 수 있게 한다.

</br>

### 블록 장치와 문자 장치

→ ***블록 장치 인터페이스는 디스크나 이와 유사한 블록 지향 장치를 사용하기 위해 필요한 모든 요소를 제공하고 있다.***

- 일반적으로는 읽기와 쓰기, 그리고 다음에 전송할 위치를 지정하는 탐색 명령을 제공한다.

</br>

> **한편, 운영체제나 데이터베이스는 블록 장치를 마치 선형 배열이라고 이해하고 사용하기를 원할 것이다.**
> 
- 이러한 접근 모드를 **비가공 입출력(raw I/O)** 라고 한다.
    - 만약 응용이 자체 버퍼링을 수행한다면, 파일 시스템은 불필요하고 중복된 버퍼링을 하게 된다.
    - 마찬가지로, 응용이 파일의 블록이나 일부에 대한 자체 잠금 기능을 제공한다면, 운영체제의 잠금 기능은 최소한 중복된 기능이고, 최악의 경우에는 모순이 발생한다.

</br>

→ 이러한 충돌을 피하려면, 비가공 장치의 접근은 장치의 제어권을 직접 응용에 일임하고 운영체제는 한 발 뒤로 물러나야 한다.

- 이에 대한 절충안은, 운영체제가 버퍼링과 잠금을 하지 않는 모드이다. → **직접 입출력**

</br>

> **메모리 맵드 파일 접근은 블록 장치 위의 층으로 구현할 수 있다.**
> 
- 메모리 맵드 파일 접근이랑 “메모리의 특정 번지를 읽거나 쓰는 명령”으로 파일 입출력을 대신하는 방식이다.

</br>

> **키보드는 문자 스트림 인터페이스를 통해 접근되는 장치의 예이다.**
> 
- 이러한 인터페이스의 시스템 콜은 응용 프로그램에 한 글자씩을 보내거나 받아 오는 명령을 제공한다.

</br>

### 네트워크 장치

→ ***네트워크 입출력은 디스크 입출력과는 상당히 다르기 때문에, 대부분의 운영체제는 디스크에서 사용되는 인터페이스와는 다른 인터페이스를 네트워크 입출력에 제공한다.***

- 많은 운영체제에서 사용하는 인터페이스는 **네트워크 소켓(socket) 인터페이스**이다.

</br>

> **소켓 인터페이스에서 시스템 콜**
> 
- 응용 프로그램이 소켓을 생성한다.
- 로컬 소켓을 원격지 주소와 연결한다.
- 원격지의 응용 프로그램이 소켓으로 접속을 완료하였는지 알아본다.
- 연결되었으면 패킷을 주고 받도록 해준다.
- 일련의 소켓들을 관리하는 `select()` 함수를 제공한다.

</br>

### 클록과 타이머

→ ***대부분의 컴퓨터는 하드웨어 클록과 타이머를 가지고 3가지 기본적인 기능들을 제공한다.***

- 현재 시각을 제공
- 지난 시간을 제공
- `T` 시각이 되면 `X` 오퍼레이션을 실행

</br>

> **지나간 시간을 재고 특정 오퍼레이션을 실행시키는 하드웨어를 프로그램 가능 인터벌 타이머라고 한다.**
> 
- 이것은 어느 시간만큼 지나면 인터럽트를 발생시키도록 설정할 수 있다.
    - 또한, 이 과정을 한 번 또는 주기적으로 인터럽트를 발생하도록 반복해서 하도록 설정할 수 있다.

</br>

> **컴퓨터에는 다양한 용도로 사용되는 클록 하드웨어가 있다.**
> 
- 최신 PC에는 **고성능 이벤트 타이머(HPET)** 가 포함되어 있으며, 10MHz 범위의 속도로 실행된다.

</br>

### 봉쇄형과 비봉쇄형 입출력

→ ***시스템 콜 인터페이스와 관련된 나머지 한 가지 이슈는, 봉쇄형과 비봉쇄형 방법 간의 선택 문제이다.***

- 응용 프로그램이 **봉쇄형 시스템 콜**을 하면, 호출 스레드는 봉쇄 상태로 들어가게 된다.
    - 즉, 운영체제가 이 스레드를 실행 큐로부터 대기 큐로 옮긴다.
    - 추후 입출력이 끝나면 다시 실행 큐로 되돌아오며, 실행을 재시작할 수 있다.

</br>

> **어떤 사용자 프로그램들은 비봉쇄형 입출력이 필요하다.**
> 
- ex) 스크린에 다른 자료를 표시하거나, 연산을 하는 중에 키보드와 마우스 입력을 받아들이는 경우

</br>

> **응용 프로그램 작성자는 연산과 입출력 간의 중첩을 최대한 도모하기 위해, 다중 스레드 방식으로 프로그램을 작성할 수도 있다.**
> 
- 일부의 스레드는 봉쇄되는 시스템 콜을 하여 봉쇄되고, 나머지 스레드들은 연산을 계속할 수가 있다.

</br>

> **비봉쇄형 시스템 콜의 대안으로 비동기식 시스템 콜이 있다.**
> 

<img width="484" alt="image" src="https://user-images.githubusercontent.com/106216912/224363243-b694fab0-bb62-43ef-8375-e6a540ffc4de.png">

- 비동기식 호출도 위 호출처럼 즉각 복귀한다.
    - 이 호출에서 되돌아온 스레드는 자신의 코드를 계속 수행한다.
    - 입출력이 완료되면, 그때 가서 운영체제가 입출력이 완료됐다는 사실을 스레드의 변수를 세팅해주거나, 시그널을 보내거나, 소프트웨어 인터럽트를 걸거나, 스레드와는 별도로 수행되는 콜백 루틴을 수행함으로써 알려준다.

</br>

### 벡터형 입출력

→ ***일부 운영체제는 입출력 인터페이스를 통하여 중요한 변형 입출력을 제공한다.***

- **벡터형 입출력**은 하나의 시스템 콜을 호출해서 복수의 위치에 여러 입출력 연산을 수행할 수 있게 한다.
    - 동일한 전송은 시스템 콜을 여러 번 호출해서 수행할 수 있지만, 여러 이유로 이러한 **분산-수집 방식**이 유용하다.

---

## 4. 커널 입출력 서브시스템

→ ***커널은 입출력과 관련된 많은 서비스를 제공한다.***

</br>

### I/O 스케줄링

→ ***일련의 입출력 요구를 스케줄 한다는 것은 그 요구를 실행할 순서를 결정하는 것을 의미한다.***

- 응용 프로그램이 입출력을 요청하는 순서대로 스케줄링할 경우, 최상의 성능을 내기 어렵다.
    - 스케줄링은 전반적인 시스템 성능을 향상하고, 프로세스들 사이에 공평을 기해줄 수 있다.
    - 그리고 입출력 완료까지의 평균대기 시간을 줄일 수 있다.

</br>

> **운영체제 개발자들은 각각의 장치마다 대기 큐를 유지함으로써 스케줄링을 구현하고 있다.**
> 
- 응용 프로그램이 봉쇄형 입출력 시스템 콜을 하면, 그 입출력 요청은 해당 장치의 큐에 넣어진다.
- 입출력 스케줄러는 시스템의 성능과 각 응용에 대한 평균 응답 시간을 향상하기 위해 큐 안의 순서를 재배치한다.
    - 운영체제는 통상은 공평하게 일을 처리하려고 하지만, 때에 따라서는 시간이 급한 작업은 빨리 처리해 주기도 한다.

</br>

> **커널이 비동기적 입출력을 제공한다면, 커널은 동시에 많은 입출력 요청을 추적해야 한다.**
> 
<img width="480" alt="image" src="https://user-images.githubusercontent.com/106216912/224376556-45fd8bd2-a569-400c-8bd4-e5f3561fdcbc.png">

- 이를 위해 운영체제는 각 **장치 상태 테이블**에 대기 큐를 연동한다.
    - 이 테이블에는 각 입출력 장치에 대한 정보가 있다.
    - 각 테이블 항목은 장치의 종류, 주소, 상태 등을 가리킨다.

</br>

→ **입출력 작업 스케줄링은 입출력 서브시스템이 컴퓨터의 효율성을 향상하는 방법 중 하나이다.**

</br>

### 버퍼링

→ ***버퍼는 두 장치 사이 또는 장치와 응용 프로그램 사이에 데이터가 전송되는 동안 전송 데이터를 임시로 저장하는 메모리 영역을 말한다.***

<img width="450" alt="image" src="https://user-images.githubusercontent.com/106216912/224376682-c904cb89-b883-4bf0-80cf-908fee03bfce.png">

- 버퍼링은 다음 세 가지 이유 때문에 필요하다.
    - 데이터의 생산자와 소비자 사이에 속도가 다른 것에 대처하기 위해
    - 데이터 전송 크기가 다른 장치들 사이의 완충을 제공할 때
    - 응용 프로그램의 **입출력 복제 시맨틱**을 지원하기 위해

</br>

### 캐싱

→ ***캐시는 자주 사용될 자료의 복사본을 저장하는 빠른 메모리 영역이다.***

- 캐시된 복사본을 사용하면 원래 자료를 사용하는 것보다 더 효율적이다.

</br>

> **캐시와 버퍼링은 서로 다른 기능이지만, 때로는 메모리 영역을 두 가지 용도로 모두 사용할 수 있다.**
> 
- ex) 복사 시맨틱을 유지하고 디스크 I/O의 효율적인 스케줄링을 가능하게 하려고 운영체제는 메인 메모리의 버퍼를 사용하여 디스크 데이터를 유지한다.
    - 이 버퍼는 캐시로도 사용되어 응용 프로그램들이 공유하거나 기록된 후 곧바로 다시 읽히는 파일의 I/O 효율을 향상한다.

</br>

### 스풀링 및 장치 예약

→ ***스풀은 인터리브하게 동작할 수 없는 프린터 같은 장치를 위해 출력 데이터를 보관하는 버퍼이다.***

- 즉, 프린터는 한 번에는 하나의 작업만을 그것이 다 끝나기까지 처리하여야 하고, 여러 응용 프로그램의 출력을 섞어 번갈아 가며 출력시킬 수는 없다.

</br>

→ **운영체제는 응용 프로그램으로부터 프린터로 가는 모든 출력을 가로챔으로써, 이 문제를 해결한다!**

- 각 응용 프로그램의 출력은 각각 대응되는 보조저장장치 파일에 저장된다.
    - 응용 프로그램이 출력 데이터 만들어내기를 끝내게 되면, 스풀링 시스템은 그 때까지 모아놓은 출력 데이터를 프린터 출력용 대기 열에 삽입한다.
    - 스풀링 시스템은 큐에서 대기 중인 스풀 파일을 한 번에 하나씩 프린터에 내보낸다.

</br>

### 오류 처리

→ ***보호되는 메모리를 사용하는 운영체제는 많은 종류의 하드웨어 및 응용 프로그램 오류에 대처할 수 있으며, 그러한 오류가 일어나도 시스템 전체의 마비로까지 확대되지는 않는다.***

- 입출력 장치나 네트워크 전송은 일시적인 원인 때문에, 또는 영구적인 원인 때문에 실패할 수 있다.
    - 운영체제는 일시적인 고장으로부터 효과적으로 극복할 수 있다.

</br>

> **일반적으로, 입출력 시스템 콜은 성공/실패를 나타내는 한 비트 정보를 반환한다.**
> 
- ex) UNIX는 반환 값 외에도 `errno` 라고 부르는 변수를 사용한다.
    - 이 변수는 100가지 종류의 오류를 구분하여 준다.

</br>

### 입출력 보호

→ ***오류는 보호와 밀접한 관계가 있다.***

- 사용자 프로세스는 고의적이든 아니든 불법적인 입출력 명령을 시도함으로써 정상적인 동작을 방해할 수 있다.
    - 그러한 문제가 발생하지 않도록 다양한 기법을 사용할 수 있다.

</br>

> **사용자가 불법적인 입출력을 못 하게 하기 위해, 모든 입출력 명령은 특권 명령으로 정의한다.**
> 
<img width="378" alt="image" src="https://user-images.githubusercontent.com/106216912/224376959-f300b1c2-9bb0-407a-9014-52d63590b60d.png">

- 따라서, 사용자는 입출력 명령을 직접 수행할 수 없다.
    - 대신에 운영체제가 입출력을 대신 수행하도록 시스템 콜을 수행한다.
    - 모니터 모드에서 수행 중인 운영체제는 그 요청이 유효한지를 검사하고, 요청이 유효하면 요청을 수행한다.
    - 그리고 운영체제는 사용자에게 복귀한다.

</br>

### 커널 자료구조

→ ***커널은 입출력 구성 요소에 대한 상태 정보를 유지해야 한다.***

- 커널은 다양한 자료구조를 유지한다.
    - 커널은 네트워크 연결, 문자 장치 통신, 그리고 다른 입출력 활동을 관리하기 위해 여러 비슷한 구조를 사용한다.

</br>

> **UNIX는 파일 시스템 인터페이스를 사용하여 다양한 것에 `access` 를 할 수 있게 해 준다.**
> 
<img width="485" alt="image" src="https://user-images.githubusercontent.com/106216912/224377124-a91eb331-ac4a-4fee-b530-bd555f96c26b.png">

- ex) 사용자 파일, raw 장치, 프로세스의 주소 공간과 같은 다양한 개체들을 파일 시스템처럼 액세스할 수 있게 해준다.
    - 이 모든 객체가 `read()` 를 지원할지라도, 그 객체마다 행해지는 `read()` 의 의미는 다르다.

</br>

### 전원 관리

→ ***운영체제는 전력 사용에서 중요한 역할을 한다.***

- 클라우드 컴퓨팅 환경에서 모니터링과 시스템에서 모든 사용자 프로세스를 대피하고, 해당 시스템을 유휴 상태로 만들고, 부하가 필요할 때까지 전원을 끌 수 있는 관리 도구를 사용하면 처리 부하를 조정할 수 있다.
    - 시스템 부하가 필요로 하지 않는 경우, CPU 코어는 일시 중단될 수 있으며, 부하가 증가하고 스레드 큐를 실행하기 위해 더 많은 코어가 필요할 때 재개될 수 있다.

</br>

> **모바일 컴퓨팅에서 전력 관리는 운영체제의 우선순위가 높은 측면이다.**
> 
- 전력 사용을 최소화하고 배터리 수명을 최대화하면 장치의 사용성이 향상되고 다른 장치와 경쟁할 수 있다.

---