## 1. 개관

→ ***컴퓨터에 연결된 장치들을 제어하는 일은 운영체제의 주요 관심사이다.***

- 입출력 장치들은 기능이나 속도 면에서 매우 다양한 특성을 보이기 때문에, 각각의 특성에 맞는 제어가 필요하다.
    - 다양한 제어 방법들이 커널의 **입출력 서브시스템**을 형성한다.

</br>

> **입출력 장치 관련 기술들은 두 가지의 상충하는 궤도를 따라간다.**
> 
- 한편으로는 관련 인터페이스의 표준화가 늘어나고 있다는 것이다.
    - 이런 경향은, 새로 나오는 장치들이 기존 시스템에 쉽게 결합할 수 있도록 하기 위함이다.
- 다른 한 경향으로는, 입출력 장치가 갈수록 다양해진다.
    - 몇몇 장치들을 컴퓨터나 운영체제에 결합하는 것은, 하드웨어와 소프트웨어 기술의 조합에 의해 해결될 수 있다.

</br>

> **장치 드라이버**
> 
- 모든 하드웨어를 일관된 인터페이스로 표현해 주며, 이러한 인터페이스를 그보다 상위층인 커널의 입출력 서브시스템에 제공해 준다.

---

## 2. 입출력 하드웨어

> **하드웨어 장치는 케이블을 통하거나 무선으로 신호를 보냄으로써 컴퓨터 시스템과 통신한다.**
> 
- 이들 장치는 **포트(port)** 라고 불리는 연결점을 통해 컴퓨터와 접속된다.
    - 만약 하나 이상의 장치들이 공동으로 여러 선을 사용한다면, 이러한 선을 **버스(bus)** 라고 부른다.
    - 버스의 정의는, 회선의 집합으로써 이를 통해 어떻게 해야 메시지를 주고받을 수 있는지를 정한 프로토콜까지를 포함한다.

</br>

> **데이지 체인(daisy chain)**

→ ***장치 A가 B에 연결되고, B가 C, 이어 C가 컴퓨터의 포트에까지 연결되어 있는 것***

- 통상 하나의 버스처럼 동작한다.

</br>

> **버스는 컴퓨터 구조에서 널리 사용되고 신호 방식, 속도, 처리량 및 연결 방식에 따라 다양한 종류가 있다.**
> 
<img width="471" alt="image" src="https://user-images.githubusercontent.com/106216912/224350132-942cc145-6986-483c-820e-bbb767312ceb.png">

- **PCI 버스**가 프로세서-메모리 서브시스템을 고속 장치와 키보드와 직렬, USB 포트처럼 상대적으로 느린 장치들을 연결하는 **확장 버스**에 연결하는 모습이다.
    - 왼쪽 하단은 네 개의 디스크가 SAS 컨트롤러에 접속된 **직렬 연결 SCSI 버스**에 연결되어 있는 것을 볼 수 있다.

</br>

> **컨트롤러는 포트, 버스 또는 장치를 작동할 수 있는 전자장치 집합체이다.**
> 
- 직렬 포트 컨트롤러는 간단한 장치 컨트롤러이다.
    - 직렬 포트의 전선에 나타나는 전기신호를 제어하는 데 쓰이고, 하나의 칩으로 나온다.
    - 반대로 **광섬유 채널(FC)** 버스 컨트롤러는 간단하지 않다.
        - 복잡하고, PC가 아닌 데이터 센터에서 사용되기 때문에 종종 컴퓨터의 버스에 연결되는 별도의 회로 보드 또는 **호스트 버스 어댑터(HBA)** 로 구현된다.

</br>

### 메모리 맵드 입출력

→ ***입출력 전송을 하기 위해 처리기는 어떻게 명령어와 데이터를 컨트롤러에 전달할까?***

- 모든 컨트롤러는 레지스터를 가지고 있다.
    - 본체의 프로세서는 이들 컨트롤러의 레지스터에 비트 패턴을 쓰거나 읽음으로써 입출력을 수행한다.
    - 이러한 통신을 수행하는 한 방법은 “특별한 입출력 명령어”를 사용하는 것이다.

</br>

> **메모리 맵드 입출력(memory-mapped I/O) 방식**
>
→ ***특수 입출력 명령어를 가지는 대신, 장치 제어 레지스터를 프로세스의 주소 공간으로 사상한다.***

- 이 경우, 각 주변 장치 레지스터들은 메모리 주소와 일대일 대응된다.
    - CPU는 물리 메모리에 사상된 장치-제어 레지스터를 읽고 쓸 때 표준 데이터 전송 명령을 사용함으로써 입출력 요청을 수행하게 된다.

</br>

> **입출력 장치 컨트롤러는 네 개의 레지스터로 구성되어 있다.**
> 
- **입력 레지스터**
    - 호스트가 입력을 얻기 위해 읽기를 수행한다.

</br>

- **출력 레지스터**
    - 호스트가 데이터를 출력하기 위해 쓰기를 수행한다.

</br>

- **상태 레지스터**
    - 호스트가 읽는 용도이며, 현재의 명령이 완료되었는지, 입력 레지스터로부터 한 바이트를 읽어도 되는지, 오류가 있었는가와 같은 상태들을 보고한다.

</br>

- **제어 레지스터**
    - 호스트가 주변 장치에 입출력 명령을 내리거나, 장치의 모드를 변경하기 위해 쓰기를 수행하는 대상이다.

</br>

### 폴링

→ ***호스트와 입출력 하드웨어 사이의 프로토콜은 복잡하지만, 기본적인 핸드셰이킹 개념은 간단하다.***

- 호스트는 다음과 같은 방법으로 핸드셰이킹을 통해 컨트롤러와 협력하면서, 포트를 통해 출력을 쓴다.
    1. 호스트가 반복적으로 비지 비트를 검사한다.
    2. 호스트가 명령 레지스터에 쓰기 비트를 설정하고, 출력 레지스터에 출력할 바이트를 쓴다.
    3. 호스트가 명령 준비 완료 비트를 설정한다.
    4. 컨트롤러가 명령 준비 완료 비트가 설정된 것을 알아차렸을 때, 자신의 비지 비트를 설정한다.
    5. 컨트롤러는 명령 레지스터를 읽고, 쓰기 명령임을 알게 되고, 출력 레지스터를 읽어 해당 바이트를 가져와 해당 하드웨어  장치로 출력한다.
    6. 컨트롤러는 명령 준비 비트를 소거하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 소거한다.

</br>

> **단계 1에서 호스트는 바쁜 대기, 즉 폴링(polling)을 하게 된다.**
> 
- 호스트는 이 루프를 계속 돌면서 비지 비트가 소거될 때까지 검사를 반복한다.
    - 기간이 짧다면 문제가 없지만, 기다림이 매우 길어지면 호스트는 다른 태스크로 전환하여 다른 일을 하다가 오는 것이 좋다.

</br>

> **인터럽트(interrupt)**
> 
→ ***입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법***

- **하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 그것을 통보해 주는 것이, 반복적으로 폴링을 하는 것보다 효율적이다!**

</br>

### 인터럽트

> **기본 인터럽트 기법**
> 
- CPU 하드웨어는 인터럽트 요청 라인을 하나 갖는데, CPU는 매 명령어를 끝내고 다음 명령어를 수행하기 전에 늘 이 선을 검사한다.
    - 입출력 하드웨어 컨트롤러가 이 요청 라인에 신호를 보내면 CPU가 알아차리고 각종 레지스터 값과 상태 정보를 저장한다.
    - 그 후, 메모리상의 인터럽트 핸들러 루틴으로 이동한다.

</br>

- 인터럽트 핸들러는 인터럽트의 발생 원인을 조사하고 필요한 작업을 수행 후, CPU를 인터럽트 전의 실행 상태로 되돌리기 위해 인터럽트 이전으로 복귀 명령을 실행한다.
    - 장치 컨트롤러는 인터럽트 요청 라인에 신호를 보내서 인터럽트를 야기하고, CPU는 인터럽트 상황을 알아차리고 인터럽트 핸들러를 수행한다.

<img width="473" alt="image" src="https://user-images.githubusercontent.com/106216912/224350730-d74e639f-4941-4c59-bec4-99e9bc9c5f98.png">

</br>

> **현대 운영체제에서의 세분된 인터럽트 핸들링 방법**
> 
1. 어떤 특수한 상황에서는 인터럽트 발생을 연기시키는 능력이 필요하다.
2. 어떤 장치가 인터럽트를 일으켰는지 조사하기 위해 모든 장치를 폴링하지 않고 알아내는 방법이 필요하다.
3. 여러 개의 인터럽트가 병행하게 발생할 때, 운영체제는 높은 우선순위와 낮은 우선순위 인터럽트를 구별하고 긴급한 정도에 따라 먼저 응답하기 위한 다수준 인터럽트가 필요하다.
4. 페이지 폴트 및 0으로 나누기 오류와 같은 활동에 대해 운영체제의 주의를 직접 돌릴 수 있는 방법이 필요하다.

</br>

> **현대 컴퓨터는 이들 요소를 CPU와 인터럽트 컨트롤러 하드웨어에 제공하고 있다.**
> 
- 대부분의 CPU는 두 종류의 인터럽트 요청 라인을 가진다.
    - 하나는 회복 불가능한 메모리 오류와 같은 이벤트를 위해 사용되는 **마스크 불가 인터럽트**,
    - 다른 하나는 필요하면 인터럽트 기능을 잠시 중단 시켜놓을 수 있는 **마스크 가능 인터럽트**이다.

</br>

> **인터럽트 기법은 보통 주소라고 하는 하나의 작은 정수를 받아들이는데, 이 정수는 특정 인터럽트 핸들링 루틴을 선택하기 위해 사용된다.**
> 
- 대부분의 아키텍처에서 이 주소는 인터럽트 벡터라고 불리는 테이블의 오프셋으로 사용된다.
    - 이 벡터는 인터럽트 핸들러들의 메모리 주소들을 가지고 있다.

</br>

- 벡터형 인터럽트 기법은 단일 인터럽트 핸들러가 서비스할 인터럽트를 결정하기 위해 모든 가능한 인터럽트의 진원지를 찾아야 할 필요를 줄인다.
    - 컴퓨터는 **인터럽트 벡터** 내에 있는 주소들보다 더 많은 수의 장치가 있다.
    - 문제를 해결하기 위해 **인터럽트 사슬화** 기술을 사용한다.

</br>

> **또한, 인터럽트 기법은 인터럽트 우선순위 수준의 구현을 가능하게 한다.**
> 
- 이러한 수준들은 CPU가 모든 낮은 우선순위 인터럽트를 일일이 마스크 오프시키기 않더라도, 자동으로 높은 우선순위 인터럽트가 낮은 우선순위 인터럽트의 실행을 선점할 수 있게 한다.

</br>

> **대부분의 경우 인터럽트 처리는 시간과 자원이 제한되어 구현하기가 복잡하다.**
> 
→ ***따라서, 시스템은 인터럽트 관리를 1차 인터럽트 처리기(FLIH)와 2차 인터럽트 처리기(SLIH)로 나눈다.***

- **FLIH** : 문맥 교환, 상태 저장 및 처리 작업을 큐에 삽입하는 작업을 수행
- **SLIH** : 요청된 작업 처리를 수행

</br>

> **운영체제는 인터럽트를 다른 용도로도 사용한다.**
> 
- ex) 가상 메모리 페이징을 위해 인터럽트 기법을 사용
- ex) 시스템 콜의 수행

</br>

→ 정리하면, **인터럽트는 모든 현대 시스템에서 비동기적으로 일어나는 이벤트를 처리하고, 커널 내의 슈퍼바이저 루틴으로 달려가기 위한 방도로 사용된다!**

- 또한, 이러한 일 중에서도 가장 급한 일부터 차례로 수행하기 위해 인터럽트 간에도 다른 우선순위를 부여한다.

</br>

### 직접 메모리 접근

→ ***디스크와 같은 많은 데이터를 입출력하는 장치를 위해 비싼 범용 프로세서가 매번 바이트 전송을 제어하게 하는 것은 낭비이다.***

- **PIO(Programmed I/O)**
    - **CPU가 상태 비트를 반복적으로 검사하면서 1바이트씩 옮기는 입출력 방식**

</br>

- 컴퓨터는 CPU의 PIO 작업 중 일부를 **DMA** 컨트롤러라고 불리는 특수 프로세서에 위임함으로써, CPU의 일을 줄여 준다.
    - 호스트는 메모리에 DMA 명령 블록을 쓰는데, 이 블록에는 전송할 데이터가 있는 곳의 포인터, 전송할 장소에 대한 포인터, 전송될 바이트 수를 기록해 놓는다.
        - **분산-수집 방법**을 사용하면 하나의 DMA 명령을 통해 여러 개의 전송을 실행할 수 있다.

</br>

> **대상 주소가 커널 주소 공간에 있는 경우가 가장 간단하다.**
> 
<img width="440" alt="image" src="https://user-images.githubusercontent.com/106216912/224351187-c5168f06-f690-4eb9-9fb1-6efaa9f812c1.png">

- DMA로 전송된 데이터를 스레드가 액세스 할 수 있게 하려면, 커널 메모리에서 사용자 메모리로 두 번째 복사 작업이 필요하다.
    - 이런 **이중 버퍼링은 비효율적**이다.
        - 따라서, 시간이 지남에 따라 운영체제는 장치와 사용자 주소 공간 간에 직접 I/O 전송을 수행하기 위해 메모리 매핑을 사용하게 되었다.

</br>

> **DMA 컨트롤러와 장치 컨틀롤러 간의 핸드셰이킹은 DMA-request와 DMA-acknowledge, 두 개의 선을 통해 수행된다.**
> 
- 장치 컨트롤러는 전송할 자료가 생기면 DMA-request 선에 신호를 보낸다.
    - 이 신호를 받으면 DMA 컨트롤러가 메모리 버스를 얻어 거기에 원하는 주소를 올려놓고, DMA-acknowledge 선에 신호를 보낸다.
    - 장치 컨트롤러가 DMA-acknowledge 신호를 받으면, 컨트롤러는 한 워드를 메모리로 전송하고 DMA-request 신호를 제거한다.

</br>

> **사이클 스틸링은 CPU의 속도를 저하하지만, 입출력 작업을 DMA로 넘기는 것은 시스템 성능을 향상한다.**
> 
- 어떠한 컴퓨터들은 DMA를 할 때 물리 주소를 사용하지만, 다른 컴퓨터들은 **직접 가상 주소 접근(DVMA)** 을 사용하기도 한다.

---