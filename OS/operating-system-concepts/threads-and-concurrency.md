> **현대 운영체제는 한 프로세스가 다중 스레드를 포함하는 특성을 제공한다.**

→ 다중 CPU를 제공하는 최신 다중 코어 시스템에서, **스레드 사용을 통한 병렬 처리의 기회를 식별하는 것**이 중요하다.

---

## 1. 개요

→ ***스레드는 CPU 이용의 기본 단위이다.***

- 스레드 ID, 프로그램 카운터, 레지스터 집합, 스택으로 구성된다.
    - 스레드는 **같은 프로세스에 속한 다른 스레드와 운영체제 자원들을 공유**한다.

</br>

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/210487126-fba2b150-aafc-41ff-bb87-a7c403c2f905.png">

- 프로세스가 다수의 제어 스레드를 갖는다면, **프로세스는 동시에 하나 이상의 작업을 수행**할 수 있다.
    - **단일 스레드 프로세스**
    - **다중 스레드 프로세스**

</br>

### 동기

→ ***현대의 컴퓨터와 모바일 기기에서 작동하는 소프트웨어 응용들은 다중 스레드를 이용한다.***

- 하나의 응용은 몇 개의 실행 흐름을 가진 독립적인 프로세스로 구현된다.
    - ex) 웹 브라우저는 하나의 스레드가 이미지를 표시하고, 다른 스레드는 데이터 검색을 할 수 있다.

</br>

> **응용은 다중 코어 시스템에서 처리 능력을 향상시키도록 설계될 수 있다.**

→ **다중 계산 코어를 사용해서 다수의 CPU-집중 작업을 병렬로 처리**할 수 있다.

</br>

- **하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황**이 있다.
    - ex) 웹 서버는 수천 개의 클라이언트들이 병행하게 접근한다.
        - 이 때, **웹 서버가 단일 스레드 프로세스로 작동한다면, 클라이언트들은 매우 긴 시간을 기다려야 한다.**

</br>

- **해결책** : 서버가 요청을 받아들이는 하나의 프로세스로 동작하게 하는 것이다.
    - 즉, 서비스 요청이 들어오면, 프로세스는 그 요청을 수행할 별도의 프로세스를 생성하는 것이다.

</br>

> **하지만 새 프로세스가 해야 할 일이 기존 프로세스와 동일하다면 왜 이런 오버헤드를 감수해야 할까?**

→ **그럴 바엔, 프로세스 안에 여러 스레드를 만들어 나가는 것이 효율적이다!**

<img width="486" alt="image" src="https://user-images.githubusercontent.com/106216912/210487279-52bf1eb1-c1cc-49f7-ba7b-eab0fc0eca2c.png">

</br>

- 대부분의 운영체제 커널도 일반적으로 다중 스레드이다.
    - 많은 응용 프로그램 또한, 기본 정렬, 트리 및 그래프 알고리즘을 포함하여 다중 스레드를 활용할 수 있다.

</br>

### 장점

→ ***다중 스레드 프로그래밍의 이점은 4가지 큰 부류로 나눌 수 있다.***

1. **응답성(responsiveness)**
    - 응용 프로그램의 일부분이 봉쇄되거나 긴 작업을 수행하더라도 프로그램이 계속되는 것을 허용한다.
        - **사용자에 대한 응답성을 증가**시킨다.
        - 사용자 인터페이스를 설계하는 데 있어 특히 유용하다.

</br>

2. **자원 공유(resouce sharing)**
    - 프로세스는 공유 메모리와 메시지 전달 기법을 통해야만 자원을 공유할 수 있다.
    - 하지만, **스레드는 자동으로 그들이 속한 프로세스의 자원들과 메모리를 공유**한다.

</br>

3. **경제성(economy)**
    - 프로세스 생성을 위해 메모리와 자원을 할당하는 것은 비용이 많이 든다.
    - 하지만, 스레드는 자신이 속한 프로세스의 자원들을 공유한다.
        - **스레드를 생성하고, 문맥 교환하는 것이 경제적**이다.

</br>

4. **규모 적응성(scalability)**
    - 다중 처리기 구조에서는 **각각의 스레드가 다른 처리기에서 병렬로 수행**될 수 있다.

---

## 2. 다중 코어 프로그래밍

→ ***컴퓨터 설계에서 단일 CPU 시스템은 다중 CPU 시스템으로 발전하였다.***

<img width="514" alt="image" src="https://user-images.githubusercontent.com/106216912/210490562-d9d4c94f-3b27-499e-90d4-b668132d8290.png">

- 현재의 추세는 단일 컴퓨팅 칩에 여러 컴퓨팅 코어를 배치하는 것이다.
    - **다중 코어 시스템** : 각 코어가 운영체제에 별도로 존재하는 시스템
    - 다중 스레드 프로그래밍은 **여러 컴퓨팅 코어를 효율적으로 사용하고 병행성을 향상시키는 기법을 제공**한다.

</br>

> **병행성과 병렬성의 차이점은?**

- **병행** : 모든 작업이 진행되게 하여 둘 이상의 작업을 지원한다.
- **병렬** : 둘 이상의 작업을 동시에 수행할 수 있다.

</br>

### 프로그래밍 도전과제

→ ***다중 코어가 발전함에 따라, 시스템 설계자뿐 아니라 응용 프로그래머도 다중 코어의 활용도를 높여야 한다.***

<img width="323" alt="image" src="https://user-images.githubusercontent.com/106216912/210490673-325a784e-c853-419b-a0cb-1ae3924e060b.png">

- **운영체제 설계자** : 병렬 수행이 될 수 있도록 여러 코어를 활용하는 스케줄링 알고리즘을 개발해야 한다.
- **응용 프로그래머** : 기존 프로그램을 다중 스레드를 사용하도록 수정하고, 새로운 다중 스레드 프로그램을 설계해야 한다.

</br>

> **다중 코어 시스템을 위해 프로그래밍하기 위한 5가지 극복해야 할 도전 과제**
> 
1. **태스크 인식(identifying tasks)**
    - 응용을 분석하여 독립된 병행 가능 태스크로 나눌 수 있는 영역을 찾는 작업이 필요하다.
        - 태스크는 서로 독립적이고, 개별 코어에서 병렬 실행될 수 있어야 한다.

</br>

2. **균형(balance)**
    - 병렬로 실행될 수 있는 태스크를 찾는 것도 중요하지만, 찾아진 부분들이 전체 작업에 균등한 기여도를 가지도록 태스크로 나누는 것도 중요하다.

</br>

3. **데이터 분리(data spliting)**
    - 응용이 독립된 태스크로 나누어지는 것처럼, 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 나누어져야 한다.

</br>

4. **데이터 종속성(data dependency)**
    - 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 한다.

</br>

5. **시험 및 디버깅(testing and debugging)**
    - 프로그램이 다중 코어에서 병렬로 실행될 때, 다양한 실행 경로가 존재할 수 있다.
        - 병행 프로그램을 시험 및 디버깅 하는 것은, 단일 스레드 응용을 시험 및 디버깅하는 것보다 어렵다.

</br>

### 병렬 실행의 유형

→ ***일반적으로 데이터 병렬 실행, 태스크 병렬 실행의 두 가지 유형이 존재한다.***

<img width="389" alt="image" src="https://user-images.githubusercontent.com/106216912/210490831-a75615ca-b947-42c3-8a30-27df62b1aad3.png">

- **데이터 병렬 실행**
    - 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤, 각 코어에서 동일한 연산을 실행한다.

</br>

- **태스크 병렬 실행**
    - 데이터가 아닌, 태스크(스레드)를 다수의 코어에 분배한다.
    - 각 스레드는 고유의 연산을 실행한다.
    - 스레드들은 동일한 데이터에 의해 연산을 할 수도 있고, 서로 다른 데이터에 의해 연산을 실행할 수도 있다.

→ **데이터와 태스크 병럴 처리는 상호 배타적이지 않으며, 두 가지 전략을 혼합하여 사용할 수 있다!**

---

## 3. 다중 스레드 모델

→ ***스레드를 위한 지원은 사용자 스레드(user threads)를 위해서는 사용자 수준에서, 또는 커널 스레드(kernel threads)를 위해서는 커널 수준에서 제공된다.***

- **사용자 스레드** : 커널 위에서 지원되며, 커널의 지원 없이 관리된다.
- **커널 스레드** : 운영체제에 의해 직접 지원되고 관리된다.

</br>

> **사용자 스레드와 커널 스레드는 어떤 연관 관계가 존재해야 한다.**

<img width="341" alt="image" src="https://user-images.githubusercontent.com/106216912/210952724-02fbeef5-eb76-486b-b327-9b15e6555135.png">


→ 연관 관계를 확립하는 **다대일, 일대일, 다대다 모델**을 알아보자!

</br>

### 다대일 모델(Many-to-One Model)

→ ***다대일 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 사상한다.***

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/210952880-13ec3e98-92ae-44a9-8b34-da948658b051.png">

- **스레드 관리가 사용자 공간의 스레드 라이브러리에 의해 행해지므로, 효율적이다!**
    - 하지만, **한 스레드가 봉쇄형 시스템 콜을 할 경우, 전체 프로세스가 봉쇄**된다.

</br>

- 또한, **한 번에 하나의 스레드만이 커널에 접근할 수 있다.**
    - 따라서, **다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없다.**

</br>

- 그린 스레드(green thread)가 다대일 모델을 사용하였다.
    - 그린 스레드 : Solaris 시스템을 위한 스레드 라이브러리

</br>

→ **최근에는 다중 처리 코어를 대부분 사용하며, 이 모델을 사용 중인 시스템은 거의 존재하지 않는다.**

</br>

### 일대일 모델(One-to-One Model)

→ ***일대일 모델은 각 사용자 스레드를 각각 하나의 커널 스레드로 사상한다.***

<img width="389" alt="image" src="https://user-images.githubusercontent.com/106216912/210953043-35ea709c-0327-4e06-9ea7-a75f461b55f5.png">

- **하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도, 다른 스레드가 실행될 수 있다.**
    - 다대일 모델보다 **더 많은 병렬성을 제공**한다.
    - 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용한다.

</br>

- **일대일 모델의 단점**
    - 사용자 스레드를 만들려면 해당 커널 스레드를 만들어야 한다.
    - **많은 수의 커널 스레드가 시스템 성능에 부담**을 줄 수 있다.

</br>

→ **Linux는 Windows 운영체제 제품군과 함께 일대일 모델을 구현한다.**

</br>

### 다대다 모델(Many-to-Many Model)

→ ***다대다 모델은 여러 개의 사용자 수준 스레드를 그보다 작은 수, 혹은 같은 수의 커널 스레드로 멀티플렉스 한다.***

<img width="386" alt="image" src="https://user-images.githubusercontent.com/106216912/210953224-6a107546-8202-4bdd-9556-bd8e882079b3.png">

- 커널 스레드의 수는 응용 프로그램이나 특정 기계에 따라 결정된다.

</br>

> **이러한 설계가 병행 실행에 미치는 영향은?**

- 다대일 모델은 사용자 수준 스레드는 많이 생성할 수 있지만, **커널은 한 번에 하나의 커널 스레드만 스케줄 할 수 있다.**
- 일대일 모델은 더 많은 병행 실행이 가능하지만, **너무 많은 스레드를 생성하지 않도록 주의해야 한다.**
    
    → **다대다 모델은 이런 단점들을 어느 정도 해결했다!**

</br>

- 다대다 모델에서 개발자는 **필요한 만큼 사용자 수준 스레드를 생성**할 수 있다.
    - 또한, **상응하는 커널 스레드가 다중 처리기에서 병렬로 수행**될 수 있다.
    - 스레드가 봉쇄형 시스템 콜을 했을 때, 커널이 다른 스레드의 수행을 스케줄 할 수 있다.

</br>

> **두 수준 모델(two-level model)**

→ ***다대다 모델의 변형은 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것도 허용한다.***

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/210953371-d73133e4-df26-445e-854e-f1e77908b56f.png">

- 현재 논의된 모델 중 **가장 좋아보이지만, 구현하기 어렵다.**
    - 대부분의 운영체제는 일대일 모델을 사용한다.
    - 현대 병행 라이브러리는 개발자가 태스크를 식별하면, 다대다 모델을 사용하여 스레드에 매핑될 수 있게 한다.

---