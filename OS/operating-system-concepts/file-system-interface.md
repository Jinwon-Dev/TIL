## 1. 파일 개념

→ ***컴퓨터는 정보를 NVM 장치, HDD, 자기 디스크, 자기 테이프, 광디스크 같은 각기 다른 저장 매체에 저장할 수 있다.***

- **파일** : **저장된 정보에 대해 일관된 논리적 관점을 제공하고, 저장장치의 물리적 특성을 추상화한 논리적 저장 단위**
    - 파일은 운영체제에 의해서 물리 장치들로 사상되며, 일반적으로 비휘발성이기 때문에 시스템이 재부팅되어도 저장된 내용은 영구히 존속된다.

</br>

> **파일은 보조저장장치에 기록된 관련 정보의 집합으로 정의할 수 있다.**
> 
- 사용자의 관점에서 볼 때, 파일은 논리적 보조저장장치의 가장 작은 할당 요소이다.
    - 즉, 자료가 파일 안에 존재해야만 보조저장장치에 기록될 수 있다.
    - 일반적으로 파일은 **프로그램과 자료**를 나타낸다.

</br>

> **파일은 사용자와 응용 프로그램이 데이터를 저장하고 검색하는 데 사용하는 방법이고, 일반적인 용도로 사용 된다.**
> 
- 따라서, 원래 사용 범위를 넘어서 다른 용도로 사용되었다.
    - ex) UNIX, Linux 및 기타 운영체제는 시스템 정보에 대한 액세스를 제공하기 위해서 파일 시스템 인터페이스를 사용하는 `proc` 파일 시스템을 제공한다.

</br>

> **파일 내의 정보는 작성자에 의해 정의된다.**
> 
- **텍스트 파일** : 행들로 구성되는 연속된 문자들
- **소스 파일** : 함수들의 연속
- **실행 파일** : 로더가 메모리로 가져와 실행시킬 수 있는 연속된 코드 부분들

</br>

### 파일 속성

→ ***사용자의 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다.***

- 파일 이름은 하나의 문자열로 나타낸다.
    - 일부 시스템들은 대문자와 소문자를 서로 다른 문자로 구별해서 파일의 이름을 만든다.
    - 또 다른 시스템들은 이들 문자를 동일 취급한다.

</br>

> **파일은 운영체제마다 다른 속성을 갖지만, 전형적으로 다음과 같은 속성을 가진다.**
> 
- **이름** : 기호형 파일의 이름은 사람이 읽을 수 있는 형태로 유지된 유일한 정보이다.
- **식별자** : 이 고유의 꼬리표는 통상 하나의 숫자로 파일 시스템 내에서 파일을 확인한다.
- **유형** : 이 정보는 여러 유형을 제공하는 시스템을 위해 필요하다.
- **위치** : 이 정보는 파일이 존재하는 장치와 그 장치 내의 위치에 대한 포인터이다.
- **크기** : 파일의 현재 크기와, 최대 허용 가능한 크기가 이 속성에 포함된다.
- **보호** : 접근 제어 정보는 누가 읽기, 쓰기, 실행 등을 할 수 있는가를 제어한다.
- **타임스탬프와 사용자 식별** : 이 정보는 생성, 최근 변경, 최근 사용 등을 유지하고, 보호, 보안 및 사용자 감시를 위해 사용된다.

</br>

> **몇몇 새로운 파일 시스템은 확장된 파일 속성도 지원한다.**
> 
- ex) macOS의 파일 정보 창

<img width="292" alt="image" src="https://user-images.githubusercontent.com/106216912/225938574-9d57fffa-91cb-42f7-90a3-ceac7aebfc22.png">

</br>

### 파일 연산

→ ***파일이란 추상적인 데이터 유형이다.***

</br>

> **운영체제는 파일 생성, 쓰기, 읽기, 위치 재설정, 삭제 및 절단 등을 하기 위한 시스템 콜을 제공한다.**
> 
- **파일 생성**
    - 파일을 생성하기 위해서는 2단계가 필요하다.
        - 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾아야 한다.
        - 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야 한다.

</br>

- **파일 열기**
    - 모든 파일 연산에서 파일 이름을 지정하게 하면, 운영체제가 이름을 검사하고, 접근 권한을 확인하는 드으이 작업을 매번 수행해야 한다.
    - 따라서, 생성과 삭제를 제외한 모든 연산을 하기 전에 반드시 파일을 `open()` 해야 한다.

</br>

- **파일 쓰기**
    - 파일을 쓰기 위해서는 열린 파일 핸들과 파일에 기록될 정보를 명시하는 시스템 콜을 실행한다.
    - 시스템은 파일 내의 다음 순차적 쓰기가 일어날 위치를 가리키는 쓰기 포인터를 유지하고 있어야 한다.

</br>

- **파일 읽기**
    - 파일을 읽기 위해서 파일 핸들과 파일이 읽어야 할 블록의 위치를 기술하는 시스템 콜을 사용한다.
    - 다시 시스템은 다음 순차적 읽기가 일어날 파일 안의 위치를 가리키는 읽기 포인터를 유지할 필요가 있다.

</br>

- **파일 안에서의 위치 재설정**
    - 열린 파일의 현재 파일 위치를 주어진 값으로 설정한다.

</br>

- **파일 삭제**
    - 파일을 삭제하기 위해 지정된 파일을 디렉터리에서 찾는다.
        - 일부 시스템은 동일한 파일에 대한 여러 개의 이름이 존재할 수 있는 하드 링크를 허용한다.

</br>

- **파일 절단**
    - 사용자가 파일의 내용은 지우고 다만 그 파일의 속성은 그대로 남기기를 원할 때 사용한다.

</br>

> **운영체제는 모든 열린 파일에 대한 정보를 갖는 열린 파일 테이블을 유지한다.**
> 
- 임의의 파일 연산이 요구되면, 이 테이블에 대한 인덱스로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않다.
    - 파일이 더는 사용되지 않으면, 프로세스에 의해 닫히고 운영체제는 열린 파일 테이블에 있는 항목을 제거하며, 락을 해제할 가능성이 있다.

</br>

> **일부 시스템은 파일에 대한 첫 번째 참조가 이루어질 때 파일을 암묵적으로 연다.**
> 
- 이 파일은 자신을 연 작업이나, 프로그램이 종료되면 자동으로 닫힌다.
    - 그러나 대부분의 시스템은 파일이 사용되기 전에 먼저 프로그래머가 `open()` 시스템 콜을 명시적으로 호출하여 열어야 한다.

</br>

> **여러 개의 프로세스가 동시에 파일을 열 수 있는 환경에서 `open()` 과 `close()` 연산들의 구현은 더 복잡하다.**
> 
- 여러 개의 다른 응용들이 동시에 같은 파일을 열 수 있는 시스템에서 이러한 상황은 발생할 수 있다.
    - 보통 운영체제는 두 단계 내부 테이블, 즉 프로세스 별 테이블과 범 시스템 테이블을 사용한다.

</br>

> **프로세스별 테이블의 각 항목은 다시 범 시스템 열린 파일 테이블들을 가리킨다.**
> 
- 이 범 시스템 테이블은 프로세스에 독립적인 정보 즉, 디스크상의 파일 위치, 접근 날짜, 그리고 파일 크기와 같은 정보들을 갖고 있다.
    - 일반적으로, 열린 파일 테이블은 파일을 연 프로세스 수를 가리키는 열린 계수를 각 파일에 연관해 두고 있다.

</br>

> **열린 파일과 관련된 몇 가지 정보들을 요약하면 다음과 같다.**
> 
- **파일 포인터**
    - 읽기와 쓰기 시스템 콜의 일부분으로 파일 오프셋을 포함하지 않는 시스템은 현재 파일 위치 포인터로서 가장 최근의 읽기/쓰기 위치를 추적해야 한다.

</br>

- **파일 열린 계수**
    - 파일이 닫히면, 운영체제는 열린 파일 테이블 항목들을 재사용해야 한다.
    - 아니면, 테이블의 공간이 모자라게 된다.

</br>

- **파일의 위치**
    - 대부분의 파일 연산들은 시스템에 파일 내의 데이터를 읽거나 쓰도록 요구한다.
    - 파일의 위치를 찾기 위한 정보는 연산마다, 디렉터리 구조에서 읽는 것을 피하고자 메모리에 저장된다.

</br>

- **접근 권한**
    - 각 프로세스는 한 파일을 하나의 접근 모드로 연다.
    - 이 정보는 프로세스 별 테이블에 저장되며, 운영체제는 이 정보를 후속 요구를 허용하거나 불허하는 데 사용할 수 있다.

</br>

> **몇몇 운영체제는 열린 파일을 락킹할 수 있는 기능을 제공한다.**
> 
<img width="391" alt="image" src="https://user-images.githubusercontent.com/106216912/225939331-b1c89703-ad60-4d8a-9de9-1f406257b589.png">

- **파일 락**은 읽기-쓰기 락과 유사한 기능을 제공한다.
    - **공유락**은 여러 프로세스가 동시에 락을 획득할 수 있다는 점에서 읽기 락과 비슷하다.
    - **배타적인 락**은 한 번에 한 프로세스만 락을 획득할 수 있다는 점에서 쓰기 락과 비슷하게 행동한다.

</br>

> **게다가, 운영체제는 강제적 또는 권고적 파일 락 방법을 제공할 수도 있다.**
> 
- 강제적 락의 경우, 어떠한 프로세스가 배타적 락을 획득하면 운영체제는 다른 프로세스가 잠겨진 파일에 접근하는 것을 막을 것이다.

</br>

> **파일 락의 사용은 프로세스 동기화처럼 특별한 주의가 필요하다.**
> 
- ex) 강제적 락을 사용하는 시스템에서 개발하고 있는 프로그래머는 파일에 접근할 때만 배타적 락을 가지도록 해야만 한다.
    - 그렇지 않으면, 다른 프로세스가 그 파일에 접근하는 것이 허용되지 않는다.

</br>

### 파일 유형

→ ***전체 운영체제 설계 시 중요한 사항 중 하나는 운영체제가 파일 유형들을 인식하고 지원할 것인지를 결정하는 것이다.***

- 운영체제가 파일 유형을 지원한다면, 운영체제는 파일에 대해 합리적인 연산을 수행할 수 있다.
    - 흔히 잘 알려진 방법은 파일 이름의 한 부분이 파일 유형을 나타내도록 하는 것이다.
        - 파일 이름이 마침표로 구분되는 이름과 확장자 두 부분으로 나뉘게 된다.

<img width="343" alt="image" src="https://user-images.githubusercontent.com/106216912/225939599-fa55920a-646c-4abc-bad2-7d48c36d0168.png">

</br>

> **시스템은 파일 유형에 따라 파일 연산 명령을 결정한다.**
> 
- ex) `.com` , `.exe` , `.sh` 확장자를 가진 파일들은 수행 파일로서 이 확장자를 가진 파일만이 실행 가능하다.
    - `.com` , `.exe` : 이진 형태의 수행 파일
    - `.sh` : **셸 스크립트**

</br>

> **UNIX 시스템은 일부 이진 파일의 시작 부분에 저장된 매직 넘버를 사용하여 파일의 데이터 유형을 나타낸다.**
> 
- 마찬가지로 텍스트 파일의 시작 부분에 텍스트 매직 번호를 사용하여 파일 유형 등을 나타낸다.

</br>

### 파일 구조

→ ***파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다.***

- 각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태로 가지게 된다.
    - 어떤 파일들의 경우에는 운영체제가 인식할 수 있도록 미리 정해진 구조를 따라야 할 때도 있다.

</br>

> **운영체제가 여러 파일 구조를 지원하는 경우에 발생 가능한 단점의 하나는, 운영체제의 크기가 커지고 관리하기 힘들어진다는 점이다.**
> 
- 만일 어떤 운영체제가 다섯 가지의 다른 파일 구조를 지원한다면, 그러한 파일 구조를 지원하기 위한 코드가 부가적으로 필요하다.
    - 또한, 모든 파일은 운영체제에서 지원하는 파일 유형 중 하나로만 정의되어야 하는 것이 필요할 수 있다.

</br>

### 파일의 내부 구조

→ ***내부적으로 한 파일 내의 어떤 위치를 찾는 것은 좀 복잡할 수 있다.***

- 모든 디스크 I/O는 한 블록 단위로 수행되며, 모든 디스크 블록들은 동일한 크기를 가진다.
    - 논리 레코드의 길이는 매우 다양하며, 여러 논리 레코드를 하나의 물리 레코드에 팩킹하는 것이 일반적이다.

</br>

> **논리 레코드의 크기, 물리 블록 크기, 그리고 팩킹 기술은 각 물리 블록 내에 몇 개의 논리 블록이 들어갈지 결정한다.**
> 
- 팩킹은 사용자의 응용 프로그램이나 운영체제의 의해 수행될 수 있다.
    - 어느 경우든 파일은 일련의 블록으로 간주한다.
    - 모든 기본 I/O 기능은 블록 단위로 수행된다.

</br>

> **디스크가 공간이 항상 블록 단위로 할당되기 때문에, 각 파일의 마지막 블록의 일부는 낭비된다.**
> 
- ex) 한 블록이 512바이트라면, 파일의 크기가 1949바이트 일 경우 4블록이 할당되고 마지막 99바이트는 낭비될 것이다.
    - 이렇게 낭비되는 것을 **내부 단편화**라 한다.
    - 블록 크기가 클수록, 내부 단편화가 커진다.

---

## 2. 접근 방법

→ ***파일이 사용될 때는 이 정보가 반드시 접근되어 컴퓨터 메모리로 읽혀야 한다.***

- 일부 시스템은 파일에 대해 단 하나의 접근 방법만 제공한다.

</br>

### 순차 접근

→ ***가장 간단한 접근 방법은 순차 접근이다.***

- 저장되어 있는 레코드 순서로 접근한다.
    - 이 접근 모드는 예를 들면, 편집거나 컴파일러는 보통 이러한 형식으로 파일에 접근한다.

</br>

> **파일에 대한 대부분의 연산은 읽기와 쓰기이다.**
> 
<img width="387" alt="image" src="https://user-images.githubusercontent.com/106216912/225946288-5d5018cb-fe3a-4308-91c7-5c7a36b5c36b.png">

- 읽기는 파일의 다음 부분부터 차례로 읽어 나간다.
    - 읽으면 자동으로 현재 위치를 추적하는 파일 포인터가 자동으로 증가한다.
- 쓰기 작업은 파일의 끝에 추가하며 새로운 파일의 끝으로 파일 포인터가 이동한다.
    - 오프셋을 맨 앞이나 맨 뒤로 옮길 수도 있고, 레코드의 개수만큼 앞뒤로 건너뛸 수도 있다.

</br>

### 직접 접근

→ ***또 다른 방법은 직접 접근(상대 접근)이다.***

- 직접 접근을 위해서 파일은 고정 길이의 논리 레코드의 집합으로 정의되고, 직접 접근 파일은 어떠한 블록이라도 직접 액세스할 수 있다.
    - 직접 접근 방법은 파일의 디스크 모델에 기반하며, 이는 디스크가 임의의 파일 블록에 임의적 접근을 허용하기 때문이다.

</br>

> **직접 접근 파일은 대규모의 정보를 다루는 데 아주 유용하며, 대규모 데이터베이스가 이러한 유형일 수 있다.**
> 
- 어떤 질의가 들어오면 그 답을 수록하고 있는 블록을 알아내어 직접 그 정보를 읽는다.

</br>

> **직접 접근 방법을 위해서는, 파일 연산이 블록 번호 파라미터를 포함할 수 있도록 수정되어야 한다.**
> 
- 블록 번호 `n` 은 통상 파일의 시작을 0으로 보고 계산한 레코드의 위치로써, **상대 블록 번호**이다.
    - 따라서, 블록의 실제 절대적인 디스크 주소가 처음 블록인 경우 14703, 두 번째 블록인 경우 3192일지라도, 파일의 첫 번째 상대 블록은 0이고 다음은 1의 순서이다.

</br>

> **모든 운영체제가 직접 접근 파일과 순차 접근 파일을 둘 다 제공하지는 않는다.**
> 
<img width="426" alt="image" src="https://user-images.githubusercontent.com/106216912/225946462-16ac93ab-6c8a-446c-b485-cf8306d69697.png">

- 어떤 시스템은 순차 접근 파일만 제공하고, 또 다른 시스템은 직접 접근 파일만을 제공한다.
    - 그러나, 직접 접근 파일이 있으면 순차 파일 기능을 쉽게 제공해줄 수는 있다.

</br>

### 기타 접근 방법

→ ***직접 접근 파일이 있으면 그것을 기반으로 여러 가지 다른 파일 접근 방법을 제공할 수 있다.***

- 이들은 대부분 파일에 대한 **색인(index)** 를 사용한다.
    - **색인** : 여러 부분에 대한 포인터를 제공하는 것

</br>

> **파일이 아주 크면 색인 자체도 매우 커 메모리에 다 들어가지 못할 수도 있으므로, 그것 자체를 파일로 만들어 주어야 한다.**
> 

<img width="384" alt="image" src="https://user-images.githubusercontent.com/106216912/225946604-beb4eb3e-c1d8-4ba1-bdc3-90549ac949aa.png">

- 색인 파일이 너무 커지면 그것에 대해서도 또 색인을 만들 수 있다.
    - 일차 색인 파일은 2차 색인 파일의 포인터를 가지고, 이는 다시 실제 자료 항목을 가리킨다.

---

## 3. 디렉터리 구조

→ ***특정한 디렉터리 구조를 고려할 때, 각 디렉터리에 수행될 수 있는 연산을 주의 깊게 살펴보아야 한다.***

</br>

> **디렉터리에 대한 연산**
> 
- **파일 찾기**
    - 사용자는 특정 파일을 찾기 위해서 디렉터리를 탐색할 필요가 있다.

</br>

- **파일 생성**
    - 새로운 파일을 생성해서 디렉터리에 첨가한다.

</br>

- **파일 삭제**
    - 더는 필요하지 않은 파일을 디렉터리에서 삭제한다.

</br>

- **디렉터리 나열**
    - 디렉터리에 존재하는 파일을 나열하고, 파일에 대한 디렉터리 항목의 내용을 보여준다.

</br>

- **파일의 재명명**
    - 파일의 이름을 변경할 수도 있어야 한다.

</br>

- **파일 시스템의 순회**
    - 파일 시스템의 여러 디렉터리를 순회해 다니며 파일을 볼 수 있게 해주는 기능은 매우 유용하다.
    - 또 신뢰성 측면을 고려하면, 파일 시스템 구조와 관련된 정보를 주기적으로 자기 테이프, 다른 보조저장장치 또는 네트워크를 통해 다른 시스템에 또는 클라우드에 저장해 두는 것이 좋다.

</br>

### 1단계 디렉터리

→ ***가장 간단한 디렉터리 구조가 1단계 디렉터리이다.***

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/225960448-10c58c5b-f289-4dc6-a70a-1d2fde7cc038.png">

- 1단계 디렉터리 구조는 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 가지고 있다.
    - 같은 디렉터리에 있는 모든 파일이 존재함으로, 각 파일들은 유일한 이름을 가져야 한다.

</br>

> **심지어 1단계 디렉터리 구조를 한 명의 사용자가 사용한다고 할지라도, 파일의 이름이 증가함에 따라서 모든 파일의 이름을 기억하는 것은 어려울 수 있다.**
> 

</br>

### 2단계 디렉터리

→ ***1단계 디렉터리에 대한 해결책은 각 사용자에게 서로 다른 디렉터리를 만들어주는 것이다.***

<img width="426" alt="image" src="https://user-images.githubusercontent.com/106216912/225960621-958e6bb1-e1f5-432c-a561-244bcef279ed.png">

- 2단계 디렉터리 구조에서는, 각 사용자는 **자신만의 UFD 디렉터리**를 가지고, UFD는 비슷한 구조로 되어 있지만, 각 디렉터리에서는 오직 한 사람의 파일만을 저장한다.
    - 사용자 작업이 시작되거나, 시스템에 사용자가 로그인 등을 통해 접속하게 되면 시스템은 **마스터 파일 디렉터리(MFD)**를 먼저 탐색한다.

</br>

> **그 후, 사용자가 특정한 파일을 시스템에 제시하면 그 UFD 디렉터리 밑에서만 탐색한다.**
> 
- 그러므로 UFD내에서 파일 이름이 유일하다면, 다른 사용자들이 동일한 이름의 파일을 가져도 상관이 없다.
    - 파일의 생성 시 운영체제는 그 이름의 다른 파일이 이미 존재하는지를 확인하기 위해서 UFD만을 검색하기만 하면 된다.

</br>

> **이렇게 되려면 물론 시스템은 각 사용자를 위한 UFD를 만들고 없앨 수 있어야 한다.**
> 
- 이를 위해서는 적정한 사용자 이름과 회계 정보를 가지고 특수 시스템 프로그램을 수행한다.
    - 이 프로그램은 새로운 UFD를 생성하고 MFD에 그 항을 추가한다.
    - 이 프로그램의 수행은 시스템 관리자만이 가능해야 할 것이다.

</br>

> **2단계 디렉터리 구조는 파일 이름이 충돌하는 문제는 어느 정도 해결하였으나, 다른 문제를 새로 제기한다.**
> 
- 두 사용자가 한 파일을 공유해서 사용해야 하는 경우는 문제가 발생한다.
    - 서로가 자신의 UFD 접근을 허용하지 않으면 공유는 불가능할 것이다.

</br>

> **접근이 허용된다면, 한 사용자가 다른 사용자의 디렉터리에 있는 파일을 지칭할 수 있어야 한다.**
> 
- 2단계 디렉터리에서 특정 파일을 유일하게 지칭하기 위해서는 반드시 사용자의 이름과 파일 이름 둘 다 줘야 한다.
    - 2단계 디렉터리는 높이 2의 트리 또는 역 트리로서 간주할 수 있다.

<br>

> **운영체제는 어셈블러, 컴파일러, 유틸리티 루틴, 라이브러리 등의 시스템 프로그램을 일반적인 파일 형태로 가지고 있다.**
> 
- 그러다가 사용자가 터미널에서 명령어를 넣어주면 운영체제는 명령 해석기라는 프로그램에 자기가 방금 받은 명령을 넘겨준다.
    - 한 가지 해결책은 시스템 파일을 각 UFD로 복사하는 것이다.
    - 하지만, 모든 시스템 파일을 복사하는 것은 거대한 공간 낭비를 가져온다.

</br>

> **일반적인 해결책은 검색 절차를 약간 복잡하게 하는 것이다.**
> 
- 시스템 파일을 가지는 특정한 사용자 디렉터리를 정의한다.
    - 시스템에 적재될 파일 이름이 주어질 때마다, 운영체제는 먼저 현재 UFD를 검색한다.
    - 만약 파일을 찾으면, 사용하지만, 찾지 못하면 시스템은 자동으로 특수한 사용자 디렉터리를 탐색한다.

</br>

### 트리 구조 디렉터리

→ ***2단계 디렉터리 구조를 2단계 트리로 보는 방법처럼 여러 단계로 확장하는 일반적인 방법이 임의의 높이를 갖는 트리 구조이다.***

<img width="437" alt="image" src="https://user-images.githubusercontent.com/106216912/225960819-163db37c-849a-42ab-98f5-7941fd675381.png">

- 이것은 일반 사용자들에게 자신의 서브디렉터리를 얼마든지 만들 수 있도록 해준다.
    - 트리는 가장 일반적인 디렉터리 구조이다.
    - 트리 구조이므로 최상위에 하나의 루트 디렉터리가 존재하게 된다.
    - 시스템 내의 모든 파일은 고유한 경로명을 가진다.

</br>

> **디렉터리는 그 하부에 다시 디렉터리나 파일을 가질 수 있다.**
> 
- 많은 구현에서 디렉터리는 단순히 파일과 같지만 특별 취급을 받는 파일이라고 생각할 수 있다.
    - 모든 디렉터리는 내부적으로 똑같은 구조로 되어 있다.

</br>

> **통상적으로 각 프로세스는 현재 디렉터리를 가지고 있다.**
> 
- 현재 디렉터리 안에는 사용자가 현재 관심이 있는 대부분의 파일이 들어 있을 것이다.
    - 따라서 파일의 참조가 일어나면 현재 디렉터리를 먼저 검색한다.
    - 만일 현재 디렉터리에 없는 파일을 참조하려면 탐색 경로를 사용하거나 그 파일이 있는 디렉터리로 먼저 가야 한다.

</br>

> **경로명에는 절대 경로명과 상대 경로명이 있다.**
> 
- **절대 경로명** : 루트에서부터 지정된 파일까지의 경로가 명시된 것
- **상대 경로명** : 현재 디렉터리를 기준으로 목적하는 파일까지의 경로를 지정하는 것

</br>

> **트리 구조에서 생기는 흥미로운 문제**
> 
→ ***디렉토리의 삭제 문제이다.***

- 만약 디렉터리가 비어 있다면 문제가 간단한다.
    - 하지만, 제거 대상 디렉터리가 파일들이나 서브디렉터리들로 아직 채워져 있다면 다음 두 방법의 하나를 택할 수 있다.
        1. 디렉터리가 비어있지 않으면 삭제하지 않는다.
        2. 디렉터리를 삭제하려 할 때, 그 디렉터리 안에 있는 파일이나 서브디렉터리 역시 삭제한다.

</br>

### 비순환 그래프 디렉터리

→ ***비순환 그래프는 디렉터리들이 서브디렉터리들과 파일들을 공유할 수 있도록 허용하는 구조로 똑같은 파일이나 서브디렉터리가 서로 다른 서브디렉터리에 있을 수 있다.***

- 비순환 그래프는 트리 구조 디렉터리 방식을 일반화한 것이다.

<img width="336" alt="image" src="https://user-images.githubusercontent.com/106216912/225961030-7899a103-a2f6-4f0d-b70f-cb2b562c43be.png">

</br>

> **공유를 위해 디렉터리나 파일을 복사하면 안 된다.**
> 
- 공유 파일은 두 개의 복사본과는 다르다.
    - 두 개의 복사본이 있으면 한 복사본을 변경해도 다른 복사본에는 그 영향이 미치지 않는다.
    - 그보다는 물리적으로 한 파일을 공유함으로써 하나의 파일에 가해진 변경을 다른 사용자가 즉시 볼 수 있다.

</br>

> **팀을 이루어 작업을 할 때, 공유되어야 할 모든 파일은 하나의 디렉터리에 놓일 수 있다.**
> 
- 각 팀 구성원의 홈 디렉터리에는 공유파일 디렉터리가 서브디렉터리로 존재하게 된다.
    - 단독 사용자인 경우에도 어떠한 파일은 여러 디렉터리에 존재할 수도 있다.

</br>

> **공유 파일은 여러 가지 방법으로 구현한다.**
> 
- 일반적인 방법은 **링크**라 불리는 새로운 디렉터리 항목을 만드는 것으로, 링크는 다른 파일이나 서브디렉터리를 가리키는 포인터이다.
    - 이러한 링크는 절대, 상대 경로명으로 구현될 수 있고, 파일에 대한 참조가 일어날 때 디렉터리를 검색한다.

</br>

- 다른 방법은 디렉터리들이 동일한 항목 내용을 복사해서 가지고 있는 방법이다.
    - 링크는 원래의 디렉터리와는 완연히 다른 거이므로, 그 두 개는 같은 것이 아니다.
    - 그러나 디렉터리 항목을 복사하는 것은 복사본과 원래 것이 구분이 안 된다.

</br>

> **비순환 그래프 디렉터리는 트리 구조보다는 융통성 있는 대신 더 복잡하다.**
> 
- 파일은 여러 개의 절대 경로명을 가질 수 있다.
    - 결과적으로 다른 파일 이름이 같은 파일을 가리킬 수 있다.

</br>

- 또 다른 문제는 삭제 시의 문제이다.
    - 공유 파일에 할당된 공간을 언제 반납하고 재사용할 수 있을까?
        - 한 가능성은 누구든지 삭제할 경우 그 파일을 제거하는 방법이다.

</br>

- 다른 방법은 모든 참조가 지워질 때까지 원본 파일을 보존하는 것이다.
    - 이 방법을 구현하기 위해서는 파일에 대한 마지막 첨조가 삭제되었는지 판단할 수 있는 방법이 필요하다.

</br>

→ 이 문제의 단점은 **파일 참조 리스트의 사이즈가 가변적이고 매우 커질 수 있다는 것**이다.

- 하지만 참조한 숫자를 가리키는 계수만 유지하면 되므로, 참조 리스트 전체를 저장할 필요는 없다.

</br>

### 일반 그래프 디렉터리

→ ***비순환 그래프 트리 구조에 있어서 중요한 문제점은, 순환이 발생하지 않도록 어떻게 보장하느냐는 것이다.***

<img width="393" alt="image" src="https://user-images.githubusercontent.com/106216912/225961236-daf5c91b-8281-406d-b922-c699db21750a.png">

- 2단계 디렉터리 구조에서 시작해서 사용자가 서브디렉터리를 생성하게 되면, 트리 구조가 형성된다.
    - 기존의 트리에 새로운 링크를 추가하면, 트리 구조는 파괴되고 일반적인 그래프 구조가 될 수 있다.

</br>

> **비순환 그래프의 장점은 파일을 검색하고 파일에 대한 참조의 존재 여부를 결정하는 알고리즘이 비교적 간단하다는 것이다.**
> 
- 디렉터리에서 순환이 허용될 경우에는, 마찬가지로 성능적인 이유와 정확성의 이유에서 한 요소를 두 번 탐색하려 하지 않을 것이다.
    - 잘못 설계된 알고리즘은 순환적으로 계속 탐색하고 종료하지 않는 무한루프에 빠질 수도 있다.
    - 한 가지 해결책은, 한 번에 검색할 수 있는 디렉터리의 숫자를 임의로 제한하는 것이다.

</br>

> **이러한 문제가 파일을 삭제할 경우에도 생긴다.**
> 
- 일반적으로 아무도 참조하지 않는 파일은 참조 계수가 0이 되고, 그러면 이 값이 0이 될 때 이 파일을 삭제하면 된다.
    - 그러나 순환이 존재하면 디렉터리나 파이를 참조하지 않더라도 참조 계수가 0이 아닐 수도 있다.
    - 디렉터리 구조에서 자기 참조로 인하여 이러한 비정상적인 결과를 가져온다.

</br>

→ 이 경우, 마지막 참조가 제거되고 디스크 공간이 재 할당될 수 있을 때를 결정하기 위해서 **가비지 수집 기법**을 사용해야 한다.

- 가비지 컬렉션은 전체 파일 시스템을 검색하고, 접근 가능한 모든 것을 표시한다.
    - 그 후, 두 번째 탐색에서 표시되지 않은 것들을 수집하고 사용 가능한 공간 리스트에 추가한다.

---