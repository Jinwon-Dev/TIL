## 1. 파일 개념

→ ***컴퓨터는 정보를 NVM 장치, HDD, 자기 디스크, 자기 테이프, 광디스크 같은 각기 다른 저장 매체에 저장할 수 있다.***

- **파일** : **저장된 정보에 대해 일관된 논리적 관점을 제공하고, 저장장치의 물리적 특성을 추상화한 논리적 저장 단위**
    - 파일은 운영체제에 의해서 물리 장치들로 사상되며, 일반적으로 비휘발성이기 때문에 시스템이 재부팅되어도 저장된 내용은 영구히 존속된다.

</br>

> **파일은 보조저장장치에 기록된 관련 정보의 집합으로 정의할 수 있다.**
> 
- 사용자의 관점에서 볼 때, 파일은 논리적 보조저장장치의 가장 작은 할당 요소이다.
    - 즉, 자료가 파일 안에 존재해야만 보조저장장치에 기록될 수 있다.
    - 일반적으로 파일은 **프로그램과 자료**를 나타낸다.

</br>

> **파일은 사용자와 응용 프로그램이 데이터를 저장하고 검색하는 데 사용하는 방법이고, 일반적인 용도로 사용 된다.**
> 
- 따라서, 원래 사용 범위를 넘어서 다른 용도로 사용되었다.
    - ex) UNIX, Linux 및 기타 운영체제는 시스템 정보에 대한 액세스를 제공하기 위해서 파일 시스템 인터페이스를 사용하는 `proc` 파일 시스템을 제공한다.

</br>

> **파일 내의 정보는 작성자에 의해 정의된다.**
> 
- **텍스트 파일** : 행들로 구성되는 연속된 문자들
- **소스 파일** : 함수들의 연속
- **실행 파일** : 로더가 메모리로 가져와 실행시킬 수 있는 연속된 코드 부분들

</br>

### 파일 속성

→ ***사용자의 편의를 위해 파일에 이름을 부여하고, 그 이름으로 파일을 참조한다.***

- 파일 이름은 하나의 문자열로 나타낸다.
    - 일부 시스템들은 대문자와 소문자를 서로 다른 문자로 구별해서 파일의 이름을 만든다.
    - 또 다른 시스템들은 이들 문자를 동일 취급한다.

</br>

> **파일은 운영체제마다 다른 속성을 갖지만, 전형적으로 다음과 같은 속성을 가진다.**
> 
- **이름** : 기호형 파일의 이름은 사람이 읽을 수 있는 형태로 유지된 유일한 정보이다.
- **식별자** : 이 고유의 꼬리표는 통상 하나의 숫자로 파일 시스템 내에서 파일을 확인한다.
- **유형** : 이 정보는 여러 유형을 제공하는 시스템을 위해 필요하다.
- **위치** : 이 정보는 파일이 존재하는 장치와 그 장치 내의 위치에 대한 포인터이다.
- **크기** : 파일의 현재 크기와, 최대 허용 가능한 크기가 이 속성에 포함된다.
- **보호** : 접근 제어 정보는 누가 읽기, 쓰기, 실행 등을 할 수 있는가를 제어한다.
- **타임스탬프와 사용자 식별** : 이 정보는 생성, 최근 변경, 최근 사용 등을 유지하고, 보호, 보안 및 사용자 감시를 위해 사용된다.

</br>

> **몇몇 새로운 파일 시스템은 확장된 파일 속성도 지원한다.**
> 
- ex) macOS의 파일 정보 창

<img width="292" alt="image" src="https://user-images.githubusercontent.com/106216912/225938574-9d57fffa-91cb-42f7-90a3-ceac7aebfc22.png">

</br>

### 파일 연산

→ ***파일이란 추상적인 데이터 유형이다.***

</br>

> **운영체제는 파일 생성, 쓰기, 읽기, 위치 재설정, 삭제 및 절단 등을 하기 위한 시스템 콜을 제공한다.**
> 
- **파일 생성**
    - 파일을 생성하기 위해서는 2단계가 필요하다.
        - 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾아야 한다.
        - 새로 생성된 파일에 대한 항목이 디렉터리에 만들어져야 한다.

</br>

- **파일 열기**
    - 모든 파일 연산에서 파일 이름을 지정하게 하면, 운영체제가 이름을 검사하고, 접근 권한을 확인하는 드으이 작업을 매번 수행해야 한다.
    - 따라서, 생성과 삭제를 제외한 모든 연산을 하기 전에 반드시 파일을 `open()` 해야 한다.

</br>

- **파일 쓰기**
    - 파일을 쓰기 위해서는 열린 파일 핸들과 파일에 기록될 정보를 명시하는 시스템 콜을 실행한다.
    - 시스템은 파일 내의 다음 순차적 쓰기가 일어날 위치를 가리키는 쓰기 포인터를 유지하고 있어야 한다.

</br>

- **파일 읽기**
    - 파일을 읽기 위해서 파일 핸들과 파일이 읽어야 할 블록의 위치를 기술하는 시스템 콜을 사용한다.
    - 다시 시스템은 다음 순차적 읽기가 일어날 파일 안의 위치를 가리키는 읽기 포인터를 유지할 필요가 있다.

</br>

- **파일 안에서의 위치 재설정**
    - 열린 파일의 현재 파일 위치를 주어진 값으로 설정한다.

</br>

- **파일 삭제**
    - 파일을 삭제하기 위해 지정된 파일을 디렉터리에서 찾는다.
        - 일부 시스템은 동일한 파일에 대한 여러 개의 이름이 존재할 수 있는 하드 링크를 허용한다.

</br>

- **파일 절단**
    - 사용자가 파일의 내용은 지우고 다만 그 파일의 속성은 그대로 남기기를 원할 때 사용한다.

</br>

> **운영체제는 모든 열린 파일에 대한 정보를 갖는 열린 파일 테이블을 유지한다.**
> 
- 임의의 파일 연산이 요구되면, 이 테이블에 대한 인덱스로 그 파일을 지정하므로 어떠한 탐색도 필요하지 않다.
    - 파일이 더는 사용되지 않으면, 프로세스에 의해 닫히고 운영체제는 열린 파일 테이블에 있는 항목을 제거하며, 락을 해제할 가능성이 있다.

</br>

> **일부 시스템은 파일에 대한 첫 번째 참조가 이루어질 때 파일을 암묵적으로 연다.**
> 
- 이 파일은 자신을 연 작업이나, 프로그램이 종료되면 자동으로 닫힌다.
    - 그러나 대부분의 시스템은 파일이 사용되기 전에 먼저 프로그래머가 `open()` 시스템 콜을 명시적으로 호출하여 열어야 한다.

</br>

> **여러 개의 프로세스가 동시에 파일을 열 수 있는 환경에서 `open()` 과 `close()` 연산들의 구현은 더 복잡하다.**
> 
- 여러 개의 다른 응용들이 동시에 같은 파일을 열 수 있는 시스템에서 이러한 상황은 발생할 수 있다.
    - 보통 운영체제는 두 단계 내부 테이블, 즉 프로세스 별 테이블과 범 시스템 테이블을 사용한다.

</br>

> **프로세스별 테이블의 각 항목은 다시 범 시스템 열린 파일 테이블들을 가리킨다.**
> 
- 이 범 시스템 테이블은 프로세스에 독립적인 정보 즉, 디스크상의 파일 위치, 접근 날짜, 그리고 파일 크기와 같은 정보들을 갖고 있다.
    - 일반적으로, 열린 파일 테이블은 파일을 연 프로세스 수를 가리키는 열린 계수를 각 파일에 연관해 두고 있다.

</br>

> **열린 파일과 관련된 몇 가지 정보들을 요약하면 다음과 같다.**
> 
- **파일 포인터**
    - 읽기와 쓰기 시스템 콜의 일부분으로 파일 오프셋을 포함하지 않는 시스템은 현재 파일 위치 포인터로서 가장 최근의 읽기/쓰기 위치를 추적해야 한다.

</br>

- **파일 열린 계수**
    - 파일이 닫히면, 운영체제는 열린 파일 테이블 항목들을 재사용해야 한다.
    - 아니면, 테이블의 공간이 모자라게 된다.

</br>

- **파일의 위치**
    - 대부분의 파일 연산들은 시스템에 파일 내의 데이터를 읽거나 쓰도록 요구한다.
    - 파일의 위치를 찾기 위한 정보는 연산마다, 디렉터리 구조에서 읽는 것을 피하고자 메모리에 저장된다.

</br>

- **접근 권한**
    - 각 프로세스는 한 파일을 하나의 접근 모드로 연다.
    - 이 정보는 프로세스 별 테이블에 저장되며, 운영체제는 이 정보를 후속 요구를 허용하거나 불허하는 데 사용할 수 있다.

</br>

> **몇몇 운영체제는 열린 파일을 락킹할 수 있는 기능을 제공한다.**
> 
<img width="391" alt="image" src="https://user-images.githubusercontent.com/106216912/225939331-b1c89703-ad60-4d8a-9de9-1f406257b589.png">

- **파일 락**은 읽기-쓰기 락과 유사한 기능을 제공한다.
    - **공유락**은 여러 프로세스가 동시에 락을 획득할 수 있다는 점에서 읽기 락과 비슷하다.
    - **배타적인 락**은 한 번에 한 프로세스만 락을 획득할 수 있다는 점에서 쓰기 락과 비슷하게 행동한다.

</br>

> **게다가, 운영체제는 강제적 또는 권고적 파일 락 방법을 제공할 수도 있다.**
> 
- 강제적 락의 경우, 어떠한 프로세스가 배타적 락을 획득하면 운영체제는 다른 프로세스가 잠겨진 파일에 접근하는 것을 막을 것이다.

</br>

> **파일 락의 사용은 프로세스 동기화처럼 특별한 주의가 필요하다.**
> 
- ex) 강제적 락을 사용하는 시스템에서 개발하고 있는 프로그래머는 파일에 접근할 때만 배타적 락을 가지도록 해야만 한다.
    - 그렇지 않으면, 다른 프로세스가 그 파일에 접근하는 것이 허용되지 않는다.

</br>

### 파일 유형

→ ***전체 운영체제 설계 시 중요한 사항 중 하나는 운영체제가 파일 유형들을 인식하고 지원할 것인지를 결정하는 것이다.***

- 운영체제가 파일 유형을 지원한다면, 운영체제는 파일에 대해 합리적인 연산을 수행할 수 있다.
    - 흔히 잘 알려진 방법은 파일 이름의 한 부분이 파일 유형을 나타내도록 하는 것이다.
        - 파일 이름이 마침표로 구분되는 이름과 확장자 두 부분으로 나뉘게 된다.

<img width="343" alt="image" src="https://user-images.githubusercontent.com/106216912/225939599-fa55920a-646c-4abc-bad2-7d48c36d0168.png">

</br>

> **시스템은 파일 유형에 따라 파일 연산 명령을 결정한다.**
> 
- ex) `.com` , `.exe` , `.sh` 확장자를 가진 파일들은 수행 파일로서 이 확장자를 가진 파일만이 실행 가능하다.
    - `.com` , `.exe` : 이진 형태의 수행 파일
    - `.sh` : **셸 스크립트**

</br>

> **UNIX 시스템은 일부 이진 파일의 시작 부분에 저장된 매직 넘버를 사용하여 파일의 데이터 유형을 나타낸다.**
> 
- 마찬가지로 텍스트 파일의 시작 부분에 텍스트 매직 번호를 사용하여 파일 유형 등을 나타낸다.

</br>

### 파일 구조

→ ***파일의 유형을 사용하여 파일의 내부 구조 형태를 짐작할 수 있다.***

- 각각의 파일들은 그 파일을 다루는 프로그램에 의해 인식 가능한 내부 구조를 일정한 형태로 가지게 된다.
    - 어떤 파일들의 경우에는 운영체제가 인식할 수 있도록 미리 정해진 구조를 따라야 할 때도 있다.

</br>

> **운영체제가 여러 파일 구조를 지원하는 경우에 발생 가능한 단점의 하나는, 운영체제의 크기가 커지고 관리하기 힘들어진다는 점이다.**
> 
- 만일 어떤 운영체제가 다섯 가지의 다른 파일 구조를 지원한다면, 그러한 파일 구조를 지원하기 위한 코드가 부가적으로 필요하다.
    - 또한, 모든 파일은 운영체제에서 지원하는 파일 유형 중 하나로만 정의되어야 하는 것이 필요할 수 있다.

</br>

### 파일의 내부 구조

→ ***내부적으로 한 파일 내의 어떤 위치를 찾는 것은 좀 복잡할 수 있다.***

- 모든 디스크 I/O는 한 블록 단위로 수행되며, 모든 디스크 블록들은 동일한 크기를 가진다.
    - 논리 레코드의 길이는 매우 다양하며, 여러 논리 레코드를 하나의 물리 레코드에 팩킹하는 것이 일반적이다.

</br>

> **논리 레코드의 크기, 물리 블록 크기, 그리고 팩킹 기술은 각 물리 블록 내에 몇 개의 논리 블록이 들어갈지 결정한다.**
> 
- 팩킹은 사용자의 응용 프로그램이나 운영체제의 의해 수행될 수 있다.
    - 어느 경우든 파일은 일련의 블록으로 간주한다.
    - 모든 기본 I/O 기능은 블록 단위로 수행된다.

</br>

> **디스크가 공간이 항상 블록 단위로 할당되기 때문에, 각 파일의 마지막 블록의 일부는 낭비된다.**
> 
- ex) 한 블록이 512바이트라면, 파일의 크기가 1949바이트 일 경우 4블록이 할당되고 마지막 99바이트는 낭비될 것이다.
    - 이렇게 낭비되는 것을 **내부 단편화**라 한다.
    - 블록 크기가 클수록, 내부 단편화가 커진다.

---