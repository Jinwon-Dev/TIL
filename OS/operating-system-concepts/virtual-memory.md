> **가상 메모리** → **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법**

- 장점 : **사용자 프로그램이 물리 메모리보다 커져도 된다.**
    - 가상 메모리는 물리 메모리로부터 프로그래머 관점의 논리 메모리를 분리해, 메인 메모리를 균일한 크기의 저장 공간으로 구성된 엄청나게 큰 배열로 추상화시켜 준다!

</br>

- 또한, **가상 메모리는 파일과 라이브러리의 공유를 쉽게 해주고 공유 메모리 구현을 가능**하게 한다.
    - 하지만, 이러한 가상 메모리는 구현하기 어렵다.
    - 또한, 잘못 사용하게 된다면 성능이 현저히 저하될 수 있다.

---

## 1. 배경

→ ***프로그램을 일부분만 메모리에 올려놓고 실행할 수 있다면 많은 이점이 있다.***

1. **프로그램은 물리 메모리 크기에 의해 더는 제약받지 않게 된다.**
    - 사용자들은 매우 큰 가상 주소 공간을 가정하고 프로그램을 만들 수 있으므로, 프로그래밍 작업이 간단해진다.

</br>

2. **각 프로그램이 더 작은 메모리를 차지하므로, 더 많은 프로그램을 동시에 수행할 수 있다.**
    - 응답 시간은 늘어나지 않으면서도 CPU 이용률과 처리율이 높아진다.

</br>

3. **프로그램을 메모리에 올리고 스왑하는 데 필요한 I/O 횟수가 줄어들기 때문에 프로그램들이 보다 빨리 실행된다.**

</br>

→ **프로그램의 일부만을 메모리에 올려놓고 실행하면, 시스템과 사용자 모두에게 이득이 된다!**

</br>

> **가상 메모리는 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것이다.**

- 장점 : **작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공**할 수 있다.
    - 프로그래머는 메모리 크기에 관련한 문제를 염려할 필요 없이, 실제 해결하는 문제에만 집중할 수 있게 된다.

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/221362082-7daab735-3b17-434e-974b-3442ac470b98.png">

</br>

> **한 프로세스의 가상 주소 공간은 그 프로세스가 메모리에 저장되는 논리적인 모습을 말한다.**

<img width="191" alt="image" src="https://user-images.githubusercontent.com/106216912/221362111-4c97d026-e0c5-41fb-9d16-3e7192cbce92.png">

- 일반적으로, 특정 논리 주소에서 시작하여 연속적인 공간을 차지한다.
    - **힙(heap)** 은 동적 할당 메모리를 사용함에 따라 주소 공간상에서 위쪽으로 확장된다.
    - **스택(stack)** 또한 함수 호출을 거듭함에 따라 주소 공간상에서 아래쪽으로 확장된다.
        - 힙과 스택 사이의 공백도 가상 주소 공간의 일부이지만, 힙 또는 스택이 확장되어야만 실제 물리 페이지를 요구하게 될 것이다.

</br>

→ 공백을 포함하는 가상 주소 공간을 **성긴 주소 공간**이라고 한다!

- **성긴 주소 공간의 공백은 스택이나 힙 세그먼트가 확장될 때 사용되거나 프로그램 실행 중 동적으로 라이브러리를 링크할 필요가 있을 때 사용**된다.

</br>

> **가상 메모리는 또한 페이지 공유를 통해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 한다!**

→ ***이는 다음과 같은 장점을 갖는다.***

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/221362641-76fc60a4-df22-4720-ac56-3f6901f3f904.png">

1. **시스템 라이브러리가 여러 프로세스들에 공유될 수 있다.**
    - 각 프로세스는 라이브러리가 자신의 가상 주소 공간 일부라고 생각하지만, 실제로는 라이브러리가 존재하는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.

</br>

2. **프로세스들이 메모리를 공유할 수 있다.**
    - 가상 메모리는 한 프로세스가 다른 프로세스와 공유할 수 있는 영역을 만들 수 있도록 해 준다.

</br>

3. **페이지는 `fork()` 시스템 콜을 통한 프로세스 생성 과정 중에 공유될 수 있기 때문에 프로세스 생성 속도를 높일 수 있다.**

---

## 2. 요구 페이징

→ ***어떻게 실행 프로그램을 보조저장장치에서 메모리로 적재할 수 있을까?***

1. 프로그램 실행 시작 시 프로그램의 전부를 물리 메모리에 적재한다.
    - 문제 : 초기에는 프로그램의 전체가 메모리에 있을 필요는 없을지도 모른다.

</br>

2. 필요한 페이지만 적재한다.
    - 이 방법은 **요구 페이징(demand paging)** 이라고 하며, 가상 메모리 시스템에서 일반적으로 사용된다.
        - 요구 페이징 가상 메모리를 사용하면 **프로그램 실행 중 필요할 때만 페이지가 적재**된다.
        - 접근되지 않은 페이지는 물리 메모리로 적재되지 않는다.

</br>

### 기본 개념

→ ***요구 페이징의 기본 개념은 필요할 때만 페이지를 메모리에 적재하는 것이다.***

- 결과적으로 프로세스가 실행되는 동안 일부 페이지는 메모리에 있고, 일부는 보조저장장치에 있다.
    - **따라서, 이 둘을 구별하기 위해 하드웨어 지원이 필요하다!**

</br>

<img width="438" alt="image" src="https://user-images.githubusercontent.com/106216912/221364427-21478318-b3b4-4d17-bd28-0b67df4ea415.png">

- 유효, 무효 비트 기법이 사용될 수 있다.
    - **유효(valid)** : 해당 페이지가 메모리에 있다.
    - **무효(invalid)** : 해당 페이지가 유효하지 않거나, 유효하지만 보조저장장치에 존재한다.

</br>

> **그러나, 프로세스가 메모리에 올라와 있지 않은 페이지에 접근하려고 하면 어떠한 일이 발생할까?**

- 이때, 페이지 테이블 항목이 무효로 설정되어 있으므로 **페이지 폴트 트랩**을 발생시킨다.
    - 페이징 하드웨어는 페이지 테이블을 이용한 주소 변환 과정에서 무효 비트를 발견하고 운영체제에 트랩을 건다.

</br>

> **페이지 폴트를 처리하는 과정**

<img width="528" alt="image" src="https://user-images.githubusercontent.com/106216912/221364487-76621a4f-252e-49e1-b0f0-0f0985a91953.png">

1. 프로세스에 대한 내부 테이블(internal table)을 검사해서 그 메모리 참조가 유효, 무효인지를 알아낸다.
2. 만약 무효한 페이지에 대한 참조라면, 그 프로세스는 중단된다.
    - 유효한 참조인데 페이지가 아직 메모리에 올라오지 않았다면, 그것을 보조저장장치로부터 가져와야 한다.
3. 빈 공간, 즉 가용 프레임을 찾는다.
4. 보조 저장장치에 새로이 할당된 프레임으로 해당 페이지를 읽어 들이도록 요청한다.
5. 보조저장장치 읽기가 끝나면, 이 페이지가 이제는 메모리에 있다는 것을 알리기 위해 페이지 테이블을 갱신한다.
    - 또한, 프로세스가 유지하고 있는 내부 테이블을 수정한다.
6. 트랩에 의해 중단되었던 명령어를 다시 수행한다.
    - 이제 프로세스는 마치 그 페이지가 항상 메모리에 있었던 것처럼 해당 페이지에 접근할 수 있다.

</br>

> **극단적인 경우에는 메모리에 페이지가 하나도 안 올라와 있는 상태에서도 프로세스를 실행시킬 수 있다.**

- 운영체제에서 명령 포인터의 값을 프로세스의 첫 명령으로 설정하는 순간, 이 명령이 메모리에 존재하지 않은 페이지에 있으므로 페이지 폴트를 발생시킨다.
    - 페이지가 적재되고 나면 프로세스는 수행을 계속하는데 프로세스가 사용하는 모든 페이지가 메모리에 올라올 때까지 필요할 때마다 페이지 폴트가 발생한다.
    - 필요한 모든 페이지가 적재되고 나면, 더 폴트가 발생하지는 않는다.

</br>

→ **순수 요구 페이징(pure demand paging)**

- 즉, **어떤 페이지가 필요해지기 전에는 결코 그 페이지를 메모리로 적재하지 않는 방법**이다.

</br>

> **요구 페이징을 지원하기 위해 필요한 하드웨어는 페이징과 스와핑을 위한 하드웨어와 동일하다.**

- **페이지 테이블**
    - 보호 비트들을 특별한 값, 또는 유효, 무효 비트를 통해 특정 항목을 무효로 설정할 수 있어야 한다.

</br>

- **보조 저장장치**
    - 메인 메모리에 없는 모든 페이지를 가지고 있다.
    - 보통은 고성능의 디스크, 또는 NVM이다.
    - **스왑 장치**라고도 하며, 이 목적을 위해 사용하는 저장장치 영역을 **스왑 공간**이라고 한다.

</br>

> **요구 페이징을 위한 필수적인 요구 사항은 페이지 폴트 오류 처리 후에 명령어 처리를 다시 시작할 수 있어야 한다는 것이다!**

- 페이지 폴트가 발생하여 중단된 프로세스 상태를 보관해 두면, 다시 이 프로세스를 시작할 때 해당 페이지가 메모리로 올라와서 접근 가능하다는 것 이외에는 정확히 같은 위치, 같은 상태에서 프로세스를 다시 수행할 수 있다.

</br>

> **한 명령어가 많은 기억 장소를 변경하는 것일 때는 상당히 어려운 문제가 발생한다.**

- 어느 블록이라도 페이지 경계에서 양쪽에 걸쳐 있으면 이동이 다 끝나지도 않은 상태에서 페이지 폴트가 발생할 수 있다.
    - 원천 블록과 목적 블록이 서로 겹쳐져 있는 경우에는, 단순히 명령어를 다시 실행하는 것만으로는 문제가 해결되지 않는다.

</br>

> **위와 같은 문제는 두 가지 방법으로 해결할 수 있다.**

1. 마이크로코드(microcode)로 양 블록의 두 끝을 계산하여 겹치지 않는 것을 확인한 후에, 접근을 시도한다.
2. 이동에 의해서 이전의 내용이 지워질 기억 장소들의 값을 보존하기 위해 임시 레지스터들을 사용한다.

</br>

### 가용 프레임 리스트

→ ***페이지 폴트를 해결하기 위해 대부분의 운영체제는 가용 프레임의 풀인 가용 프레임 리스트를 유지한다.***

<img width="388" alt="image" src="https://user-images.githubusercontent.com/106216912/221364564-2d695b89-655b-4e9f-ba84-ee7b5d876d28.png">

- 운영체제는 일반적으로 **zero-fill-on-demand**라는 기법을 사용해서 가용 프레임을 할당한다.
    - **이 프레임은 할당되기 전에 0으로 모두 채워져서 이전 내용이 지워진다.**

</br>

> **시스템이 시작되면 모든 가용 메모리가 가용 프레임 리스트에 넣어진다.**

- 가용 프레임이 요청되면, 가용 프레임 리스트의 크기가 줄어든다.

</br>

### 요구 페이징의 성능

→ ***요구 페이징은 컴퓨터 시스템의 성능에 큰 영향을 줄 수 있다.***

- **실질 접근 시간(effective access time : EAT)**
    - `p` = 페이지 폴트 확률
    - `ma` = 기억 장소 접근 시간
    - 실질 접근 시간 = `(1 - p) x ma + p x (페이지 폴트 시간)`

</br>

> **실제 접근 시간은 페이지 폴트율(page fault rate)에 비례한다.**

- ex) 1000번 중에 한 번의 접근에 페이지 폴트가 발생한다고 하면, 실제 접근 시간은 8.2마이크로초이다.
    - **컴퓨터는 요구 페이징 때문에 40배나 느려진다!**

</br>

- 만약 성능 저하를 10% 이하로 낮추고 싶다면, 다음 조건이 필요하다.

<img width="239" alt="image" src="https://user-images.githubusercontent.com/106216912/221364598-ef2d9950-b9f7-4d2b-80dc-b36e4a75cd44.png">

</br>

→ **요구 페이징 시스템에서 페이지 폴트 비율을 낮게 유지시키는 것은 상당히 중요하다!**

- **그렇지 않으면 실질 접근 시간이 커지고, 프로세스 수행은 심각하게 늦어진다.**

</br>

> **요구 페이징의 또 다른 특성 중 하나는 스왑 공간의 관리이다.**

- 스왑 공간에서의 디스크 입출력은 일반적으로 파일시스템의 입출력보다 빠르다.
    - 스왑 공간은 파일 시스템보다 더 큰 블록을 사용하고, 파일 찾기나 간접 할당 방법 등은 사용하지 않기 때문이다.

</br>

- **시스템이 더 나은 페이징 처리량을 얻는 옵션**
    1. 프로세스 시작 시 전체 파일 이미지를 스왑 공간에 복사한 다음, 스왑 공간에서 요구 페이징을 수행한다.
    - 단점 : 프로그램 시작 시 파일 이미지를 복사하는 것
    2. 프로그램을 처음 시작시킬 때는 파일 시스템으로부터 요구 페이징을 처리하지만, 그 페이지들이 교체될 때는 스왑 공간에 페이지를 기록한다.

</br>

> **어떤 시스템들은 실행 파일을 스왑 공간에 넣지 않음으로써 스왑 공간의 크기를 줄인다.**

- 실행 파일로부터 요구 페이지를 요청하면, 파일 시스템으로부터 그 페이지를 직접 가져온다.
    - 이 페이지들의 교체가 필요하면 이들 페이지에 새 페이지의 내용을 그대로 덮어쓸 수 있다.

</br>

- 그러나 스왑 공간은 여전히 파일과 관련이 없는 페이지 때문에 필요하다!
    - 이러한 메모리를 **익명(anonymous) 메모리**라고 한다.
        - 프로세스의 스택 및 힙이 포함된다.

</br>

> **모바일 운영체제는 통상 스와핑을 지원하지 않는다.**

- 대신 파일 시스템으로부터 요구 페이징을 하고 메모리가 부족하게 되면 응용으로부터 코드와 같은 읽기 전용 페이지들을 방출한다.

---