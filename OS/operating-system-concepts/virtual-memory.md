> **가상 메모리** → **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법**

- 장점 : **사용자 프로그램이 물리 메모리보다 커져도 된다.**
    - 가상 메모리는 물리 메모리로부터 프로그래머 관점의 논리 메모리를 분리해, 메인 메모리를 균일한 크기의 저장 공간으로 구성된 엄청나게 큰 배열로 추상화시켜 준다!

</br>

- 또한, **가상 메모리는 파일과 라이브러리의 공유를 쉽게 해주고 공유 메모리 구현을 가능**하게 한다.
    - 하지만, 이러한 가상 메모리는 구현하기 어렵다.
    - 또한, 잘못 사용하게 된다면 성능이 현저히 저하될 수 있다.

---

## 1. 배경

→ ***프로그램을 일부분만 메모리에 올려놓고 실행할 수 있다면 많은 이점이 있다.***

1. **프로그램은 물리 메모리 크기에 의해 더는 제약받지 않게 된다.**
    - 사용자들은 매우 큰 가상 주소 공간을 가정하고 프로그램을 만들 수 있으므로, 프로그래밍 작업이 간단해진다.

</br>

2. **각 프로그램이 더 작은 메모리를 차지하므로, 더 많은 프로그램을 동시에 수행할 수 있다.**
    - 응답 시간은 늘어나지 않으면서도 CPU 이용률과 처리율이 높아진다.

</br>

3. **프로그램을 메모리에 올리고 스왑하는 데 필요한 I/O 횟수가 줄어들기 때문에 프로그램들이 보다 빨리 실행된다.**

</br>

→ **프로그램의 일부만을 메모리에 올려놓고 실행하면, 시스템과 사용자 모두에게 이득이 된다!**

</br>

> **가상 메모리는 실제의 물리 메모리 개념과 개발자의 논리 메모리 개념을 분리한 것이다.**

- 장점 : **작은 메모리를 가지고도 얼마든지 큰 가상 주소 공간을 프로그래머에게 제공**할 수 있다.
    - 프로그래머는 메모리 크기에 관련한 문제를 염려할 필요 없이, 실제 해결하는 문제에만 집중할 수 있게 된다.

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/221362082-7daab735-3b17-434e-974b-3442ac470b98.png">

</br>

> **한 프로세스의 가상 주소 공간은 그 프로세스가 메모리에 저장되는 논리적인 모습을 말한다.**

<img width="191" alt="image" src="https://user-images.githubusercontent.com/106216912/221362111-4c97d026-e0c5-41fb-9d16-3e7192cbce92.png">

- 일반적으로, 특정 논리 주소에서 시작하여 연속적인 공간을 차지한다.
    - **힙(heap)** 은 동적 할당 메모리를 사용함에 따라 주소 공간상에서 위쪽으로 확장된다.
    - **스택(stack)** 또한 함수 호출을 거듭함에 따라 주소 공간상에서 아래쪽으로 확장된다.
        - 힙과 스택 사이의 공백도 가상 주소 공간의 일부이지만, 힙 또는 스택이 확장되어야만 실제 물리 페이지를 요구하게 될 것이다.

</br>

→ 공백을 포함하는 가상 주소 공간을 **성긴 주소 공간**이라고 한다!

- **성긴 주소 공간의 공백은 스택이나 힙 세그먼트가 확장될 때 사용되거나 프로그램 실행 중 동적으로 라이브러리를 링크할 필요가 있을 때 사용**된다.

</br>

> **가상 메모리는 또한 페이지 공유를 통해 파일이나 메모리가 둘 또는 그 이상의 프로세스들에 의해 공유되는 것을 가능하게 한다!**

→ ***이는 다음과 같은 장점을 갖는다.***

1. **시스템 라이브러리가 여러 프로세스들에 공유될 수 있다.**
    - 각 프로세스는 라이브러리가 자신의 가상 주소 공간 일부라고 생각하지만, 실제로는 라이브러리가 존재하는 물리 메모리 페이지들은 모든 프로세스에 공유되고 있다.

</br>

2. **프로세스들이 메모리를 공유할 수 있다.**
    - 가상 메모리는 한 프로세스가 다른 프로세스와 공유할 수 있는 영역을 만들 수 있도록 해 준다.

</br>

3. **페이지는 `fork()` 시스템 콜을 통한 프로세스 생성 과정 중에 공유될 수 있기 때문에 프로세스 생성 속도를 높일 수 있다.**
---