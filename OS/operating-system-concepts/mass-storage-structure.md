> **최신 컴퓨터의 기본 대용량 저장장치 시스템은 보조저장장치이며, 일반적으로 HDD 및 NVM 장치를 사용하여 제공된다.**

- **HDD, NVM 장치** 이 두 가지 유형의 저장장치에 관해 알아본다.
- 성능을 최대화하기 위해 **I/O 순서를 스케줄 하는 스케줄링 알고리즘**을 고려한다.
- **장치 포맷팅과 부트 블록, 손상된 블록 및 스왑 공간의 관리**에 대해 알아본다.
- **RAID 시스템**의 구조를 살펴본다.

---

## 1. 대용량 저장장치 구조의 개관

→ ***최신 컴퓨터를 위한 대량의 보조저장장치는 하드 디스크 드라이브(HDD) 및 비휘발성 메모리(NVM) 장치에 의해 관리된다.***

- 이번 절에서는 이러한 장치의 기본 기법, 운영체제가 주소 매핑을 통해 물리적 속성을 논리 저장장치로 변환하는 방법을 설명한다.

</br>

### 하드 디스크 드라이브

→ ***개념적으로 HDD는 비교적 단순하다.***

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/222909010-034984df-2c7f-4fa1-a808-6e631c4baecc.png">

- 각 디스크의 **플래터(platter)** 는 CD처럼 생긴 원형 평판 모양이다.
    - 플래터의 양쪽 표면은 자기 테이프와 유사하게 자기 물질로 덮여 있다.
    - 우리는 정보를 플래터상에 자기적으로 기록하여 저장하고, 플래터의 자기 패턴을 감지하여 정보를 읽는다.

</br>

> **읽기-쓰기 헤드는 모든 플래터의 각 표면 바로 위에서 움직인다.**

- 헤드는 모든 헤드를 한꺼번에 이동시키는 **디스크 암(disk arm)** 에 부착되어 있다.
    - 플래터의 표면은 원형인 **트랙(track)** 으로 논리적으로 나누어져 있고, 이것은 다시 **섹터(sector)** 로 나누어진다.
    - 트랙의 집합은 하나의 **실린더(cylinder)** 를 형성한다.

</br>

> **디스크 드라이브 모터는 고속으로 회전한다.**

- 대부분의 드라이브는 **분당 회전수(RPM)** 단위로 표현되며, 초당 60~250회 회전한다.
    - 일반 드라이브는 5,400, 7,200, 10,000 및 15,000 RPM에서 회전한다.

- 회전 속도는 전송 속도와 관련이 있다.
    - **전송 속도** : 드라이브와 컴퓨터 간의 데이터 흐름의 속도
    - **액세스 시간**
        - **탐색 시간** : 디스크 암을 원하는 실린더로 이동하는 데 필요한 시간
        - **회전 지연시간** : 원하는 섹터가 디스크 헤드 위치까지 회전하는 데 걸리는 시간

</br>

> **디스크 헤드는 공기 또는 헬륨과 같은 다른 가스의 매우 얇은 쿠션 위를 비행하며 헤드가 디스크 표면에 닿을 위험이 있다.**

- **헤드 충돌** : 디스크 플래터는 얇은 보호 층으로 코팅되어 있지만, 헤드는 때때로 자기 표면을 손상한다.
    - 일반적으로 수리할 수 없고, 전체 디스크를 교체해야 한다.

</br>

### 비휘발성 메모리 장치

→ ***비휘발성 메모리(NVM) 장치의 중요성이 증가하고 있다.***

</br>

> **비휘발성 메모리 장치 개요**

→ ***플래시 메모리 기반 NVM은 디스크 드라이브와 유사한 컨테이너에서 자주 사용되며, SSD라고 한다.***

- 다른 경우에는 USB 드라이브 또는 DRAM 스틱의 형태를 취한다.

<img width="345" alt="image" src="https://user-images.githubusercontent.com/106216912/222909388-23aaffbf-0c40-4bff-969a-208057d32426.png">

</br>

> **NVM 장치는 움직이는 부품이 없으므로 HDD보다 안정성이 높으며, 탐색 시간이나 회전 지연시간이 없으므로 더 빠를 수 있다!**
> 
- 또한, **전력 소비량**도 적다.
    - **단점 : 기존 하드 디스크보다 비싸고, 용량이 적다.**

</br>

→ 하지만, **NVM 장치의 용량이 HDD 용량보다 빠르게 증가하고, 가격은 빠르게 하락하여 사용량이 급격히 증가하고 있다.**

- 일부 랩탑에서는 더 작고, 빠르고, 에너지 효율적이다.

</br>

> **NVM 장치는 하드 디스크 드라이브보다 훨씬 빠를 수 있으므로, 표준 버스 인터페이스가 처리량을 크게 제한할 수 있다.**
> 
- 일부 NVM 장치는 시스템 버스에 직접 연결되도록 설계되었다.
    - 일부 시스템은 디스크 드라이브를 직접 대체하는 데 사용하는 반면, 다른 시스템은 새로운 캐시 계층을 사용하여 성능을 최적화하기 위해 자기 디스크, NVM 및 메인 메모리 간에 데이터를 이동한다.

</br>

> **NAND 반도체는 일부 특성 때문에 자체적인 저장 및 신뢰성 문제를 가진다.**
> 
- 섹터와 유사한 “페이지” 단위로 읽고 쓸 수 있지만, 데이터를 덮어쓸 수는 없다.
    - 덮어쓰기 위해서는 NAND 셀을 먼저 지워야 한다.

</br>

- 쓰기 마모로 인해 그리고 움직이는 부품이 없기 때문에 NAND NVM 수명은 연 단위가 아니라 **DWPD(Drive Writes Per Day)** 로 측정된다.
    - **드라이브 장애가 발생하기 전에 드라이브 용량에 해당하는 데이터를 하루에 몇 번 쓸 수 있는지**를 나타낸다.

</br>

→ 이러한 제한으로 인해, 여러 가지 개선 알고리즘이 고안되었다!

- 일반적으로 NVM 장치 컨트롤러에서 구현되며, 운영체제가 신경 쓰지 않아도 된다.
    - 운영체제는 단순히 논리 블록을 읽고 쓰고, 장치가 그 연산을 관리한다.

</br>

> **NAND 플래시 컨트롤러 알고리즘**
> 
→ ***NAND 반도체는 한 번 쓴 후에는 덮어쓸 수 없으므로, 일반적으로 유효하지 않은 데이터가 포함된 페이지가 있다.***

- 한 번 기록된 후, 나중에 다시 기록된 파일 시스템 블록을 고려하자.
    - 그 사이에 삭제가 발생하지 않은 경우 처음 기록된 페이지에는 이전 데이터가 저장되어 있으며, 현재는 유효하지 않은 데이터이다.

</br>

<img width="346" alt="image" src="https://user-images.githubusercontent.com/106216912/222909788-a52bbd08-c7e2-4d3a-a37b-9411432ba637.png">

- 유효한 데이터와 유효하지 않은 페이지를 포함하는 **NAND 블록**이다.
    - 유효한 데이터를 포함하는 논리 블록을 추적하기 위해 컨트롤러는 **플래시 변환 계층(FTL)** 을 유지한다.
        - **이 테이블은 현재 유효한 논리 블록을 포함하는 물리 페이지를 매핑한다.**

</br>

> **보류 중인 쓰기 요청이 있는 전체 SSD를 고려하자.**
> 
- SSD가 가득 찼기 때문에 모든 페이지가 기록되었지만, 그 중 유효하지 않은 데이터만 포함하고 있는 블록이 있을 수 있다.
    - 개별 페이지에 유효하지 않은 데이터가 있으면 여전히 사용 가능한 공간이 있을 수 있다.
    - 이 경우, **가비지 수집**이 발생할 수 있다.

</br>

- 그러나 가비지 수집은 유효한 데이터를 어디에 저장해야 할까?
    - 이 문제를 해결하고 쓰기 성능을 향상하기 위해 NVM 장치는 **과잉 공급**을 사용한다.
    - **장치는 언제나 쓸 수 있도록 다수의 페이지를 따로 준비해 놓는다.**

</br>

> **과잉 공급 공간은 마모 평준화(wear leveling)에도 도움이 된다.**
> 
- 다른 블록에 비해 일부 블록만 반복적으로 지워지면 자주 지워지는 블록은 다른 블록보다 빨리 마모된다.
    - 그리고, 모든 블록이 동시에 마모되는 경우보다 전체 장치의 수명이 짧아진다.

</br>

> **데이터 보호 측면에서 NVM 장치는 오류 수정 코드를 제공한다.**
> 
- 이 코드는 기록될 때 계산되어 데이터와 함께 저장되고, 읽을 때 데이터와 함께 읽어 오류를 감지하고 수정한다.

</br>

### 휘발성 메모리

→ ***RAM 드라이브는 보조저장장치처럼 작동하지만, 시스템 DRAM의 한 영역을 할당하여 저장장치인 것처럼 나머지 시스템에 제공하는 장치 드라이버에 의해 생성된다.***

- DRAM은 휘발성이며, RAM 드라이브의 데이터는 시스템 크래시, 종료 또는 전원이 꺼진 후에는 지속되지 않는다.
    - RAM 드라이브를 사용하면 사용자와 프로그래머가 **표준 파일 연산을 사용하여 데이터를 메모리에 임시로 보관할 수 있다.**

</br>

> **RAM 드라이브는 고속 임시 저장 공간으로 유용하다.**
> 
- DRAM은 NVM 장치보다 **훨씬 빠르다.**
    - 또한, RAM 드라이브에 대한 I/O 작업은 파일과 내용을 생성, 읽기, 쓰기 및 삭제하는 가장 빠른 방법이다.
    - 많은 프로그램이 임시 파일을 저장하기 위해 RAM 드라이브를 사용하거나 혜택을 얻을 수 있다.

</br>

### 보조저장장치 연결 방법

→ ***보조저장장치는 시스템 버스 또는 I/O 버스에 의해 컴퓨터에 연결된다.***

- **ATA, SATA, eSATA, SAS, USB, FC**를 포함하여 여러 종류의 버스를 사용할 수 있다.
    - NVM 장치는 HDD보다 훨씬 빠르기 때문에, 산업계에서는 **NVMe**라는 NVM 장치를 위한 특별하고 빠른 인터페이스를 만들었다.
        - NVMe는 **장치를 시스템 PCI 버스에 직접 연결하여 다른 연결 방법과 비교해 처리량을 높이고, 지연시간을 줄인다.**

</br>

> **버스에서의 데이터 전송은 컨트롤러라고 하는 특수 전자 프로세서에 의해 수행된다.**
> 
- **호스트 컨트롤러**는 버스의 컴퓨터 쪽에 있는 컨트롤러이다.
    - 각 저장장치에는 **장치 컨트롤러**가 내장되어 있다.

</br>

### 주소 매핑

→ ***저장장치는 논리 블록의 커다란 1차원 배열처럼 주소가 매겨진다.***

- 논리 블록은 가장 작은 전송 단위이고, 각 논리 블록은 물리 섹터 또는 반도체 페이지로 매핑된다.
    - 논리 블록의 1차원 배열은 장치의 섹터들 또는 페이지들에 매핑된다.

</br>

- 매핑은 해당 트랙을 순서대로 완료한 후에, 해당 실린더의 나머지 트랙을 매핑한 다음 나머지 실린더를 바깥쪽에서 안쪽 순으로 매핑한다.
    - NVM의 경우 칩, 블록 및 페이지의 튜플에서 논리 블록의 배열로 매핑된다.
    - **논리 블록 주소(LBA)** 를 사용하기가 더 쉽다.

</br>

> **현실적으로는 세 가지 이유로 이 변환을 수행하는 것이 어렵다!**
> 
1. 대부분의 드라이브에는 결함이 있는 섹터가 있지만, 매핑은 드라이브의 다른 곳에 있는 예비 섹터로 대체하여 이를 숨긴다.
2. 트랙당 섹터 수는 일부 드라이브에서 일정하지 않다.
3. 디스크 제조업체는 LBA와 물리 주소 간의 매핑을 내부적으로 관리하므로, 현재 드라이브에서는 LBA와 물리적 섹터 간에 관계가 거의 없다.

</br>

> **두 번째 이유를 좀 더 살펴보면, 고정 선형 속도(CLV)를 사용하는 장치에서는 트랙당 비트의 밀도가 일정하다.**
> 
- 트랙이 디스크의 중심으로부터 멀어질수록 트랙은 더 길이가 길어져 더 많은 섹터를 가질 수 있게 된다.
    - 따라서, 현대의 디스크는 실린더들을 몇 개의 구역으로 나눈다.
    - 드라이브는 헤드가 바깥쪽에서 안쪽 트랙으로 이동하면서 헤드 아래를 통과하는 데이터의 비율을 동일하게 유지하기 위해 회전 속도를 늘린다.

</br>

→ 이의 대안으로, **디스크의 회전 속도를 일정하게 유지하고, 이 경우 안쪽 트랙에서 바깥쪽 트랙으로 갈수록 비트의 밀도를 줄여 데이터 비율을 일정하게 유지할 수 있다.**

- 이 방법은 하드 디스크에 사용되며, **고정 각 속도(CAV)** 로 알려져 있다.

---

## 2. 디스크 스케줄링

→ ***운영체제의 책임 중 하나는 효율적인 하드웨어 사용이다.***

- HDD 또는 플래터를 사용하는 기계식 저장장치의  경우, 접근 시간은 두 가지 요소로 이루어진다.
    - **탐색 시간** : 장치 암이 헤드를 해당 실린더로 움직이는 데 걸리는 시간
    - **회원 지연 시간** : 플래터가 원하는 섹터를 헤드 위치까지 회전시키는 데 소요되는 추가적인 시간
    - **장치 대역폭** : 전송된 총 바이트 수를 첫 번째 서비스 요청과 마지막 전송 완료 사이의 전체 시간으로 나눈 값

</br>

> **프로세스가 입출력을 해야 할 때마다 운영체제에 시스템 콜을 한다.**
> 
- 이 호출에는 여러 가지의 인수가 주어진다.
    - 이 작업이 입력 또는 출력인지의 여부
    - 연산이 수행될 파일을 가리키는 열린 파일 핸들
    - 전송을 위한 메모리 주소
    - 전송할 데이터의 양

</br>

> **원하는 드라이브와 컨트롤러가 쉬고 있다면, 이 요청은 즉시 시작된다.**
> 
- 그러나 드라이브나 컨트롤러가 바쁘면, 이 요청은 드라이브의 큐에 들어가 기다려야 한다.
    - 이 큐에는 여러 장치 I/O 요청들이 함께 대기하고 있을 수 있다.

</br>

→ **헤드 탐색을 피하면 성능을 최적화할 수 있는 장치에 대해 요청 큐를 유지하면, 장치 드라이버는 큐의 순서를 조정하여 성능을 향상할 수 있는 기회를 가지게 된다.**

</br>

### 선입 선처리 스케줄링

→ ***디스크 스케줄링의 가잔 간단한 형태는 선입 선처리(FCFS)이다.***

- 공평해 보이지만, 빠른 서비스를 제공하지는 못한다.

<img width="430" alt="image" src="https://user-images.githubusercontent.com/106216912/222914028-d3413c3e-1ca3-4201-8644-be48092c018d.png">

</br>

### SCAN 스케줄링

→ ***SCAN 알고리즘에서는 디스크 암이 디스크의 한쪽에서 시작하여 다른 끝으로 이동하며, 가는 길에 있는 요청을 모두 처리한다.***

- **다른 한쪽 끝에 도달하면 역방향으로 이동하면서 오는 길에 있는 요청을 모두 처리한다.**
    - 따라서, 헤드는 디스크 양쪽을 계속해서 가로지르며 왕복한다.
    - **엘리베이터 알고리즘**이라고도 부른다.

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/222914051-7451302e-e431-4f31-85ba-1429d35f18fd.png">

</br>

### C-SCAN 스케줄링

→ ***C-SCAN 스케줄링은 각 요청에 걸리는 시간을 좀 더 균등하게 하기 위한 SCAN의 변형이다.***

- 한 쪽으로 헤드를 이동해 가면서 요청을 처리하지만, 한쪽 끝에 다다르면 처음에 시작했던 자리로 돌어가서 서비스를 시작한다.

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/222914085-e94526a4-d678-4745-9edc-6ad041576220.png">

</br>

### 디스크 스케줄링 알고리즘의 선택

→ ***SCAN 및 C-SCAN은 기아 문제를 일으킬 가능성이 작기 때문에 디스크에 많은 부하를 주는 시스템의 성능을 향상한다.***

- 그래도 기아가 계속될 수 있으며, 이로 인해 Linux가 **마감시간 스케줄러**를 만들었다.
    - 이 스케줄러는 읽기와 쓰기별로 큐를 유지 관리하며, 읽기 연산에 높은 우선순위를 준다.
    - 대기열은 LBA 순서로 정렬되어 기본적으로 C-SCAN을 구현하고, 모든 I/O 요청은 이 LBA 순서로 묶어서 전송된다.

</br>

> **RHEL 7에는 다른 두 가지가 포함되어 있다.**
> 
- **NOOP**은 NVM 장치와 같은 빠른 저장장치를 사용하는 CPU 중심 시스템에 선호된다.
    - **CFQ 스케줄러**는 SATA 드라이브의 디폴트 스케줄러이다.
    - CFQ는 실시간, 최선 노력 및 유휴의 세 가지 큐를 유지한다.

---

## 3. NVM 스케줄링

→ ***NVM 장치에는 이동 디스크 헤드가 없으며, 일반적으로 간단한 FCFS 정책을 사용한다.***

- ex) Linux NOOP 스케줄러는 FCFS 정책을 사용하지만, 인접한 요청을 병합하도록 수정한다.

</br>

> **I/O는 순차적으로 또는 무작위로 발생할 수 있다.**
> 
- 읽거나 쓸 데이터가 읽기/쓰기 헤드 근처에 있기 때문에 HDD 및 테이프와 같은 기계 장치에는 순차적 액세스가 최적이다.
    - 초당 입/출력 연산 수(IOPS)로 측정되는 무작위 액세스 I/O는 HDD 디스크 헤드 이동을 유발한다.

</br>

> **HDD 헤드 탐색을 최소화하고 미디어에 대한 데이터 읽기 및 쓰기가 강조되는 `raw` 순차 처리량 측면에서는, NVM이 더 적은 이득을 제공한다.**
> 
- 이러면 읽기의 경우, 두 가지 유형의 장치 성능은 동등하거나 NVM이 10배 정도 이득을 얻는다.
    - NVM에 쓰는 것이 읽는 것보다 느리므로 이러한 이득은 줄어든다.

</br>

→ 시간이 지남에 따라 NVM 장치의 수명과 성능을 향상하는 한 가지 방법?

- **파일이 삭제될 때 파일 시스템이 장치에 알리도록 하여, 장치가 해당 파일이 저장된 블록을 지울 수 있도록 하는 것**

</br>

> **가비지 수집이 성능에 미치는 영향**
> 
- **하나의 쓰기 요청으로 인해 결국 페이지 쓰기, 하나 이상의 페이지 읽기 및 하나 이상의 페이지 쓰기가 발생한다.**
    - 응용 프로그램이 아니라 가비지 수집 및 공간 관리를 수행하는 NVM 장치에 의한 I/O 요청 생성을 **쓰기 증폭**이라고 한다.
        - 장치의 쓰기 성능이 큰 영향을 준다!

---