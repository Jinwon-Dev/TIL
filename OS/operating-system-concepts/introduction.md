
> **운영체제란**? <br>
→ 컴퓨터 하드웨어를 관리하는 소프트웨어이다. <br>
→ 응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. <br>
→ CPU, 메모리 및 입출력 장치와 저장장치를 프로그램에 할당한다.

<br>

- 운영체제는 **광범위한(사물 인터넷, 자동차, 스마트폰, 컴퓨터 등) 컴퓨팅 환경에서 여러 일들을 다양한 방법으로 수행**한다.

---

## 1. 운영체제가 할 일

→ ***컴퓨터 시스템은 하드웨어, 운영체제, 응용 프로그램, 사용자로 구분할 수 있다.***

<img width="400" alt="image" src="https://user-images.githubusercontent.com/106216912/209369001-0c7333ac-30a5-44d0-888e-67e0f7365ef4.png">

- **하드웨어** : 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치
- **응용 프로그램** : 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등

→ 운영체제는 다양한 사용자를 위해, <u>**다양한 응용 프로그램 간의 하드웨어 사용을 제어 및 조정**</u>한다.

<br>

> **운영체제의 역할을 사용자와 시스템 두 관점에서 살펴보자.** 

### 사용자 관점

→ ***컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.***

- 대부분의 사용자는 랩톱, 모니터, 키보드, 마우스로 구성된 PC 앞에서 작업한다.
    - 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었고, 목표는 사용자가 수행하는 작업을 최대화 하는 것이다.
    
    → 운영체제는 대부분 **사용의 용이성을 위해 설계**되고, 하드웨어와 소프트웨어 자원이 어떻게 공유되는지의 **자원의 이용에는 신경을 쓰지 않는다.**

<br> 

### 시스템 관점

→ ***시스템의 관점에서는 운영체제는 하드웨어와 밀접하게 연관된 프로그램이다.***

- **자원 할당자**
    - 컴퓨터 시스템은 여러 가지 자원들(하드웨어 & 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간, 입출력 장치 등을 가진다.
    - 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 **어느 요청에 자원을 할당할 지 결정**해야 한다.

<br>

- **제어 프로그램**
    - 컴퓨터의 부적절한 사용을 방지하기 위해 **사용자 프로그램의 실행을 제어**한다.
        - 특히, 입출력 장치의 제어와 작동에 깊이 관여한다.

<br>

### 운영체제의 정의

→ ***운영체제에 대한 적합한 정의는 없다.***

- 운영체제는 <u>**유용한 컴퓨터 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 위해**</u> 존재한다.
- 응용 프로그램에는 입출력 장치 제어와 같은 공통적인 작업과 자원을 제어하고 할당하는 일반적인 기능이 필요하다.
    - 이 기능들을 **운영체제라는 하나의 소프트웨어로 통합**한 것이다.

<br>

- **운영체제는 컴퓨터에서 항상 실행되는 프로그램(커널)이다.**
- 커널과 다른 두 가지 유형의 프로그램이 존재한다.
    - **시스템 프로그램** : 운영체제와 관련되어 있지만, 반드시 커널의 일부일 필요는 없는 프로그램으로 시스템 관리에 도움을 준다.
    - 응용 프로그램 : 시스템 작동과 관련되지 않은 모든 프로그램을 포함한다.

<br>

- 모바일 기기의 운영체제 를 보면 운영체제를 구성하는 기능의 수가 증가하고 있다.
    - 핵심 커널 이외에 **미들웨어**도 포함된다.

<br>

> **요약 → 운영체제에는 커널, 미들웨어 프레임워크, 시스템 프로그램이 포함된다.** 

---

## 2. 컴퓨터 시스템의 구성

→ ***컴퓨터 시스템은 하나 이상의 CPU, 구성요소와 공유 메모리 사이의 액세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성된다.***

<img width="481" alt="image" src="https://user-images.githubusercontent.com/106216912/209372583-e6bf39b7-0e0e-4b9a-b3a7-2024089cd0b0.png">

- 일반적으로 운영체제에는 각 장치 컨트롤러마다 **장치 드라이버**가 있다.
    - 장치 드라이버는 운영체제에 <u>**장치에 대한 일관된 인터페이스를 제공**</u>한다.
        - CPU ↔?장치 컨트롤러 : 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
        - 메모리 컨트롤러 : 메모리에 대한 액세스를 동기화시켜 공유 메모리를 질서 있게 액세스시킨다.

</br>

### 인터럽트

→ ***장치 컨트롤러는 작업이 완료되면 장치 드라이버에게 작업이 완료되었음을 알린다.***

- 하지만 컨트롤러는 장치 드라이버에게 작업이 완료했다는 것을 어떻게 알릴까?
    
    → **인터럽트!**
    
</br>

- 하드웨어는 <u>**시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.**</u>
    - **인터럽트는 운영체제와 하드웨어의 상호 작용 방식의 핵심**이다.
    - 인터럽트가 발생되면, CPU는 하던 일을 중단하고 고정된 위치로 실행을 옮기고, **인터럽트 서비스 루틴**이 실행된다.
        - 고정된 위치 : 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소
    - 그 후, **인터럽트 서비스 루틴의 실행이 완료되면 다시 연산을 재개**한다.

</br>

- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.
    - 이 전달을 관리하는 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다.
    - 하지만 <u>**인터럽트는 매우 빈번히 발생되고 빠르게 처리되어야 한다.**</u>
        - 따라서, **인터럽트 루틴에 대한 포인터들의 테이블**을 대신 이용할 수 있다.
        - 이 테이블에는 **인터럽트 서비스 루틴의 주소**가 들어 있다.
    - 인터럽트가 요청되면 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인되어 주소를 얻을 수 있다.

</br>

- 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
    - 인터럽트 루틴이 처리기의 상태를 변경한다면, <u>**반드시 현재의 상태를 저장하고, 복귀하기 전에 상태를 복원**</u>해야 한다.
    - 그 후, 복귀 주소를 프로그램 카운터에 적재하고 중단되었던 연산이 다시 시작된다.

</br>

<img width="475" alt="image" src="https://user-images.githubusercontent.com/106216912/209372909-f75b065d-bed5-4a3b-a65f-e760a4251b58.png">

1. 하나의 명령어의 실행을 완료할 때마다 CPU가 인터럽트 요청 라인을 감지한다.
2. 그 후, 인터럽트 번호를 읽고 번호를 인터럽트 벡터의 인덱스로 사용하여, 인터럽트 핸들러 루틴으로 점프한다.
3. 그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다.
4. 인터럽트 처리기는 변경될 상태 저장, 인터럽트 원인 확인, 필요한 처리 수행, 상태 복원 등의 작업을 수행하고 CPU를 인터럽트 전 실행 상태로 되돌린다.

→ **장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생(raise)시키고 CPU는 인터럽트가 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch)하고, 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear).**

</br>

> **최신 운영체제에서는 정교한 인터럽트 처리 기능이 필요하다.**
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

</br>

> **인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다.**
- 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
- 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 **인터럽트 우선순위 시스템**을 사용한다.

→ **인터럽트는 빈번하게 사용되므로 효율적인 인터럽트 처리가 필요하다!**

</br>

### 저장장치 구조

→ ***CPU는 메모리에서만 명령을 적재할 수 있으므로, 실행을 위해서는 프로그램을 메모리에 먼저 적재해야 한다.***

- 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM = 휘발성)라 불리는 재기록 가능한 메모리**에서 가져온다.

</br>

- 모든 형태의 <u>**메모리는 바이트의 배열을 제공하고, 각 바이트는 자신의 주소를 가지고 있다.**</u>
    - 상호 작용은 특정 메모리 주소들에 대한 일련의 **적재(load), 또는 저장(store) 명령**을 통해 이루어진다.
    - **적재** : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것
    - **저장** : 레지스터의 내용을 메인 메모리로 옮기는 것

</br>

> **이상적으로는 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.**

→ 그러나 대부분의 시스템에서 두 가지 이유로 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 **영구히 저장하기에는 너무 작다.**
2. 메인 메모리는 전원이 공급되지 않으면 그 **내용을 잃어버리는 휘발성 장치**이다.

</br>

- 따라서 메인 메모리의 확장으로 **보조 저장 장치**를 제공한다.
    - 보조 저장 장치는 <u>**대량의 데이터를 영구히 보존**</u>할 수 있어야 한다.
        - **하드 디스크 드라이브(HDD)**
        - **비휘발성 메모리(NVM) 장치**
    - 프로그램과 데이터 모두를 위한 저장소를 제공하며, 대부분의 프로그램은 메모리에 적재될 때까지 보조 저장 장치에 저장된다.
        - 보조 저장 장치는 메인 메모리 보다 **훨씬 느리다.**

</br>

- **3차 저장장치** : 백업 사본을 저장하기 위해 특수 목적으로만 사용되는 매우 느리고 큰 장치

</br>

> **다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다.**

<img width="564" alt="image" src="https://user-images.githubusercontent.com/106216912/209373152-d16d9867-7ec9-423b-bed0-b400f7a446d2.png">

- 속도와 용량의 차이도 있지만, **휘발성 또는 비휘발성**이라는 차이도 존재한다.
- 기계적 저장장치(HDD)는 전기적 저장장치(SSD)보다 용량이 크고, 비용이 저렴하다.
    - 전기적 저장장치는 반대로 비싸고, 용량이 적으며 빠르다.

→ **가능한 한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에, 필요한 만큼의 비싼 메모리를 사용해야 한다.**

</br>

### 입출력 구조

→ ***시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터이다.***

- 인터럽트 구동 형태의 입출력은 **소량의 데이터를 이동하는 데는 좋지만**, **대량 데이터 이동에는 높은 오버헤드를 유발**할 수 있다.
    - 따라서, <u>**직접 메모리 액세스**</u>가 사용된다.

</br>

> **직접 메모리 액세스**

→ ***장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후, 장치 제어기는 CPU의 개입 없이 데이터 블록 전체를 전송한다.***

<img width="369" alt="image" src="https://user-images.githubusercontent.com/106216912/209373279-db3d2468-aaa1-4219-9dbe-ea5ace841a20.png">

- 한 바이트마다 인터럽트가 발생하는 것이 아니라, **블록 전송이 완료될 때마다 인터럽트가 발생**한다.
    - 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.
