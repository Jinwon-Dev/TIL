
> **운영체제란**? <br>
→ 컴퓨터 하드웨어를 관리하는 소프트웨어이다. <br>
→ 응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. <br>
→ CPU, 메모리 및 입출력 장치와 저장장치를 프로그램에 할당한다.

<br>

- 운영체제는 **광범위한(사물 인터넷, 자동차, 스마트폰, 컴퓨터 등) 컴퓨팅 환경에서 여러 일들을 다양한 방법으로 수행**한다.

---

## 1. 운영체제가 할 일

→ ***컴퓨터 시스템은 하드웨어, 운영체제, 응용 프로그램, 사용자로 구분할 수 있다.***

<img width="400" alt="image" src="https://user-images.githubusercontent.com/106216912/209369001-0c7333ac-30a5-44d0-888e-67e0f7365ef4.png">

- **하드웨어** : 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치
- **응용 프로그램** : 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등

→ 운영체제는 다양한 사용자를 위해, <u>**다양한 응용 프로그램 간의 하드웨어 사용을 제어 및 조정**</u>한다.

<br>

> **운영체제의 역할을 사용자와 시스템 두 관점에서 살펴보자.** 

### 사용자 관점

→ ***컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.***

- 대부분의 사용자는 랩톱, 모니터, 키보드, 마우스로 구성된 PC 앞에서 작업한다.
    - 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었고, 목표는 사용자가 수행하는 작업을 최대화 하는 것이다.
    
    → 운영체제는 대부분 **사용의 용이성을 위해 설계**되고, 하드웨어와 소프트웨어 자원이 어떻게 공유되는지의 **자원의 이용에는 신경을 쓰지 않는다.**

<br> 

### 시스템 관점

→ ***시스템의 관점에서는 운영체제는 하드웨어와 밀접하게 연관된 프로그램이다.***

- **자원 할당자**
    - 컴퓨터 시스템은 여러 가지 자원들(하드웨어 & 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간, 입출력 장치 등을 가진다.
    - 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 **어느 요청에 자원을 할당할 지 결정**해야 한다.

<br>

- **제어 프로그램**
    - 컴퓨터의 부적절한 사용을 방지하기 위해 **사용자 프로그램의 실행을 제어**한다.
        - 특히, 입출력 장치의 제어와 작동에 깊이 관여한다.

<br>

### 운영체제의 정의

→ ***운영체제에 대한 적합한 정의는 없다.***

- 운영체제는 <u>**유용한 컴퓨터 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 위해**</u> 존재한다.
- 응용 프로그램에는 입출력 장치 제어와 같은 공통적인 작업과 자원을 제어하고 할당하는 일반적인 기능이 필요하다.
    - 이 기능들을 **운영체제라는 하나의 소프트웨어로 통합**한 것이다.

<br>

- **운영체제는 컴퓨터에서 항상 실행되는 프로그램(커널)이다.**
- 커널과 다른 두 가지 유형의 프로그램이 존재한다.
    - **시스템 프로그램** : 운영체제와 관련되어 있지만, 반드시 커널의 일부일 필요는 없는 프로그램으로 시스템 관리에 도움을 준다.
    - 응용 프로그램 : 시스템 작동과 관련되지 않은 모든 프로그램을 포함한다.

<br>

- 모바일 기기의 운영체제 를 보면 운영체제를 구성하는 기능의 수가 증가하고 있다.
    - 핵심 커널 이외에 **미들웨어**도 포함된다.

<br>

> **요약 → 운영체제에는 커널, 미들웨어 프레임워크, 시스템 프로그램이 포함된다.** 

---

## 2. 컴퓨터 시스템의 구성

→ ***컴퓨터 시스템은 하나 이상의 CPU, 구성요소와 공유 메모리 사이의 액세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성된다.***

<img width="481" alt="image" src="https://user-images.githubusercontent.com/106216912/209372583-e6bf39b7-0e0e-4b9a-b3a7-2024089cd0b0.png">

- 일반적으로 운영체제에는 각 장치 컨트롤러마다 **장치 드라이버**가 있다.
    - 장치 드라이버는 운영체제에 <u>**장치에 대한 일관된 인터페이스를 제공**</u>한다.
        - CPU ↔?장치 컨트롤러 : 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
        - 메모리 컨트롤러 : 메모리에 대한 액세스를 동기화시켜 공유 메모리를 질서 있게 액세스시킨다.

</br>

### 인터럽트

→ ***장치 컨트롤러는 작업이 완료되면 장치 드라이버에게 작업이 완료되었음을 알린다.***

- 하지만 컨트롤러는 장치 드라이버에게 작업이 완료했다는 것을 어떻게 알릴까?
    
    → **인터럽트!**
    
</br>

- 하드웨어는 <u>**시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.**</u>
    - **인터럽트는 운영체제와 하드웨어의 상호 작용 방식의 핵심**이다.
    - 인터럽트가 발생되면, CPU는 하던 일을 중단하고 고정된 위치로 실행을 옮기고, **인터럽트 서비스 루틴**이 실행된다.
        - 고정된 위치 : 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소
    - 그 후, **인터럽트 서비스 루틴의 실행이 완료되면 다시 연산을 재개**한다.

</br>

- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.
    - 이 전달을 관리하는 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다.
    - 하지만 <u>**인터럽트는 매우 빈번히 발생되고 빠르게 처리되어야 한다.**</u>
        - 따라서, **인터럽트 루틴에 대한 포인터들의 테이블**을 대신 이용할 수 있다.
        - 이 테이블에는 **인터럽트 서비스 루틴의 주소**가 들어 있다.
    - 인터럽트가 요청되면 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인되어 주소를 얻을 수 있다.

</br>

- 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
    - 인터럽트 루틴이 처리기의 상태를 변경한다면, <u>**반드시 현재의 상태를 저장하고, 복귀하기 전에 상태를 복원**</u>해야 한다.
    - 그 후, 복귀 주소를 프로그램 카운터에 적재하고 중단되었던 연산이 다시 시작된다.

</br>

<img width="475" alt="image" src="https://user-images.githubusercontent.com/106216912/209372909-f75b065d-bed5-4a3b-a65f-e760a4251b58.png">

1. 하나의 명령어의 실행을 완료할 때마다 CPU가 인터럽트 요청 라인을 감지한다.
2. 그 후, 인터럽트 번호를 읽고 번호를 인터럽트 벡터의 인덱스로 사용하여, 인터럽트 핸들러 루틴으로 점프한다.
3. 그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다.
4. 인터럽트 처리기는 변경될 상태 저장, 인터럽트 원인 확인, 필요한 처리 수행, 상태 복원 등의 작업을 수행하고 CPU를 인터럽트 전 실행 상태로 되돌린다.

→ **장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생(raise)시키고 CPU는 인터럽트가 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch)하고, 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear).**

</br>

> **최신 운영체제에서는 정교한 인터럽트 처리 기능이 필요하다.**
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

</br>

> **인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다.**
- 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
- 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 **인터럽트 우선순위 시스템**을 사용한다.

→ **인터럽트는 빈번하게 사용되므로 효율적인 인터럽트 처리가 필요하다!**

</br>

### 저장장치 구조

→ ***CPU는 메모리에서만 명령을 적재할 수 있으므로, 실행을 위해서는 프로그램을 메모리에 먼저 적재해야 한다.***

- 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM = 휘발성)라 불리는 재기록 가능한 메모리**에서 가져온다.

</br>

- 모든 형태의 <u>**메모리는 바이트의 배열을 제공하고, 각 바이트는 자신의 주소를 가지고 있다.**</u>
    - 상호 작용은 특정 메모리 주소들에 대한 일련의 **적재(load), 또는 저장(store) 명령**을 통해 이루어진다.
    - **적재** : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것
    - **저장** : 레지스터의 내용을 메인 메모리로 옮기는 것

</br>

> **이상적으로는 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.**

→ 그러나 대부분의 시스템에서 두 가지 이유로 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 **영구히 저장하기에는 너무 작다.**
2. 메인 메모리는 전원이 공급되지 않으면 그 **내용을 잃어버리는 휘발성 장치**이다.

</br>

- 따라서 메인 메모리의 확장으로 **보조 저장 장치**를 제공한다.
    - 보조 저장 장치는 <u>**대량의 데이터를 영구히 보존**</u>할 수 있어야 한다.
        - **하드 디스크 드라이브(HDD)**
        - **비휘발성 메모리(NVM) 장치**
    - 프로그램과 데이터 모두를 위한 저장소를 제공하며, 대부분의 프로그램은 메모리에 적재될 때까지 보조 저장 장치에 저장된다.
        - 보조 저장 장치는 메인 메모리 보다 **훨씬 느리다.**

</br>

- **3차 저장장치** : 백업 사본을 저장하기 위해 특수 목적으로만 사용되는 매우 느리고 큰 장치

</br>

> **다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다.**

<img width="564" alt="image" src="https://user-images.githubusercontent.com/106216912/209373152-d16d9867-7ec9-423b-bed0-b400f7a446d2.png">

- 속도와 용량의 차이도 있지만, **휘발성 또는 비휘발성**이라는 차이도 존재한다.
- 기계적 저장장치(HDD)는 전기적 저장장치(SSD)보다 용량이 크고, 비용이 저렴하다.
    - 전기적 저장장치는 반대로 비싸고, 용량이 적으며 빠르다.

→ **가능한 한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에, 필요한 만큼의 비싼 메모리를 사용해야 한다.**

</br>

### 입출력 구조

→ ***시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터이다.***

- 인터럽트 구동 형태의 입출력은 **소량의 데이터를 이동하는 데는 좋지만**, **대량 데이터 이동에는 높은 오버헤드를 유발**할 수 있다.
    - 따라서, <u>**직접 메모리 액세스**</u>가 사용된다.

</br>

> **직접 메모리 액세스**

→ ***장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후, 장치 제어기는 CPU의 개입 없이 데이터 블록 전체를 전송한다.***

<img width="369" alt="image" src="https://user-images.githubusercontent.com/106216912/209373279-db3d2468-aaa1-4219-9dbe-ea5ace841a20.png">

- 한 바이트마다 인터럽트가 발생하는 것이 아니라, **블록 전송이 완료될 때마다 인터럽트가 발생**한다.
    - 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.

---

## 3. 컴퓨터 시스템 구조

→ ***컴퓨터 시스템은 사용된 범용 처리기의 수에 따라 다양한 방식으로 구성된다!***

</br>

### 단일 처리기 시스템(Single-Processor Systems)

→ ***코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소이다.***

- 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다.
- 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고, 처리기들의 상태를 감시한다.

</br>

- 다른 시스템 또는 환경에서는 전용 처리기가 하드웨어로 구현되는 저수준의 구성요소이다.
    - 운영체제는 이 처리기들과 통신할 수 없으며, 처리기들은 독립적으로 자신의 작업을 처리한다.

</br>

> **단일 프로세서(처리기) 시스템은 단일 처리 코어를 가진 범용 CPU가 하나만 있는 시스템이다.**

</br>

### 다중 처리기 시스템(Multiprocessor Systems)

→ ***모바일 장치에서 서버에 이르기까지 최신 컴퓨터에는 다중 처리기 시스템이 컴퓨팅 환경을 지배하고 있다.***

- 다중 처리기 시스템에는 각각 **단일 코어 CPU가 있는 두 개 이상의 프로세서**가 있다.
    - 프로세서는 컴퓨터 버스, 클록, 메모리 및 주변 장치를 공유한다.
- 다중 처리기 시스템의 장점은 **처리량 증가**이다.
    - 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있다.
        - 하지만 **프로세서 개수가 N개가 된다고 해서 속도 향상도 N배가 되는 것은 아니다.**
        - 여러 프로세서가 하나의 작업을 협력할 때, **일정한 양의 오버헤드가 발생하기 때문**이다.

</br>

> **대칭적 다중 처리(SMP)**

![image](https://user-images.githubusercontent.com/106216912/209477767-b94abf26-38cb-4187-bb9e-6833669677c9.png)


- 가장 일반적인 다중 처리기 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는 **대칭적 다중 처리 - SMP**를 사용한다.
- 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라, 자체 레지스터 세트를 갖고 있다.
    - 하지만 **모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유**한다.

</br>

- 이 모델의 장점은 **많은 프로세스를 동시에 실행할 수 있다는 것이다!**
    - 프로세스 및 메모리와 같은 자원을 동적으로 공유하여 프로세서 간의 작업 부하를 낮출 수 있다.
    - 하지만 **CPU가 독립적이기 때문에 하나는 쉬고 있고, 다른 하나는 과부하가 걸려 비효율적일 수 있다.**

</br>

> **다중 코어 시스템**

![image](https://user-images.githubusercontent.com/106216912/209477810-ced7b8bd-1f2a-4c73-98cb-3781ab80ac87.png)

- 다중 코어 시스템은 **여러 개의 컴퓨팅 코어가 단일 칩에 존재**한다.
    - 칩 내에서의 통신이 칩 사이의 통신보다 빠르므로, **다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적일 수 있다!**
    - 또한, **다중 코어 시스템은 여러 개의 단일 코어 칩을 사용하는 것보다 훨씬 적은 전력을 사용**한다.

</br>

→ **다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상 되지만, 너무 많이 추가하면 오히려 시스템 버스에 대한 경합이 병목 현상이 되어 성능이 저하된다!**

</br>

> **NUMA(불균일 기억 장치 접근)**

![image](https://user-images.githubusercontent.com/106216912/209477848-0e0aa843-6f45-41a4-a133-7a0f900f5949.png)


- 각 CPU에 작고 빠른 로컬 버스를 통해 액세스 되는 **자체 로컬 메모리를 제공**한다.
    - 모든 CPU가 **공유 시스템 연결로 연결되어, 하나의 물리 주소 공간을 공유**한다.

</br>

- **이 모델의 장점은?**
    - CPU가 **로컬 메모리에 액세스 할 때 빠를 뿐만 아니라, 시스템 상호 연결에 대한 경합도 존재하지 않는다.**
        - 따라서 **더 많은 프로세서가 추가될수록 더 효과적으로 확장 가능하다!**

</br>

- **이 모델의 단점은?**
    - CPU가 시스템 상호 연결을 통해 **원격 메모리에 액세스할 때, 지연 시간이 증가하여 성능 저하가 발생할 수 있다.**
        - ex) CPU0은 자체 로컬 메모리에는 빠르게 액세스 가능하지만, CPU3의 로컬 메모리에는 그만큼 빨리 액세스 할 수 없다.

</br>

### 클러스터형 시스템(Clustered Systems)

→ ***여러 CPU를 가진 시스템의 또 다른 유형이다.***

- 다중 처리기 시스템과 같이 여러 개의 CPU를 갖고 있지만, **둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점**이 다르다.

</br>

- 클러스터링은 통상 **높은 가용성을 제공하기 위해 사용**된다.
    - 즉, **클러스터 내 하나 이상의 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공**된다.
    - 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다.

</br>

> **어떻게 한 시스템이 고장나도 서비스를 계속 제공할 수 있을까?**
- 각 노드는 하나 이상의 다른 노드들을 감시한다.
- 만약 감시를 받던 노드가 고장나면, **감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받는다.**
    - 그 후, **그 노드에서 실행 중이던 응용 프로그램을 다시 시작**한다.

→ 결국 **사용자와 클라이언트는 잠깐의 서비스 중단만을 경험**한다.

</br>

> **우아한 성능 저하 : 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능 </br>
 결함허용 시스템 : 정상적인 성능 저하가 아닌 단일 구성요소에 오류가 발생해도 계속 작동할 수 있는 시스템**

</br>

> **클러스터링은 비대칭적으로 또는 대칭적으로 구성될 수 있다.**
- **비대칭형 클러스터링**
    - 다른 컴퓨터들이 응용 프로그램을 실행하는 동안, **한 컴퓨터는 긴급 대기 모드 상태를 유지**한다.
        - 활성 서버들을 **감시하다가, 서버가 고장 난다면 긴급 대기 모드의 호스트가 활성 서버가 된다.**

</br>

- **대칭형 클러스터링**
    - **둘 이상의 호스트들이 응용 프로그램을 실행하고, 서로를 감시**한다.
    - 가용한 하드웨어를 모두 사용하기 때문에 **비대칭형 클러스터링보다 효율적**이다.

</br>

> **클러스터는 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 고성능 계산환경을 제공하도록 사용될 수 있다.**
> 
- 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로, **단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공**할 수 있다.
    - 하지만 **병렬화**로 응용이 클러스터를 이용할 수 있도록 작성되어야 한다.

![image](https://user-images.githubusercontent.com/106216912/209477971-3ff65357-4e0e-43b3-8e16-9055b51fc56e.png)

</br>

> **다른 형태의 클러스터로 병렬 클러스터와 WAN을 이용한 클러스터링이 존재한다.**
- **병렬 클러스터**
    - **여러 호스트가 공유 저장장치상의 동일한 데이터에 접근**할 수 있게 한다.
    - 시스템은 **접근 간의 충돌이 발생하지 않는 것을 보장하기 위해 접근 제어와 잠금 기법**을 제공해야 한다.
    - **대부분의 운영체제가 이러한 동시 접근을 지원하지 않으므로**, 특수한 소프트웨어나 특별 발매 버전에만 적용된다.

---

## 4. 운영체제의 작동

→ ***운영체제는 프로그램이 실행되는 환경을 제공한다.***

- 내부적으로 운영체제는 여러 경로를 거쳐 구성되기 때문에 큰 차이가 있지만, 많은 공통점 또한 존재한다.

</br>

- 초기 프로그램 또는 **부트스트랩 프로그램**을 실행 함으로써, 컴퓨터를 실행시킬 수 있다.
    - 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다.
    - 시스템의 모든 측면을 **초기화** 한다.
    - 부트스트랩 프로그램은 **운영체제를 적재하는 방법과 해당 시스템 실행을 시작**할 수 있어야 한다.
        
        → **부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재**해야 한다.

</br>

- 커널이 적재되고 실행되면, 시스템과 사용자에게 서비스를 제공할 수 있다.
    - 일부 서비스는 시스템 데몬이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.
    
    → 이 단계가 완료되면 **시스템이 완전히 부팅되고, 시스템은 어떤 이벤트가 발생할 때까지 기다린다.**

</br>    

- 실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없다면 **운영체제는 무언가가 발생할 때까지 기다린다.**
    - 이벤트는 **인터럽트**를 발생시켜서 신호를 보낸다.
    - **트랩(예외), 오류 또는 사용자 프로그램의 특정 요청으로 발생하는 인터럽트**도 있다.
        - 이 특정 요청은 **시스템 콜**이라는 특수 연산을 실행해서 요청된다.

</br>

### 다중 프로그래밍과 다중 태스킹(Multiprogramming and Multitasking)

→ ***운영체제의 가장 중요한 측면은 여러 프로그램을 실행할 수 있다는 것이다.***

</br>

> **다중 프로그래밍은 CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여, CPU 이용률을 높이고 사용자 만족도를 높인다.**
- 다중 프로그램 시스템에서 실행 중인 프로그램을 **프로세스**라고 한다.

</br>

![image](https://user-images.githubusercontent.com/106216912/209478035-d3fc9cab-c350-4b0e-b11d-2ac021c819fc.png)

- 운영체제는 **여러 프로세스를 동시에 메모리에 유지**한다.
    - 그 후, 프로세스 중 하나를 선택하여 실행한다.
- 다중 프로그래밍 되지 않은 시스템에서는 CPU가 쉬고 있을 수도 있다.
    - 다중 프로그램 시스템에서는 **운영체제가 단순히 다른 프로세스로 전환하여 실행**한다.
    - 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다.

</br>

> **다중 태스킹은 다중 프로그래밍의 논리적 확장이다.**
- 다중 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만, 전환이 자주 발생하기 때문에 **사용자 에게 빠른 응답 시간을 제공**한다.
    - 대화식 입출력은 사람의 속도로 수행되므로, 완료 시 까지 상당히 긴 시간이 걸릴 수 있다.
    - 대화식 입력이 진행되는 동안, CPU를 쉬게 하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.

</br>

- 동시에 여러 프로세스를 메모리에 유지하려면 **메모리 관리 방식**이 필요하다.
    - 또한 **시스템은 다음에 어떤 프로세스를 실행시킬 지 선택**해야 한다.
        - **CPU 스케줄링**

</br>

> **다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다.**
- 일반적인 방법은 **가상 메모리**로, **일부만 메모리에 적재된 프로세스의 실행을 허용하는 기법**이다.
    - 프로그램이 물리 메모리의 크기보다 커도 가능하다.
    - 사용자에게 보이는 논리 메모리를 물리 메모리로부터 분리시킨다.

</br>

→ 다중 프로그래밍 및 다중 태스킹 시스템도 **파일 시스템**을 제공해야 한다.

→ **저장장치 관리**가 제공되어야 한다.

→ 부적절한 사용으로부터 **자원을 보호**해야 한다.

→ **프로세스 동기화 및 통신을 위한 기법**을 제공해야 한다.

→ **교착 상태**에 빠지지 않도록 보장해야 한다.

</br>

### 이중-모드와 다중모드 운용

→ ***운영체제와 사용자는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 공유하기 때문에, 잘못된(악의적인) 프로그램으로 인해 다른 프로그램(운영체제)이 잘못 실행될 수 없도록 보장해야 한다.***

- 시스템을 올바르게 실행하려면, 운영체제 코드 실행과 사용자 정의 코드 실행을 구분할 수 있어야 한다.
    - 대부분의 컴퓨터 시스템이 취하는 접근 방식은 **다양한 실행 모드를 차별화 할 수 있는 하드웨어 지원을 제공**하는 것이다.

</br>

- 적어도 두 개의 독립된 연산 모드를 필요로 한다.
    - **사용자 모드**
    - **커널 모드**(시스템 모드, 특권 모드)

→ **모드 비트**를 이용해서 **운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구분**할 수 있다.

- **커널 모드(0)**
- **사용자 모드(1)**

</br>

![image](https://user-images.githubusercontent.com/106216912/209508719-6ef767c2-1b50-47f3-98da-7e775378aa71.png)


- 시스템은 사용자 모드에 있게 되지만, 사용자 응용이 운영체제로부터 서비스를 요청하면 **요청의 수행을 위해 사용자 모드에서 커널 모드로 전환**해야 한다.
    - 하드웨어는 커널 모드에서 시작하여, 운영체제 적재 후 **사용자 모드에서 사용자 프로세스가 시작**된다.
        - 그 후 **트랩이나 인터럽트가 발생할 때마다 사용자 모드에서 커널 모드로 전환**한다.

</br>

→ 즉, **운영체제가 컴퓨터의 제어를 얻을 때마다 항상 커널 모드에 있게 되고, 시스템은 사용자 프로그램으로 제어를 넘기기 전에 항상 사용자 모드로 전환**한다.

</br>

> **동작의 이중 모드는 잘못된 사용자로부터 운영체제를, 그리고 잘못된 사용자 서로를 보호할 수 있는 방법을 제공한다.**
- 악영향을 끼칠 수 있는 일부 명령을 **특권 명령 - privileged instruction**으로 지정함으로써 보호하고, 하드웨어는 특권 명령이 커널 모드에서만 수행되도록 허용한다.
    - 사용자 모드에서 특권 명령을 수행하려고 하면, **하드웨어는 이를 실행하지 않고 불법적인 명령으로 간주하여 운영체제로 트랩**을 건다.

</br>

> **모드의 개념은 두 가지 모드 이상으로 확장될 수 있다.**
- ex) Intel 프로세서에 있는 4개의 분리된 보호 링
- ex) ARMv8 시스템에 있는 7가지 모드
- 가상화를 지원하는 CPU는 종종 VMM(virtual machine manager)이 시스템을 제어하는 시점을 표시하기 위한 별도의 모드를 가진다.
    - 가상 머신을 생성 및 관리하려면 이 레벨의 권한이 필요하고, CPU 상태를 변경하여 해당 작업을 수행 가능하다.

</br>

> **시스템 콜은 사용자 프로그램이 자신을 대신하여 운영체제가 수행하도록 지정되어 있는 작업을 운영체제에 요청할 수 있는 방법을 제공한다.**
- 시스템 콜은 컴퓨터 시스템의 처리기가 지원하는 기능에 따라 다양한 방법으로 호출된다.
    - 시스템 콜은 **운영체제에 의해 수행될 동작을 사용자 프로세스가 요청할 수 있게** 하고, 일반적으로 인터럽트 백터의 특정 위치로 트랩을 거는 형태를 취한다.

</br>

> **하드웨어 보호 기능이 제공되면, 모드 규칙을 위반하는 오류가 하드웨어에 의해 탐지된다.**
1. 이러한 오류는 일반적으로 **운영체제가 처리**한다.
2. 사용자 프로그램이 불법적인 명령을 수행하려 하거나, 사용자 주소 공간이 아닌 메모리에 접근을 시도하는 등의 **오류가 발생하면, 하드웨어는 운영체제로 트랩을 발생**시킨다.
3. **트랩은 인터럽트처럼 인터럽트 벡터를 통해 제어를 운영체제에 넘긴다.**
4. 프로그램 오류가 발생할 때마다, **운영체제는 비정상적으로 프로그램을 종료**시킨다.

</br>

### 타이머

→ ***운영체제가 CPU에 대한 제어를 유지하도록 보장해야 한다.***
- **사용자 프로그램이 무한 루프에 빠지거나 시스템 서비스 호출에 실패하여, 제어가 운영체제로 복귀하지 않는 경우가 없도록 방지**해야 한다.

</br>

- **타이머**의 사용
    - 타이머는 **지정된 시간 후 컴퓨터를 인터럽트 하도록 설정**할 수 있다.
    - 가변 타이머를 사용하는데, 일반적으로 **고정률의 클록과 계수기**로 구현한다.
    - 사용자에게 제어를 양도하기 전에, 운영체제는 타이머가 인터럽트를 할 수 있도록 설정되어있는지 확인한다.
    - **타이머의 값을 변경하는 명령도 특권 명령**이다.

→ **타이머가 인터럽트를 발생시키면 제어는 운영체제에 넘어간다.**

---

## 5. 자원 관리

→ ***운영체제는 자원 관리자이다.***

- 시스템의 CPU, 메모리 공간, 파일-저장 공간 및 I/O 장치는 운영체제가 관리해야 하는 자원이다.

</br>

### 프로세스 관리

→ ***프로그램은 CPU에 의해 명령이 실행되지 않으면 아무것도 할 수 없다.***

- 실행 중인 프로그램 = **프로세스**
    - 컴파일러, 문서 편집 프로그램, 소셜 미디어 앱 등

</br>

- 프로세스는 자기 일을 수행하기 위해 **CPU 시간, 메모리, 파일, 입출력 장치를 포함한 여러 자원**이 필요하다.
    - 자원은 보통 실행되는 동안 할당되고, 프로세스가 종료되면 운영체제는 재사용 가능한 자원을 회수한다.

</br>
    
- 프로그램 자체 ≠ 프로세스
    - 하나의 프로그램은 파일의 내용과 같이 **수동적 개체**지만, 프로세스는 다음 수행할 명령을 지정하는 프로그램 카운터를 가진 **능동적인 개체**이다.

</br>

> **한 프로세스의 수행은 반드시 순차적이어야 한다.**
- **CPU는 그 프로세스가 끝날 때까지 그 프로세스를 위해 하나의 명령만 수행**된다.
    - 따라서, **두 개의 프로세스가 동일한 프로그램과 연관되어 있어도 각각 두 개의 별도의 수행 순서로 간주**된다.
- 다중 스레드 프로세스는 여러 개의 프로그램 카운터를 가지고 있으며, 이 카운터들은 각 스레드가 실행할 다음 명령어를 가리키게 된다.

</br>

> **한 프로세스는 한 시스템 내의 작업의 단위이다.**
- 프로세스 중 일부는 운영체제 프로세스들이고 나머지는 사용자 프로세스들이다.
    - 모든 프로세스는 단일 CPU 코어에서 멀티플렉싱하거나 여러 CPU 코어에서 병렬로 병행하게 실행할 수 있다.

</br>

- **운영체제는 프로세스 관리와 연관해 활동에 대한 책임**을 진다.
    - 사용자 프로세스와 시스템 프로세스의 생성과 제거
    - CPU에 프로세스와 스레드 스케줄하기
    - 프로세스의 일시 중지와 재수행
    - 프로세스 동기화를 위한 기법 제공
    - 프로세스 통신을 위한 기법 제공

</br>

### 메모리 관리

→ ***메인 메모리는 CPU와 입출력 장치에 의하여 공유되는 빠른 접근이 가능한 데이터의 저장소이다.***

- 메인 메모리는 일반적으로 **CPU가 직접 주소를 지정할 수 있고, 직접 접근할 수 있는 유일한 대량 메모리**이다.
    - CPU가 디스크에서 가져온 데이터를 처리하려면, 데이터는 먼저 메인 메모리로 전송되어야 한다.
    - 또한, CPU가 명령을 수행하기 위해서는 명령이 메인 메모리 내에 있어야 한다.

</br>

> **프로그램이 수행되기 위해서는 반드시 절대 주소로 매핑되고, 메모리에 적재되어야 한다.**
- 프로그램을 수행하면서, **절대 주소를 생성하여 메모리의 프로그램 명령어와 데이터에 접근**한다.
    - 프로그램이 종료되고 프로그램이 차지하던 메모리 공간은 가용공간으로 선언되고, 다음 프로그램이 적재되어 수행될 수 있다.

</br>

- CPU 이용률과 컴퓨터의 응답 속도를 개선하기 위해, **메모리에 여러 개의 프로그램을 유지해야 하며 메모리 관리 기법이 필요**하다.
    - 메모리 관리 기법의 선택은 특히 **시스템의 하드웨어 설계**에 좌우된다.

</br>

> **운영체제는 메모리 관리와 관련하여 여러 일을 담당해야 한다.**
- 메모리의 어느 부분이 현재 사용되고 있으며, 어느 프로세스에 의해 사용되고 있는지를 추적해야 한다.
- 필요에 따라 메모리 공간을 할당하고 회수해야 한다.
- 어떤 프로세스들을 메모리하고 적재하고, 제거할 것인지를 결정해야 한다.

</br>

### 파일 시스템 관리

→ ***운영체제는 정보 저장장치에 대한 균일한 논리적 관점을 제공한다.***

> **파일 : 저장장치의 물리적 특성을 추상화한 논리적인 저장 단위**

- 운영체제는 파일을 물리적 매체로 매핑하며, 저장장치를 통해 파일에 접근한다.

</br>

> **파일은 파일 생성자에 의해 정의된 관련 정보의 집합체이다.**
- 일반적으로 파일은 **프로그램과 데이터**를 나타낸다.
    - 파일은 텍스트 파일과 같은 자유 형태일 수도 있고, 엄격하게 포맷된 형태일 수도 있다.
- 운영체제는 대량 저장 매체와 그것을 제어하는 장치를 관리함으로써 파일의 추상적인 개념을 구현한다.
    - 파일은 사용하기 쉽도록 통상 **디렉터리**로 구성된다.

</br>

> **운영체제는 파일 관리를 위하여 여러 일을 담당한다.**
- 파일의 생성 및 제거
- 디렉터리 생성 및 제거
- 파일과 디렉터리를 조작하기 위한 프리미티브의 제공
- 파일을 보조 저장장치로 매핑
- 안정적인(비휘발성) 저장 매체에 파일을 백업

</br>

### 대용량 저장장치 관리

→ ***컴퓨터 시스템은 메인 메모리를 백업하기 위해 보조저장장치를 제공해야 한다.***

- 대부분의 최신 컴퓨터 시스템은 HDD와 NVM 장치를 프로그램과 데이터를 위한 온라인 저장 매체로 사용한다.
    - 컴파일러, 웹 브라우저, 워드 프로세스 등 프로그램 대부분은 메모리에 적재될 때까지 이러한 장치에 저장된다.

</br>

→ **보조저장장치의 적절한 관리는 컴퓨터 시스템에서 가장 중요하다!**

</br>

> **보조저장장치는 매우 빈번하고 폭넓게 사용되므로, 효율적으로 사용해야 한다.**
- **컴퓨터의 전체 동작 속도는 보조저장장치 서브시스템과 그것을 조작하는 알고리즘의 속도에 의해 결정**될 수 있다.

</br>

- **보조저장장치 보다 느리고, 비용은 적게 들고 용량이 더 큰 장치**를 사용하는 경우도 많다.
    - 디스크 데이터의 백업, 가끔 쓰이는 데이터 및 장기간 보존이 필요한 데이터를 저장하는 경우이다.
        - 자기 테이프 드라이브, CD, DVD, Blu-ray 드라이브 등

</br>

> **운영체제는 보조저장장치 관리와 관련하여 여러 활동을 담당한다.**
> 
- 마운팅과 언마운팅
- 사용 가능 공간의 관리
- 저장장소 할당
- 디스크 스케줄링
- 저장장치 분할
- 보호

</br>

### 캐시 관리

→ ***캐싱은 컴퓨터 시스템의 중요한 원리이다.***

- 정보는 통상 메인 메모리와 같은 어떤 저장장치에 보관된다.
    - 정보가 사용됨에 따라, **더 빠른 장치인 캐시에 일시적으로 복사**된다.

</br>

→ 특정 정보가 필요한 경우, 먼저 **캐시에 그 정보가 있는지를 확인**해야 한다.

→ 캐시에 있다면 정보를 캐시로부터 직접 사용하지만, 캐시에 없다면 메인 메모리로부터 정보를 가져와야 하고, 이 때 정보가 **다음에 곧 다시 사용될 확률이 높다면 캐시에 넣는다.**

</br>

> **캐시 크기가 제한되어 있으므로, 캐시 관리를 신중하게 하면 성능이 크게 향상될 수 있다.**

![image](https://user-images.githubusercontent.com/106216912/209518673-351dadb9-d0d9-49e6-b6d6-5764e172056c.png)

</br>

> **저장장치의 계층 구조에서 각 수준 간의 정보 이동은 하드웨어 설계나 제어하는 운영체제에 따라 명시적 또는 묵시적으로 이루어진다.**
> 

![image](https://user-images.githubusercontent.com/106216912/209518753-7dc22f96-e28d-470b-830a-e84b2b0d7184.png)

- 캐시 → CPU 및 레지스터로의 전송은 **운영체제의 간섭 없이 하드웨어적**으로 이루어진다.
- 디스크와 메모리 간의 데이터 전송은 **운영체제에 의해** 제어된다.

</br>

> **캐시 일관성 문제**
> 
- **다중 처리기 환경**에서는 상황이 복잡하다.
- A의 복사본이 동시에 여러 캐시에 존재할 수 있다.
    - 따라서, **한 캐시에 있는 A 값이 갱신될 경우, A가 존재하는 모든 캐시에 즉각적으로 반영되어야 한다.**

</br>

- **분산 환경**에서는 상황이 훨씬 더 복잡하다.
    - 이 환경에서는 동일한 파일의 여러 사본을 다른 컴퓨터에 보관할 수 있다.
    - 복제본을 한 곳에서 업데이트 할 때 **다른 모든 복제본을 가능한 한 빨리 최신 상태로 유지해야 한다.**

</br>

### 입출력 시스템 관리

→ **운영체제의 목적 중의 하나는 사용자에게 특정 하드웨어 장치의 특성을 숨기는 것이다.**

- ex) UNIX에서 입출력 장치의 특성은 입출력 서브시스템에 의해 **운영체제 자체의 대부분으로부터 숨겨져 있다.**
- 장치 드라이버만이 자신에게 지정된 특성 장치의 특성을 알고 있다.

</br>

> **입출력 시스템의 구성 요소**
- 버퍼링, 캐싱, 스풀링을 포함한 메모리 관리 구성요소
- 일반적인 장치 드라이버 인터페이스
- 특정 하드웨어 장치들을 위한 드라이버

---

## 6. 보안과 보호

→ ***컴퓨터 시스템이 다수의 사용자를 가지며, 다수 프로세스의 병행 수행을 허용한다면, 데이터에 대한 접근은 반드시 규제되어야 한다.***
- 자원들에 대해 **운영체제로부터 적절한 허가를 획득한 프로세스만이 작업할 수 있도록** 보장해야 한다.

</br>

> **보호 : 컴퓨터 시스템이 정의한 자원에 대해 프로그램, 프로세스, 사용자들의 접근을 제어하는 기법**
- 시행될 제어에 대한 명세와, 이들을 강제 시행하는 방법을 규정하는 수단을 반드시 제공해야 한다.
- 구성 요소 서브 시스템 간의 인터페이스에서 잠재적인 오류를 검출함으로써, **시스템의 신뢰성을 증가**시킬 수 있다.
- **보호되지 않는 자원은 권한이 없거나, 무자격 사용자에 의해 사용되는 것을 방지할 수 없다.**

</br>

> **보안 : 충분한 보호 기능이 있더라도 고장이 나거나, 부적절한 접근이 일어났을 때 외부 또는 내부의 공격을 방어하는 것**
- 공격 : 바이러스, 웜, 서비스 거부 공격, 식별자 도용, 서비스 도용 등

</br>

> **보호와 보안을 제공하기 위해서는 시스템의 모든 사용자를 구분할 수 있어야 한다.**
- 운영체제의 대부분은 사용자 이름과 연관된 **사용자 식별자**의 리스트를 유지한다.
    - 식별자는 **사용자마다 할당되고, 시스템에서 유일한 값**을 가진다.
    - 사용자가 로그인 할 때, **인증 단계에서 사용자에게 맞는 적절한 식별자를 결정**한다.
    - 식별자를 사용자가 읽어야 할 필요가 있을 때는 사용자 이름 리스트를 통하여 사용자 이름으로 변경된다.

</br>

> **어떤 상황에서는 각 사용자가 아니라 사용자의 집합을 구분하기를 원한다.**
- ex) UNIX 시스템에서는 파일의 소유주에게는 모든 연산을 허용하고, 일부 사용자들에게는 읽기 연산만을 허용할 수도 있다.
    - 따라서, **그룹 이름과 그 그룹에 속한 사용자들을 정의할 필요**가 있다.
        - 그룹 기능은 시스템 전체에 존재하는 그룹 이름과 그룹 식별자의 리스트로 구현될 수 있다.

</br>

> **사용자는 때때로 원하는 작업을 수행하기 위해서 권한을 상승해야 할 때가 있다.**
- 운영체제는 **권한 상승**을 허용하는 다양한 방법을 제공한다.
    - ex) UNIX에서는 `setuid` 속성을 이용하여 식별자를 접근하려고 하는 파일의 소유주 식별자를 이용할 수 있다.
    - 종료되거나 특권을 해제하기 전까지 이 **유효 사용자 식별자**를 이용하여 수행된다.

---

## 7. 가상화

→ ***가상화는 단일 컴퓨터의 하드웨어를 여러 가지 실행 환경으로 추상화하여, 개별 환경이 자신만의 컴퓨터에서 실행되고 있다는 환상을 만들 수 있는 기술이다.***

- 부가적인 기능을 제공하는 것이 아니라, 하드웨어 자체를 사용할 때와 동일한 인터페이스를 제공하는 것이다.
- 가상 머신의 사용자는 다양한 운영체제 간에 전환할 수 있다.

</br>

![image](https://user-images.githubusercontent.com/106216912/209669055-ec5c7f77-c4f0-47fc-ab06-c5dbf8475ed4.png)

> **가상화는 운영체제가 다른 운영체제 내에서 하나의 응용처럼 수행될 수 있게 한다.**
> 
- 소프트웨어로 컴퓨터 하드웨어 시뮬레이션 하는 **에뮬레이션**은 비용이 크고, 느리다.
- 가상화에서는 **특정 CPU를 위해 컴파일된 운영체제가 동일 CPU용의 다른 운영체제 내에서 수행**된다.

---

## 8. 분산 시스템

→ ***분산 시스템은 물리적으로 떨어져 있는 이기종 컴퓨터들의 집합이다.***

- 분산 시스템의 컴퓨터들은 사용자가 시스템 내의 다양한 자원들을 접근할 수 있도록 **네트워크**로 연결되어 있다.
- 공유 자원에 대한 접근은 **계산 속도와 기능, 데이터 가용성 및 신뢰성을 향상**시킨다.

</br>

- 네트워크는 **두 개 이상 시스템 간의 통신 경로**로, 분산 시스템의 많은 기능은 네트워킹에 의존한다.
    - 네트워크는 **노드 간의 거리**에 의해 유형이 결정된다.
        - LAN, WAN, MAN, PAN 등

---