
> **운영체제란**? <br>
→ 컴퓨터 하드웨어를 관리하는 소프트웨어이다. <br>
→ 응용 프로그램을 위한 기반을 제공하며, 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할을 수행한다. <br>
→ CPU, 메모리 및 입출력 장치와 저장장치를 프로그램에 할당한다.

<br>

- 운영체제는 **광범위한(사물 인터넷, 자동차, 스마트폰, 컴퓨터 등) 컴퓨팅 환경에서 여러 일들을 다양한 방법으로 수행**한다.

---

## 1. 운영체제가 할 일

→ ***컴퓨터 시스템은 하드웨어, 운영체제, 응용 프로그램, 사용자로 구분할 수 있다.***

<img width="400" alt="image" src="https://user-images.githubusercontent.com/106216912/209369001-0c7333ac-30a5-44d0-888e-67e0f7365ef4.png">

- **하드웨어** : 중앙 처리 장치(CPU), 메모리 및 입출력(I/O) 장치
- **응용 프로그램** : 워드 프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등

→ 운영체제는 다양한 사용자를 위해, <u>**다양한 응용 프로그램 간의 하드웨어 사용을 제어 및 조정**</u>한다.

<br>

> **운영체제의 역할을 사용자와 시스템 두 관점에서 살펴보자.** 

### 사용자 관점

→ ***컴퓨터에 대한 사용자의 관점은 사용되는 인터페이스에 따라 달라진다.***

- 대부분의 사용자는 랩톱, 모니터, 키보드, 마우스로 구성된 PC 앞에서 작업한다.
    - 이러한 시스템은 한 사용자가 자원을 독점하도록 설계되었고, 목표는 사용자가 수행하는 작업을 최대화 하는 것이다.
    
    → 운영체제는 대부분 **사용의 용이성을 위해 설계**되고, 하드웨어와 소프트웨어 자원이 어떻게 공유되는지의 **자원의 이용에는 신경을 쓰지 않는다.**

<br> 

### 시스템 관점

→ ***시스템의 관점에서는 운영체제는 하드웨어와 밀접하게 연관된 프로그램이다.***

- **자원 할당자**
    - 컴퓨터 시스템은 여러 가지 자원들(하드웨어 & 소프트웨어), 즉 CPU 시간, 메모리 공간, 저장장치 공간, 입출력 장치 등을 가진다.
    - 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 **어느 요청에 자원을 할당할 지 결정**해야 한다.

<br>

- **제어 프로그램**
    - 컴퓨터의 부적절한 사용을 방지하기 위해 **사용자 프로그램의 실행을 제어**한다.
        - 특히, 입출력 장치의 제어와 작동에 깊이 관여한다.

<br>

### 운영체제의 정의

→ ***운영체제에 대한 적합한 정의는 없다.***

- 운영체제는 <u>**유용한 컴퓨터 시스템을 만드는 문제를 해결할 수 있는 합리적인 방법을 제공하기 위해**</u> 존재한다.
- 응용 프로그램에는 입출력 장치 제어와 같은 공통적인 작업과 자원을 제어하고 할당하는 일반적인 기능이 필요하다.
    - 이 기능들을 **운영체제라는 하나의 소프트웨어로 통합**한 것이다.

<br>

- **운영체제는 컴퓨터에서 항상 실행되는 프로그램(커널)이다.**
- 커널과 다른 두 가지 유형의 프로그램이 존재한다.
    - **시스템 프로그램** : 운영체제와 관련되어 있지만, 반드시 커널의 일부일 필요는 없는 프로그램으로 시스템 관리에 도움을 준다.
    - 응용 프로그램 : 시스템 작동과 관련되지 않은 모든 프로그램을 포함한다.

<br>

- 모바일 기기의 운영체제 를 보면 운영체제를 구성하는 기능의 수가 증가하고 있다.
    - 핵심 커널 이외에 **미들웨어**도 포함된다.

<br>

> **요약 → 운영체제에는 커널, 미들웨어 프레임워크, 시스템 프로그램이 포함된다.** 

---

## 2. 컴퓨터 시스템의 구성

→ ***컴퓨터 시스템은 하나 이상의 CPU, 구성요소와 공유 메모리 사이의 액세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성된다.***

<img width="481" alt="image" src="https://user-images.githubusercontent.com/106216912/209372583-e6bf39b7-0e0e-4b9a-b3a7-2024089cd0b0.png">

- 일반적으로 운영체제에는 각 장치 컨트롤러마다 **장치 드라이버**가 있다.
    - 장치 드라이버는 운영체제에 <u>**장치에 대한 일관된 인터페이스를 제공**</u>한다.
        - CPU ↔?장치 컨트롤러 : 병렬로 실행되어 메모리 사이클을 놓고 경쟁한다.
        - 메모리 컨트롤러 : 메모리에 대한 액세스를 동기화시켜 공유 메모리를 질서 있게 액세스시킨다.

</br>

### 인터럽트

→ ***장치 컨트롤러는 작업이 완료되면 장치 드라이버에게 작업이 완료되었음을 알린다.***

- 하지만 컨트롤러는 장치 드라이버에게 작업이 완료했다는 것을 어떻게 알릴까?
    
    → **인터럽트!**
    
</br>

- 하드웨어는 <u>**시스템 버스를 통해 CPU에 신호를 보내 인터럽트를 발생시킬 수 있다.**</u>
    - **인터럽트는 운영체제와 하드웨어의 상호 작용 방식의 핵심**이다.
    - 인터럽트가 발생되면, CPU는 하던 일을 중단하고 고정된 위치로 실행을 옮기고, **인터럽트 서비스 루틴**이 실행된다.
        - 고정된 위치 : 일반적으로 인터럽트를 위한 서비스 루틴이 위치한 시작 주소
    - 그 후, **인터럽트 서비스 루틴의 실행이 완료되면 다시 연산을 재개**한다.

</br>

- 인터럽트는 적절한 서비스 루틴으로 제어를 전달한다.
    - 이 전달을 관리하는 방법은 인터럽트 정보를 조사하는 일반적인 루틴을 호출하는 방법이다.
    - 하지만 <u>**인터럽트는 매우 빈번히 발생되고 빠르게 처리되어야 한다.**</u>
        - 따라서, **인터럽트 루틴에 대한 포인터들의 테이블**을 대신 이용할 수 있다.
        - 이 테이블에는 **인터럽트 서비스 루틴의 주소**가 들어 있다.
    - 인터럽트가 요청되면 **인터럽트 벡터**가 인터럽트 요청과 함께 주어진 고유의 유일한 장치 번호로 색인되어 주소를 얻을 수 있다.

</br>

- 인터럽트된 모든 정보를 저장해야 인터럽트를 처리한 후 이 정보를 복원할 수 있다.
    - 인터럽트 루틴이 처리기의 상태를 변경한다면, <u>**반드시 현재의 상태를 저장하고, 복귀하기 전에 상태를 복원**</u>해야 한다.
    - 그 후, 복귀 주소를 프로그램 카운터에 적재하고 중단되었던 연산이 다시 시작된다.

</br>

<img width="475" alt="image" src="https://user-images.githubusercontent.com/106216912/209372909-f75b065d-bed5-4a3b-a65f-e760a4251b58.png">

1. 하나의 명령어의 실행을 완료할 때마다 CPU가 인터럽트 요청 라인을 감지한다.
2. 그 후, 인터럽트 번호를 읽고 번호를 인터럽트 벡터의 인덱스로 사용하여, 인터럽트 핸들러 루틴으로 점프한다.
3. 그런 다음 해당 인덱스와 관련된 주소에서 실행을 시작한다.
4. 인터럽트 처리기는 변경될 상태 저장, 인터럽트 원인 확인, 필요한 처리 수행, 상태 복원 등의 작업을 수행하고 CPU를 인터럽트 전 실행 상태로 되돌린다.

→ **장치 컨트롤러가 인터럽트 요청 라인에 신호를 선언하여 인터럽트를 발생(raise)시키고 CPU는 인터럽트가 포착(catch)하여 인터럽트 핸들러로 디스패치(dispatch)하고, 핸들러는 장치를 서비스하여 인터럽트를 지운다(clear).**

</br>

> **최신 운영체제에서는 정교한 인터럽트 처리 기능이 필요하다.**
1. 중요한 처리 중에 인터럽트 처리를 연기할 수 있어야 한다.
2. 장치의 적절한 인터럽트 핸들러로 효율적으로 디스패치 할 방법이 필요하다.
3. 운영체제가 우선순위가 높은 인터럽트와 우선순위가 낮은 인터럽트를 구분하고 적절한 긴급도로 대응할 수 있도록 다단계 인터럽트가 필요하다.

</br>

> **인터럽트는 최신 운영체제에서 비동기 이벤트를 처리하기 위해 사용된다.**
- 장치 컨트롤러 및 하드웨어 오류로 인해 인터럽트가 발생한다.
- 가장 긴급한 작업을 먼저 수행하기 위해 최신 컴퓨터는 **인터럽트 우선순위 시스템**을 사용한다.

→ **인터럽트는 빈번하게 사용되므로 효율적인 인터럽트 처리가 필요하다!**

</br>

### 저장장치 구조

→ ***CPU는 메모리에서만 명령을 적재할 수 있으므로, 실행을 위해서는 프로그램을 메모리에 먼저 적재해야 한다.***

- 컴퓨터는 프로그램 대부분을 **메인 메모리(RAM = 휘발성)라 불리는 재기록 가능한 메모리**에서 가져온다.

</br>

- 모든 형태의 <u>**메모리는 바이트의 배열을 제공하고, 각 바이트는 자신의 주소를 가지고 있다.**</u>
    - 상호 작용은 특정 메모리 주소들에 대한 일련의 **적재(load), 또는 저장(store) 명령**을 통해 이루어진다.
    - **적재** : 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것
    - **저장** : 레지스터의 내용을 메인 메모리로 옮기는 것

</br>

> **이상적으로는 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.**

→ 그러나 대부분의 시스템에서 두 가지 이유로 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 **영구히 저장하기에는 너무 작다.**
2. 메인 메모리는 전원이 공급되지 않으면 그 **내용을 잃어버리는 휘발성 장치**이다.

</br>

- 따라서 메인 메모리의 확장으로 **보조 저장 장치**를 제공한다.
    - 보조 저장 장치는 <u>**대량의 데이터를 영구히 보존**</u>할 수 있어야 한다.
        - **하드 디스크 드라이브(HDD)**
        - **비휘발성 메모리(NVM) 장치**
    - 프로그램과 데이터 모두를 위한 저장소를 제공하며, 대부분의 프로그램은 메모리에 적재될 때까지 보조 저장 장치에 저장된다.
        - 보조 저장 장치는 메인 메모리 보다 **훨씬 느리다.**

</br>

- **3차 저장장치** : 백업 사본을 저장하기 위해 특수 목적으로만 사용되는 매우 느리고 큰 장치

</br>

> **다양한 저장장치 시스템은 저장 용량 및 액세스 시간에 따라 계층 구조로 구성될 수 있다.**

<img width="564" alt="image" src="https://user-images.githubusercontent.com/106216912/209373152-d16d9867-7ec9-423b-bed0-b400f7a446d2.png">

- 속도와 용량의 차이도 있지만, **휘발성 또는 비휘발성**이라는 차이도 존재한다.
- 기계적 저장장치(HDD)는 전기적 저장장치(SSD)보다 용량이 크고, 비용이 저렴하다.
    - 전기적 저장장치는 반대로 비싸고, 용량이 적으며 빠르다.

→ **가능한 한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에, 필요한 만큼의 비싼 메모리를 사용해야 한다.**

</br>

### 입출력 구조

→ ***시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터이다.***

- 인터럽트 구동 형태의 입출력은 **소량의 데이터를 이동하는 데는 좋지만**, **대량 데이터 이동에는 높은 오버헤드를 유발**할 수 있다.
    - 따라서, <u>**직접 메모리 액세스**</u>가 사용된다.

</br>

> **직접 메모리 액세스**

→ ***장치에 대한 버퍼, 포인터, 입출력 카운트를 세팅한 후, 장치 제어기는 CPU의 개입 없이 데이터 블록 전체를 전송한다.***

<img width="369" alt="image" src="https://user-images.githubusercontent.com/106216912/209373279-db3d2468-aaa1-4219-9dbe-ea5ace841a20.png">

- 한 바이트마다 인터럽트가 발생하는 것이 아니라, **블록 전송이 완료될 때마다 인터럽트가 발생**한다.
    - 장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.

---

## 3. 컴퓨터 시스템 구조

→ ***컴퓨터 시스템은 사용된 범용 처리기의 수에 따라 다양한 방식으로 구성된다!***

</br>

### 단일 처리기 시스템(Single-Processor Systems)

→ ***코어는 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소이다.***

- 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함하여 범용 명령어 세트를 실행할 수 있다.
- 운영체제는 이 처리기들이 수행할 다음 태스크에 대한 정보를 보내고, 처리기들의 상태를 감시한다.

</br>

- 다른 시스템 또는 환경에서는 전용 처리기가 하드웨어로 구현되는 저수준의 구성요소이다.
    - 운영체제는 이 처리기들과 통신할 수 없으며, 처리기들은 독립적으로 자신의 작업을 처리한다.

</br>

> **단일 프로세서(처리기) 시스템은 단일 처리 코어를 가진 범용 CPU가 하나만 있는 시스템이다.**

</br>

### 다중 처리기 시스템(Multiprocessor Systems)

→ ***모바일 장치에서 서버에 이르기까지 최신 컴퓨터에는 다중 처리기 시스템이 컴퓨팅 환경을 지배하고 있다.***

- 다중 처리기 시스템에는 각각 **단일 코어 CPU가 있는 두 개 이상의 프로세서**가 있다.
    - 프로세서는 컴퓨터 버스, 클록, 메모리 및 주변 장치를 공유한다.
- 다중 처리기 시스템의 장점은 **처리량 증가**이다.
    - 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행할 수 있다.
        - 하지만 **프로세서 개수가 N개가 된다고 해서 속도 향상도 N배가 되는 것은 아니다.**
        - 여러 프로세서가 하나의 작업을 협력할 때, **일정한 양의 오버헤드가 발생하기 때문**이다.

</br>

> **대칭적 다중 처리(SMP)**

![image](https://user-images.githubusercontent.com/106216912/209477767-b94abf26-38cb-4187-bb9e-6833669677c9.png)


- 가장 일반적인 다중 처리기 시스템은 각 피어 CPU 프로세서가 운영체제 기능 및 사용자 프로세스를 포함한 모든 작업을 수행하는 **대칭적 다중 처리 - SMP**를 사용한다.
- 각 CPU 처리기에는 개별 또는 로컬 캐시뿐만 아니라, 자체 레지스터 세트를 갖고 있다.
    - 하지만 **모든 프로세서는 시스템 버스를 통해 물리 메모리를 공유**한다.

</br>

- 이 모델의 장점은 **많은 프로세스를 동시에 실행할 수 있다는 것이다!**
    - 프로세스 및 메모리와 같은 자원을 동적으로 공유하여 프로세서 간의 작업 부하를 낮출 수 있다.
    - 하지만 **CPU가 독립적이기 때문에 하나는 쉬고 있고, 다른 하나는 과부하가 걸려 비효율적일 수 있다.**

</br>

> **다중 코어 시스템**

![image](https://user-images.githubusercontent.com/106216912/209477810-ced7b8bd-1f2a-4c73-98cb-3781ab80ac87.png)

- 다중 코어 시스템은 **여러 개의 컴퓨팅 코어가 단일 칩에 존재**한다.
    - 칩 내에서의 통신이 칩 사이의 통신보다 빠르므로, **다중 코어 시스템은 단일 코어를 가지는 여러 칩보다 효율적일 수 있다!**
    - 또한, **다중 코어 시스템은 여러 개의 단일 코어 칩을 사용하는 것보다 훨씬 적은 전력을 사용**한다.

</br>

→ **다중 처리기 시스템에 CPU를 추가하면 컴퓨팅 성능이 향상 되지만, 너무 많이 추가하면 오히려 시스템 버스에 대한 경합이 병목 현상이 되어 성능이 저하된다!**

</br>

> **NUMA(불균일 기억 장치 접근)**

![image](https://user-images.githubusercontent.com/106216912/209477848-0e0aa843-6f45-41a4-a133-7a0f900f5949.png)


- 각 CPU에 작고 빠른 로컬 버스를 통해 액세스 되는 **자체 로컬 메모리를 제공**한다.
    - 모든 CPU가 **공유 시스템 연결로 연결되어, 하나의 물리 주소 공간을 공유**한다.

</br>

- **이 모델의 장점은?**
    - CPU가 **로컬 메모리에 액세스 할 때 빠를 뿐만 아니라, 시스템 상호 연결에 대한 경합도 존재하지 않는다.**
        - 따라서 **더 많은 프로세서가 추가될수록 더 효과적으로 확장 가능하다!**

</br>

- **이 모델의 단점은?**
    - CPU가 시스템 상호 연결을 통해 **원격 메모리에 액세스할 때, 지연 시간이 증가하여 성능 저하가 발생할 수 있다.**
        - ex) CPU0은 자체 로컬 메모리에는 빠르게 액세스 가능하지만, CPU3의 로컬 메모리에는 그만큼 빨리 액세스 할 수 없다.

</br>

### 클러스터형 시스템(Clustered Systems)

→ ***여러 CPU를 가진 시스템의 또 다른 유형이다.***

- 다중 처리기 시스템과 같이 여러 개의 CPU를 갖고 있지만, **둘 이상의 독자적 시스템 또는 노드들을 연결하여 구성한다는 점**이 다르다.

</br>

- 클러스터링은 통상 **높은 가용성을 제공하기 위해 사용**된다.
    - 즉, **클러스터 내 하나 이상의 컴퓨터 시스템이 고장 나더라도 서비스는 계속 제공**된다.
    - 높은 가용성은 시스템에 중복 기능을 추가함으로써 얻어진다.

</br>

> **어떻게 한 시스템이 고장나도 서비스를 계속 제공할 수 있을까?**
- 각 노드는 하나 이상의 다른 노드들을 감시한다.
- 만약 감시를 받던 노드가 고장나면, **감시하던 노드가 고장 난 노드의 저장장치에 대한 소유권을 넘겨받는다.**
    - 그 후, **그 노드에서 실행 중이던 응용 프로그램을 다시 시작**한다.

→ 결국 **사용자와 클라이언트는 잠깐의 서비스 중단만을 경험**한다.

</br>

> **우아한 성능 저하 : 남아 있는 하드웨어 수준에 비례하여 서비스를 계속 제공하는 기능 </br>
 결함허용 시스템 : 정상적인 성능 저하가 아닌 단일 구성요소에 오류가 발생해도 계속 작동할 수 있는 시스템**

</br>

> **클러스터링은 비대칭적으로 또는 대칭적으로 구성될 수 있다.**
- **비대칭형 클러스터링**
    - 다른 컴퓨터들이 응용 프로그램을 실행하는 동안, **한 컴퓨터는 긴급 대기 모드 상태를 유지**한다.
        - 활성 서버들을 **감시하다가, 서버가 고장 난다면 긴급 대기 모드의 호스트가 활성 서버가 된다.**

</br>

- **대칭형 클러스터링**
    - **둘 이상의 호스트들이 응용 프로그램을 실행하고, 서로를 감시**한다.
    - 가용한 하드웨어를 모두 사용하기 때문에 **비대칭형 클러스터링보다 효율적**이다.

</br>

> **클러스터는 네트워크로 연결된 다수의 컴퓨터 시스템으로 구성되므로 고성능 계산환경을 제공하도록 사용될 수 있다.**
> 
- 클러스터 내의 모든 컴퓨터에서 응용을 병렬 수행할 수 있으므로, **단일 처리기나 SMP 시스템보다 훨씬 큰 계산 능력을 제공**할 수 있다.
    - 하지만 **병렬화**로 응용이 클러스터를 이용할 수 있도록 작성되어야 한다.

![image](https://user-images.githubusercontent.com/106216912/209477971-3ff65357-4e0e-43b3-8e16-9055b51fc56e.png)

</br>

> **다른 형태의 클러스터로 병렬 클러스터와 WAN을 이용한 클러스터링이 존재한다.**
- **병렬 클러스터**
    - **여러 호스트가 공유 저장장치상의 동일한 데이터에 접근**할 수 있게 한다.
    - 시스템은 **접근 간의 충돌이 발생하지 않는 것을 보장하기 위해 접근 제어와 잠금 기법**을 제공해야 한다.
    - **대부분의 운영체제가 이러한 동시 접근을 지원하지 않으므로**, 특수한 소프트웨어나 특별 발매 버전에만 적용된다.

---

## 4. 운영체제의 작동

→ ***운영체제는 프로그램이 실행되는 환경을 제공한다.***

- 내부적으로 운영체제는 여러 경로를 거쳐 구성되기 때문에 큰 차이가 있지만, 많은 공통점 또한 존재한다.

</br>

- 초기 프로그램 또는 **부트스트랩 프로그램**을 실행 함으로써, 컴퓨터를 실행시킬 수 있다.
    - 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장된다.
    - 시스템의 모든 측면을 **초기화** 한다.
    - 부트스트랩 프로그램은 **운영체제를 적재하는 방법과 해당 시스템 실행을 시작**할 수 있어야 한다.
        
        → **부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재**해야 한다.

</br>

- 커널이 적재되고 실행되면, 시스템과 사용자에게 서비스를 제공할 수 있다.
    - 일부 서비스는 시스템 데몬이 되기 위해 부팅할 때 메모리에 적재되는 시스템 프로그램에 의해 커널 외부에서 제공된다.
    
    → 이 단계가 완료되면 **시스템이 완전히 부팅되고, 시스템은 어떤 이벤트가 발생할 때까지 기다린다.**

</br>    

- 실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없다면 **운영체제는 무언가가 발생할 때까지 기다린다.**
    - 이벤트는 **인터럽트**를 발생시켜서 신호를 보낸다.
    - **트랩(예외), 오류 또는 사용자 프로그램의 특정 요청으로 발생하는 인터럽트**도 있다.
        - 이 특정 요청은 **시스템 콜**이라는 특수 연산을 실행해서 요청된다.

</br>

### 다중 프로그래밍과 다중 태스킹(Multiprogramming and Multitasking)

→ ***운영체제의 가장 중요한 측면은 여러 프로그램을 실행할 수 있다는 것이다.***

</br>

> **다중 프로그래밍은 CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여, CPU 이용률을 높이고 사용자 만족도를 높인다.**
- 다중 프로그램 시스템에서 실행 중인 프로그램을 **프로세스**라고 한다.

</br>

![image](https://user-images.githubusercontent.com/106216912/209478035-d3fc9cab-c350-4b0e-b11d-2ac021c819fc.png)

- 운영체제는 **여러 프로세스를 동시에 메모리에 유지**한다.
    - 그 후, 프로세스 중 하나를 선택하여 실행한다.
- 다중 프로그래밍 되지 않은 시스템에서는 CPU가 쉬고 있을 수도 있다.
    - 다중 프로그램 시스템에서는 **운영체제가 단순히 다른 프로세스로 전환하여 실행**한다.
    - 결국 첫 번째 프로세스는 대기를 마치고 CPU를 다시 돌려받는다.

</br>

> **다중 태스킹은 다중 프로그래밍의 논리적 확장이다.**
- 다중 태스킹 시스템에서 CPU는 여러 프로세스를 전환하며 프로세스를 실행하지만, 전환이 자주 발생하기 때문에 **사용자 에게 빠른 응답 시간을 제공**한다.
    - 대화식 입출력은 사람의 속도로 수행되므로, 완료 시 까지 상당히 긴 시간이 걸릴 수 있다.
    - 대화식 입력이 진행되는 동안, CPU를 쉬게 하지 않고, 운영체제는 CPU를 다른 사용자의 프로그램으로 신속하게 전환한다.

</br>

- 동시에 여러 프로세스를 메모리에 유지하려면 **메모리 관리 방식**이 필요하다.
    - 또한 **시스템은 다음에 어떤 프로세스를 실행시킬 지 선택**해야 한다.
        - **CPU 스케줄링**

</br>

> **다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야 한다.**
- 일반적인 방법은 **가상 메모리**로, **일부만 메모리에 적재된 프로세스의 실행을 허용하는 기법**이다.
    - 프로그램이 물리 메모리의 크기보다 커도 가능하다.
    - 사용자에게 보이는 논리 메모리를 물리 메모리로부터 분리시킨다.

</br>

→ 다중 프로그래밍 및 다중 태스킹 시스템도 **파일 시스템**을 제공해야 한다.

→ **저장장치 관리**가 제공되어야 한다.

→ 부적절한 사용으로부터 **자원을 보호**해야 한다.

→ **프로세스 동기화 및 통신을 위한 기법**을 제공해야 한다.

→ **교착 상태**에 빠지지 않도록 보장해야 한다.