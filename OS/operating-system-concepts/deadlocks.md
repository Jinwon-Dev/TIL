> **다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다.**

→ ***한 스레드가 자원을 요청했을 때, 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있다.***

- 이 때, 스레드가 **대기 상태**로 들어간다.

</br>

> **교착 상태란?**

→ ***대기 중인 스레드들이 요청한 자원들이 다른 스레드들에 의해 점유 되어 있고, 그들도 다 대기 상태에 있기 때문에 다시는 그 상태를 변경시킬 수 없는 상황***

---

## 1. 시스템 모델

→ ***시스템은 경쟁하는 스레드들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다.***

- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스들로 구성된다.
    - ex) CPU 주기, 파일, I/O 장치 등

</br>

- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다.
    - 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다.

</br>

> **스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.**

→ ***스레드는 지정된 태스크를 수행하기 위해, 필요한 만큼의 자원을 요청할 수 있다.***

- 요청된 자원의 수는 시스템에서 사용 가능한 전체 자원의 수를 초과해서는 안 된다.

</br>

> **정상적인 작동 모드하에서, 프로세스는 다음의 순서로만 자원을 사용할 수 있다.**

1. **요청** : **스레드는 자원을 요청**한다.
    - 요청이 즉시 허용되지 않으면, 요청 스레드는 자원을 얻을 때까지 대기해야 한다.

</br>

2. **사용** : **스레드는 자원에 대해 작업을 수행**할 수 있다.

</br>

3. **방출** : **스레드가 자원을 방출**한다.

</br>

→ **교착 상태** : ***한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다리는 현상***

---

## 2. 다중 스레드 응용에서의 교착 상태

→ ***먼저, POSIX mutex 락을 사용해서 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아본다.***

- `pthread_mutex_init()` 함수는 가용한 mutex를 초기화한다.
    - Mutex 락은 각각 `pthread_mutex_lock()` 과 `pthread_mutex_unlock()` 함수를 이용해서 획득되고, 방출된다.

</br>

- 한 스레드가 잠긴 mutex 락을 획득하려고 시도하면, `pthread_mutex_lock()` 함수 호출은 mutex 락의 소유주가 `pthread_mutex_unlock()` 함수를 호출할 때까지 이 스레드를 봉쇄한다.

</br>

> **두 mutex 락이 다음과 같은 코드에 의해 생성되고, 초기화된다.**

<img width="288" alt="image" src="https://user-images.githubusercontent.com/106216912/215436924-4d1e95dd-2697-4565-beaf-e76a073fe779.png">

- `thread_one` 과 `thread_two` 가 생성되고, mutex 락에 대한 접근 권한을 갖는다.
    - 두 스레드는 각각 `do_work_one()` 과 `do_work_two()` 함수를 실행한다.

</br>

- `thread_one` 은 첫 번째로 `first_mutex` , 두 번째로는 `second_mutex` 순서로 mutex 락을 획득하려고 한다.
    - 동시에 `thread_two` 는 첫 번째로 `second_mutex` , 두 번째로는 `first_mutex` 순서로 mutex 락을 획득하려 한다.

</br>

→ `thread_one` 이 `first_mutex` 를 획득하고, `thread_two` 가 `second_mutex` 를 획득하게 되면 교착 상태가 가능하다.

- 교착 상태가 가능하더라도, `thread_two` 가 락을 획득하려고 시도하기 전에 `thread_one` 이 `first_mutex` 와 `second_mutex` 를 획득하고 방출할 수 있다면, 교착 상태는 발생하지 않는다.

</br>

### 라이브락

→ ***라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다.***

- 교착 상태와 유사하게 두 개 이상의 스레드가 진행되는 것을 방해하지만, 진행할 수 없는 이유가 다르다.
    - 라이브락은 **실패한 행동을 계속해서 시도할 때 발생**한다.

</br>

> **라이브락은 `Pthreads` 의 `pthread_mutex_trylock()` 함수로 설명할 수 있다.**

→ ***이 함수는 봉쇄되지 않고, mutex 락을 획득하려고 시도한다.***

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/215437252-19431d26-62d3-463b-b94a-85f5c77f11c6.png">

- `thread_one` 이 `first_mutex` 를 획득한 후, `thread two` 가 `second_mutex` 를 획득하면 이 상황을 라이브락으로 이어질 수 있다.
    - 그런 다음 각 스레드는 `pthread_mutex_trylock()` 을 호출하여 실패하고, 각자의 락을 해제한 후 동일한 행동을 무한정 반복한다.

</br>

> **라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.**

→ ***따라서, 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.***

- 네트워크 충돌이 발생할 때, Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 패킷을 재전송하려고 시도하는 대신, 충돌한 호스트는 임의의 시간 동안 한 발 뒤로 물러선다.

</br>

→ ***라이브락은 교착 상태만큼 흔하지는 않지만, 병행 응용 프로그램을 설계할 때 어려운 문제이고, 특정 스케줄링 상황에서만 발생할 수 있다.***

---