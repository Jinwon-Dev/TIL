> **다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다.**

→ ***한 스레드가 자원을 요청했을 때, 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있다.***

- 이 때, 스레드가 **대기 상태**로 들어간다.

</br>

> **교착 상태란?**

→ ***대기 중인 스레드들이 요청한 자원들이 다른 스레드들에 의해 점유 되어 있고, 그들도 다 대기 상태에 있기 때문에 다시는 그 상태를 변경시킬 수 없는 상황***

---

## 1. 시스템 모델

→ ***시스템은 경쟁하는 스레드들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다.***

- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스들로 구성된다.
    - ex) CPU 주기, 파일, I/O 장치 등

</br>

- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다.
    - 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다.

</br>

> **스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.**

→ ***스레드는 지정된 태스크를 수행하기 위해, 필요한 만큼의 자원을 요청할 수 있다.***

- 요청된 자원의 수는 시스템에서 사용 가능한 전체 자원의 수를 초과해서는 안 된다.

</br>

> **정상적인 작동 모드하에서, 프로세스는 다음의 순서로만 자원을 사용할 수 있다.**

1. **요청** : **스레드는 자원을 요청**한다.
    - 요청이 즉시 허용되지 않으면, 요청 스레드는 자원을 얻을 때까지 대기해야 한다.

</br>

2. **사용** : **스레드는 자원에 대해 작업을 수행**할 수 있다.

</br>

3. **방출** : **스레드가 자원을 방출**한다.

</br>

→ **교착 상태** : ***한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다리는 현상***

---

## 2. 다중 스레드 응용에서의 교착 상태

→ ***먼저, POSIX mutex 락을 사용해서 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아본다.***

- `pthread_mutex_init()` 함수는 가용한 mutex를 초기화한다.
    - Mutex 락은 각각 `pthread_mutex_lock()` 과 `pthread_mutex_unlock()` 함수를 이용해서 획득되고, 방출된다.

</br>

- 한 스레드가 잠긴 mutex 락을 획득하려고 시도하면, `pthread_mutex_lock()` 함수 호출은 mutex 락의 소유주가 `pthread_mutex_unlock()` 함수를 호출할 때까지 이 스레드를 봉쇄한다.

</br>

> **두 mutex 락이 다음과 같은 코드에 의해 생성되고, 초기화된다.**

<img width="288" alt="image" src="https://user-images.githubusercontent.com/106216912/215436924-4d1e95dd-2697-4565-beaf-e76a073fe779.png">

- `thread_one` 과 `thread_two` 가 생성되고, mutex 락에 대한 접근 권한을 갖는다.
    - 두 스레드는 각각 `do_work_one()` 과 `do_work_two()` 함수를 실행한다.

</br>

- `thread_one` 은 첫 번째로 `first_mutex` , 두 번째로는 `second_mutex` 순서로 mutex 락을 획득하려고 한다.
    - 동시에 `thread_two` 는 첫 번째로 `second_mutex` , 두 번째로는 `first_mutex` 순서로 mutex 락을 획득하려 한다.

</br>

→ `thread_one` 이 `first_mutex` 를 획득하고, `thread_two` 가 `second_mutex` 를 획득하게 되면 교착 상태가 가능하다.

- 교착 상태가 가능하더라도, `thread_two` 가 락을 획득하려고 시도하기 전에 `thread_one` 이 `first_mutex` 와 `second_mutex` 를 획득하고 방출할 수 있다면, 교착 상태는 발생하지 않는다.

</br>

### 라이브락

→ ***라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다.***

- 교착 상태와 유사하게 두 개 이상의 스레드가 진행되는 것을 방해하지만, 진행할 수 없는 이유가 다르다.
    - 라이브락은 **실패한 행동을 계속해서 시도할 때 발생**한다.

</br>

> **라이브락은 `Pthreads` 의 `pthread_mutex_trylock()` 함수로 설명할 수 있다.**

→ ***이 함수는 봉쇄되지 않고, mutex 락을 획득하려고 시도한다.***

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/215437252-19431d26-62d3-463b-b94a-85f5c77f11c6.png">

- `thread_one` 이 `first_mutex` 를 획득한 후, `thread two` 가 `second_mutex` 를 획득하면 이 상황을 라이브락으로 이어질 수 있다.
    - 그런 다음 각 스레드는 `pthread_mutex_trylock()` 을 호출하여 실패하고, 각자의 락을 해제한 후 동일한 행동을 무한정 반복한다.

</br>

> **라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.**

→ ***따라서, 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.***

- 네트워크 충돌이 발생할 때, Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 패킷을 재전송하려고 시도하는 대신, 충돌한 호스트는 임의의 시간 동안 한 발 뒤로 물러선다.

</br>

→ ***라이브락은 교착 상태만큼 흔하지는 않지만, 병행 응용 프로그램을 설계할 때 어려운 문제이고, 특정 스케줄링 상황에서만 발생할 수 있다.***

---

## 3. 교착 상태 특성

→ ***교착 상태를 특징 짓는 조건을 자세히 알아본다.***

</br>

### 필요 조건들

→ ***교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.***

1. **상호 배제(mutual exclusion)**
- 최소한 하나의 자원이 비공유 모드로 점유되어야 한다.
    - 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    - 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 반드시 지연되어야 한다.

</br>

2. **점유하며 대기(hold-and-wait)**
- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.

</br>

3. **비선점(no preemption)**
- 자원들을 선점할 수 없어야 한다.
    - 즉, 자원이 강제적으로 방출될 수 없고 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.

</br>

4. **순환 대기(circular wait)**
- 대기하고 있는 스레드의 집합에서 `T0` 는 `T1` 이 점유한 자원을 대기한다.
    - 또한, `T1` 은 `T2` 가 점유한 자원을 대기하고, `Tn-1` 은 `Tn` 이 점유한 자원을 대기하며 `Tn` 은 `T0` 가 점유한 자원을 대기한다.

</br>

### 자원 할당 그래프

→ ***교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다.***

- 이 그래프는 **정점(vertex)** `V` 의 집합과 **간선(edge)** `E` 의 집합으로 구성된다.
    - 정점 `V` 의 집합은 시스템 내의 모든 활성 스레드의 집합인 `T = {T1, T2, ..., Tn}` 과 시스템 내의 모든 자원 유형의 집합인 `R = {R1, R2, ..., Rm}` 의 두 가지 유형으로 구별된다.

</br>

- **스레드 `Ti` 로부터 자원 유형 `Rj` 로의 방향 간선** = **요청 간선**
    - `Ti → Rj`
    - 스레드 `Ti` 가 자원 유형 `Rj` 의 인스턴스를 하나 요청하는 것으로, 현재 이 자원을 기다리는 상태

</br>

- **자원 유형 `Rj` 로부터 스레드 `Ti` 로의 방향 간선** = **할당 간선**
    - `Rj → Ti`
    - 자원 유형 `Rj` 의 한 인스턴스가 스레드 `Ti` 에 할당된 것

</br>

> **스레드 `Ti` 는 원으로 표현하고, 자원 유형 `Rj` 는 사각형으로 표현한다.**

<img width="375" alt="image" src="https://user-images.githubusercontent.com/106216912/215803603-e2885de4-f984-470b-923c-faa2fdac1feb.png">

- 자원 유형 `Rj` 가 한 개 이상의 인스턴스를 가질 때는 각 인스턴스를 사각형 내의 하나의 점으로 표시한다.
    - 할당 간선은 반드시 사각형 안의 하나의 점을 지정해야 하지만, 요청 간선은 사각형 `Rj` 만을 가리킨다.

</br>

- 스레드 `Ti` 가 자원 유형 `Rj` 의 한 인스턴스를 요청하면, 요청 간선이 자원 할당 그래프 안에 삽입된다.
    - 이 요청이 만족할 수 있으면, 요청 간선은 즉시 할당 간선으로 변환된다.
    - 스레드가 더 자원에 대한 접근을 해야 하지 않으면 자원을 방출하고, 할당 간선은 삭제된다.

</br>

> **이 자원 할당 그래프는 다음 상황을 묘사한다.**

<img width="181" alt="image" src="https://user-images.githubusercontent.com/106216912/215803772-7f3df9f5-6781-465d-8dda-429ab32c8036.png">

- **집합 `T` , `R` , `E`**
    - `T = {T1, T2, T3}`
    - `R = {R1, R2, R3, R4}`
    - `E = {T1 → R1, T2 → R3, R1 → T2, R2 → T2, R2 → T1, R3 → T3}`

</br>

- **자원의 인스턴스**
    - 자원 유형 `R1` 의 인스턴스가 한 개
    - 자원 유형 `R2` 의 인스턴스가 두 개
    - 자원 유형 `R3` 의 인스턴스가 한 개
    - 자원 유형 `R4` 의 인스턴스가 세 개

</br>

- **스레드 상태**
    - 스레드 `T1` 은 자원 유형 `R2` 의 인스턴스 한 개를 점유하고, 자원 유형 `R1` 의 인스턴스 한 개를 기다리며 대기한다.
    - 스레드 `T2` 는 `R1` 과 `R2` 의 인스턴스를 각각 한 개씩 점유하고, 자원 유형 `R3` 의 인스턴스 한 개를 기다린다.
    - 스레드 `T3` 는 `R3` 의 인스턴스 한 개를 점유하고 있다.

</br>

> **그래프가 사이클을 포함하지 않으면, 시스템 내 어느 스레드도 교착 상태가 아니라는 것을 보일 수 있다.**

- 반면, 그래프가 사이클을 포함하면 **교착 상태가 존재할 수 있다.**

</br>

> **각 자원 유형이 정확하게 하나의 인스턴스만을 가지면, 하나의 사이클은 교착 상태가 발생하였음을 암시한다.**

- 사이클이 각각 하나의 인스턴스만 갖는 자원 유형의 집합만을 포함한다면, **교착 상태가 발생**한 것이다.
- 각 자원 유형이 여러 개의 인스턴스를 가지면, 사이클이 **반드시 교착 상태가 발생했음을 의미하지는 않는다.**

</br>

> **스레드 `T3` 가 자원 유형 `R2` 의 인스턴스를 하나 요청한다고 가정한다.**

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/215804047-0006759a-5062-4607-9488-dc79a7be6c40.png">

- 사용 가능한 자원이 현재 없기 때문에, 요청 간선 `T3 → R2` 를 그래프에 추가한다.
    - 이 시점에서 시스템 내의 두 개의 최소의 사이클이 존재한다.
        - `T1 → R1 → T2 → R3 → T3 → R2 → T1`
        - `T2 → R3 → T3 → R2 → T2`

</br>

- 스레드 `T1, T2, T3` 는 교착 상태이다.
    - 스레드 `T2` 는 스레드 `T3` 이 점유하고 있는 자원 `R3` 를 기다린다.
    - 반면, 스레드 `T3` 는 스레드 `T1` 이나 `T2` 가 자원 `R2` 를 방출하기를 기다린다.
    - 스레드 `T1` 은 `T2` 가 자원 `R1` 을 방출하기를 기다린다.

</br>

<img width="208" alt="image" src="https://user-images.githubusercontent.com/106216912/215804212-0ef39ef7-bd77-426f-9cc4-9da5839a5cf2.png">

- `T1 → R1 → T3 → R2 → T1` 의 사이클을 갖는다.
    - 하지만, 교착 상태가 없다.
    - 프로세스 `T4` 가 자원 유형 `R2` 의 인스턴스를 방출할 수 있다.
    - 뒤이어 그 자원이 `T3` 에 할당될 수 있고, 사이클이 없어진다.

</br>

→ **자원 할당 그래프에 사이클이 없다면**, 시스템은 **교착 상태가 아니다.**

→ **반면, 사이클이 있다면** 시스템은 **교착 상태일 수도 있고 아닐 수도 있다.**

---

## 4. 교착 상태 처리 방법

→ ***원칙적으로 교착 상태 문제를 처리하는 데는 세 가지 다른 방법이 있다.***

1. **문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척 한다.**
    - Linux와 Windows를 포함해 대부분의 운영체제가 사용한다.

</br>

2. **시스템이 결코 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.**
    - 응용 개발자는 교착 상태를 처리하는 프로그램을 작성한다.

</br>

3. **시스템이 교착 상태가 되도록 허용한 다음에 복구한다.**
    - 데이터베이스와 같은 일부 시스템이 사용한다.

</br>

> **교착 상태가 발생하지 않도록 하기 위해, 시스템은 교착 상태 예방이나 회피 기법을 사용할 수 있다.**

- **교착 상태 예방** : 상호 배제, 점유하며 대기, 비선점, 순환 대기 중 적어도 하나가 성립하지 않도록 보장하는 방법

</br>

- **교착 상태 회피** : 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구한다.
    - 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다.

</br>

> **시스템이 교착 상태 예방이나 교착 상태 회피 알고리즘을 사용하지 않으면, 교착 상태가 발생할 수 있다.**

- 이런 환경에서 시스템은, 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 조사하는 알고리즘과 교착 상태로부터 복구하기 위한 알고리즘을 제공할 수 있다.

</br>

- 교착 상태를 탐지하고 복구하는 알고리즘이 없다면, 시스템은 교착 상태에 이를 수 있고, 발생한 것을 인식하지 못할 수 있다.
    - 이 경우, 탐지되지 않은 교착 상태는 수행할 수 없는 스레드에 의해 자원이 점유되어 있다.
    - 또한, **많은 스레드들이 이러한 자원을 요청함에 따라 계속 교착 상태로 진입하기 때문에, 시스템 성능을 저하**하게 된다.

---

## 5. 교착 상태 예방

→ ***교착 상태가 발생하려면 네 가지의 필요조건이 성립해야 한다.***

- **이들 조건 중에서 최소한 하나가 성립하지 않도록 보장**함으로써, 교착 상태의 발생을 예방할 수 있다!

</br>

### 상호 배제

→ ***적어도 하나의 자원은 공유가 불가능한 자원이어야 한다.***

- 반면, **공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 교착 상태에 관련될 수 없다.**
    - ex) 읽기-전용 파일

</br>

- 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것을 불가능하다.
    - 어떤 자원들은 근본적으로 공유가 불가능하다.
        - ex) mutex 락

</br>

### 점유하며 대기

→ ***시스템에서 점유하여 대기 조건이 발생하지 않도록 하려면, 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.***

- 우리가 사용할 수 있는 하나의 프로토콜은 **각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다.**
    - 이것은 자원 요청의 동적 특성으로 인해 대부분의 응용 프로그램에는 실용적이지 않다.

</br>

> **한 대안 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다.**

- 스레드는 일부 자원을 요청하고 사용할 수도 있다.
    - 스레드가 추가의 자원을 요청할 수 있으려면, 자신에게 할당된 모든 자원을 반드시 먼저 방출해야 한다.

</br>

→ 이 두 프로토콜은 **두 가지 주요 단점**이 존재한다.

1. 자원이 할당되었지만, 장기간 사용되지 않을 수 있기 때문에 **자원 이용률이 낮을 수 있다.**
2. **기아**가 발생할 수 있다.

</br>

### 비선점

→ ***이미 할당된 자원은 선점되지 않아야 한다.***

- 만일 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원이 선점된다.
    - 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다.

</br>

> **대안으로, 한 스레드가 어떤 자원들을 요청하면 이들이 사용 가능한지를 검사한다.**

- 만약 사용 가능하다면, 이들을 할당한다.
    - 사용 불가능하다면, 그 자원들이 추가의 자원을 위해 대기하고 있는 어떤 다른 스레드에 할당되어 있는지를 검사한다.
    - 그렇다면, 대기 중인 스레드로부터 원하는 자원을 선점해 이들을 요청하는 스레드에게 할당한다.

</br>

- 만약 자원을 이용할 수 없거나 다른 대기 스레드에 점유되어 있지 않다면, 요청 스레드는 반드시 대기해야 한다.
    - 스레드가 대기하는 동안, 그 스레드의 자원들 중 일부는 다른 스레드가 이들을 요청하는 경우에만 선점될 수 있다.
    - 스레드가 요청 중인 새로운 자원을 할당받고, 또한 대기 중에 선점되었던 모든 자원을 회복할 때만 다시 시작할 수 있다.

</br>

→ **이 프로토콜은 CPU 레지스터나 데이터베이스 트랜잭션처럼 그 상태가 쉽게 저장되고, 후에 복원될 수 있는 자원에 종종 적용**된다.

- 일반적으로 **mutex 락과 세마포에는 적용될 수 없다.**

</br>

### 순환 대기

→ ***순환 대기 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있는 기회를 제공한다.***

- 순환 대기 조건이 성립되지 않도록 하는 한 가지 방법
    - 모든 **자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것**

</br>

→ **하지만, 순서나 계층 구조를 정하는 것 자체만으로는 교착 상태를 예방할 수 없다!**

- 락이 동적으로 획득될 수 있다면 락 순서를 부여한다고 해서 교착 상태 예방을 보장하지는 않는다.

---