> **다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다.**

→ ***한 스레드가 자원을 요청했을 때, 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있다.***

- 이 때, 스레드가 **대기 상태**로 들어간다.

</br>

> **교착 상태란?**

→ ***대기 중인 스레드들이 요청한 자원들이 다른 스레드들에 의해 점유 되어 있고, 그들도 다 대기 상태에 있기 때문에 다시는 그 상태를 변경시킬 수 없는 상황***

---

## 1. 시스템 모델

→ ***시스템은 경쟁하는 스레드들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다.***

- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스들로 구성된다.
    - ex) CPU 주기, 파일, I/O 장치 등

</br>

- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다.
    - 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다.

</br>

> **스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.**

→ ***스레드는 지정된 태스크를 수행하기 위해, 필요한 만큼의 자원을 요청할 수 있다.***

- 요청된 자원의 수는 시스템에서 사용 가능한 전체 자원의 수를 초과해서는 안 된다.

</br>

> **정상적인 작동 모드하에서, 프로세스는 다음의 순서로만 자원을 사용할 수 있다.**

1. **요청** : **스레드는 자원을 요청**한다.
    - 요청이 즉시 허용되지 않으면, 요청 스레드는 자원을 얻을 때까지 대기해야 한다.

</br>

2. **사용** : **스레드는 자원에 대해 작업을 수행**할 수 있다.

</br>

3. **방출** : **스레드가 자원을 방출**한다.

</br>

→ **교착 상태** : ***한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다리는 현상***

---

## 2. 다중 스레드 응용에서의 교착 상태

→ ***먼저, POSIX mutex 락을 사용해서 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아본다.***

- `pthread_mutex_init()` 함수는 가용한 mutex를 초기화한다.
    - Mutex 락은 각각 `pthread_mutex_lock()` 과 `pthread_mutex_unlock()` 함수를 이용해서 획득되고, 방출된다.

</br>

- 한 스레드가 잠긴 mutex 락을 획득하려고 시도하면, `pthread_mutex_lock()` 함수 호출은 mutex 락의 소유주가 `pthread_mutex_unlock()` 함수를 호출할 때까지 이 스레드를 봉쇄한다.

</br>

> **두 mutex 락이 다음과 같은 코드에 의해 생성되고, 초기화된다.**

<img width="288" alt="image" src="https://user-images.githubusercontent.com/106216912/215436924-4d1e95dd-2697-4565-beaf-e76a073fe779.png">

- `thread_one` 과 `thread_two` 가 생성되고, mutex 락에 대한 접근 권한을 갖는다.
    - 두 스레드는 각각 `do_work_one()` 과 `do_work_two()` 함수를 실행한다.

</br>

- `thread_one` 은 첫 번째로 `first_mutex` , 두 번째로는 `second_mutex` 순서로 mutex 락을 획득하려고 한다.
    - 동시에 `thread_two` 는 첫 번째로 `second_mutex` , 두 번째로는 `first_mutex` 순서로 mutex 락을 획득하려 한다.

</br>

→ `thread_one` 이 `first_mutex` 를 획득하고, `thread_two` 가 `second_mutex` 를 획득하게 되면 교착 상태가 가능하다.

- 교착 상태가 가능하더라도, `thread_two` 가 락을 획득하려고 시도하기 전에 `thread_one` 이 `first_mutex` 와 `second_mutex` 를 획득하고 방출할 수 있다면, 교착 상태는 발생하지 않는다.

</br>

### 라이브락

→ ***라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다.***

- 교착 상태와 유사하게 두 개 이상의 스레드가 진행되는 것을 방해하지만, 진행할 수 없는 이유가 다르다.
    - 라이브락은 **실패한 행동을 계속해서 시도할 때 발생**한다.

</br>

> **라이브락은 `Pthreads` 의 `pthread_mutex_trylock()` 함수로 설명할 수 있다.**

→ ***이 함수는 봉쇄되지 않고, mutex 락을 획득하려고 시도한다.***

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/215437252-19431d26-62d3-463b-b94a-85f5c77f11c6.png">

- `thread_one` 이 `first_mutex` 를 획득한 후, `thread two` 가 `second_mutex` 를 획득하면 이 상황을 라이브락으로 이어질 수 있다.
    - 그런 다음 각 스레드는 `pthread_mutex_trylock()` 을 호출하여 실패하고, 각자의 락을 해제한 후 동일한 행동을 무한정 반복한다.

</br>

> **라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.**

→ ***따라서, 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.***

- 네트워크 충돌이 발생할 때, Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 패킷을 재전송하려고 시도하는 대신, 충돌한 호스트는 임의의 시간 동안 한 발 뒤로 물러선다.

</br>

→ ***라이브락은 교착 상태만큼 흔하지는 않지만, 병행 응용 프로그램을 설계할 때 어려운 문제이고, 특정 스케줄링 상황에서만 발생할 수 있다.***

---

## 3. 교착 상태 특성

→ ***교착 상태를 특징 짓는 조건을 자세히 알아본다.***

</br>

### 필요 조건들

→ ***교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.***

1. **상호 배제(mutual exclusion)**
- 최소한 하나의 자원이 비공유 모드로 점유되어야 한다.
    - 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    - 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 반드시 지연되어야 한다.

</br>

2. **점유하며 대기(hold-and-wait)**
- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.

</br>

3. **비선점(no preemption)**
- 자원들을 선점할 수 없어야 한다.
    - 즉, 자원이 강제적으로 방출될 수 없고 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.

</br>

4. **순환 대기(circular wait)**
- 대기하고 있는 스레드의 집합에서 `T0` 는 `T1` 이 점유한 자원을 대기한다.
    - 또한, `T1` 은 `T2` 가 점유한 자원을 대기하고, `Tn-1` 은 `Tn` 이 점유한 자원을 대기하며 `Tn` 은 `T0` 가 점유한 자원을 대기한다.

</br>

### 자원 할당 그래프

→ ***교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다.***

- 이 그래프는 **정점(vertex)** `V` 의 집합과 **간선(edge)** `E` 의 집합으로 구성된다.
    - 정점 `V` 의 집합은 시스템 내의 모든 활성 스레드의 집합인 `T = {T1, T2, ..., Tn}` 과 시스템 내의 모든 자원 유형의 집합인 `R = {R1, R2, ..., Rm}` 의 두 가지 유형으로 구별된다.

</br>

- **스레드 `Ti` 로부터 자원 유형 `Rj` 로의 방향 간선** = **요청 간선**
    - `Ti → Rj`
    - 스레드 `Ti` 가 자원 유형 `Rj` 의 인스턴스를 하나 요청하는 것으로, 현재 이 자원을 기다리는 상태

</br>

- **자원 유형 `Rj` 로부터 스레드 `Ti` 로의 방향 간선** = **할당 간선**
    - `Rj → Ti`
    - 자원 유형 `Rj` 의 한 인스턴스가 스레드 `Ti` 에 할당된 것

</br>

> **스레드 `Ti` 는 원으로 표현하고, 자원 유형 `Rj` 는 사각형으로 표현한다.**

<img width="375" alt="image" src="https://user-images.githubusercontent.com/106216912/215803603-e2885de4-f984-470b-923c-faa2fdac1feb.png">

- 자원 유형 `Rj` 가 한 개 이상의 인스턴스를 가질 때는 각 인스턴스를 사각형 내의 하나의 점으로 표시한다.
    - 할당 간선은 반드시 사각형 안의 하나의 점을 지정해야 하지만, 요청 간선은 사각형 `Rj` 만을 가리킨다.

</br>

- 스레드 `Ti` 가 자원 유형 `Rj` 의 한 인스턴스를 요청하면, 요청 간선이 자원 할당 그래프 안에 삽입된다.
    - 이 요청이 만족할 수 있으면, 요청 간선은 즉시 할당 간선으로 변환된다.
    - 스레드가 더 자원에 대한 접근을 해야 하지 않으면 자원을 방출하고, 할당 간선은 삭제된다.

</br>

> **이 자원 할당 그래프는 다음 상황을 묘사한다.**

<img width="181" alt="image" src="https://user-images.githubusercontent.com/106216912/215803772-7f3df9f5-6781-465d-8dda-429ab32c8036.png">

- **집합 `T` , `R` , `E`**
    - `T = {T1, T2, T3}`
    - `R = {R1, R2, R3, R4}`
    - `E = {T1 → R1, T2 → R3, R1 → T2, R2 → T2, R2 → T1, R3 → T3}`

</br>

- **자원의 인스턴스**
    - 자원 유형 `R1` 의 인스턴스가 한 개
    - 자원 유형 `R2` 의 인스턴스가 두 개
    - 자원 유형 `R3` 의 인스턴스가 한 개
    - 자원 유형 `R4` 의 인스턴스가 세 개

</br>

- **스레드 상태**
    - 스레드 `T1` 은 자원 유형 `R2` 의 인스턴스 한 개를 점유하고, 자원 유형 `R1` 의 인스턴스 한 개를 기다리며 대기한다.
    - 스레드 `T2` 는 `R1` 과 `R2` 의 인스턴스를 각각 한 개씩 점유하고, 자원 유형 `R3` 의 인스턴스 한 개를 기다린다.
    - 스레드 `T3` 는 `R3` 의 인스턴스 한 개를 점유하고 있다.

</br>

> **그래프가 사이클을 포함하지 않으면, 시스템 내 어느 스레드도 교착 상태가 아니라는 것을 보일 수 있다.**

- 반면, 그래프가 사이클을 포함하면 **교착 상태가 존재할 수 있다.**

</br>

> **각 자원 유형이 정확하게 하나의 인스턴스만을 가지면, 하나의 사이클은 교착 상태가 발생하였음을 암시한다.**

- 사이클이 각각 하나의 인스턴스만 갖는 자원 유형의 집합만을 포함한다면, **교착 상태가 발생**한 것이다.
- 각 자원 유형이 여러 개의 인스턴스를 가지면, 사이클이 **반드시 교착 상태가 발생했음을 의미하지는 않는다.**

</br>

> **스레드 `T3` 가 자원 유형 `R2` 의 인스턴스를 하나 요청한다고 가정한다.**

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/215804047-0006759a-5062-4607-9488-dc79a7be6c40.png">

- 사용 가능한 자원이 현재 없기 때문에, 요청 간선 `T3 → R2` 를 그래프에 추가한다.
    - 이 시점에서 시스템 내의 두 개의 최소의 사이클이 존재한다.
        - `T1 → R1 → T2 → R3 → T3 → R2 → T1`
        - `T2 → R3 → T3 → R2 → T2`

</br>

- 스레드 `T1, T2, T3` 는 교착 상태이다.
    - 스레드 `T2` 는 스레드 `T3` 이 점유하고 있는 자원 `R3` 를 기다린다.
    - 반면, 스레드 `T3` 는 스레드 `T1` 이나 `T2` 가 자원 `R2` 를 방출하기를 기다린다.
    - 스레드 `T1` 은 `T2` 가 자원 `R1` 을 방출하기를 기다린다.

</br>

<img width="208" alt="image" src="https://user-images.githubusercontent.com/106216912/215804212-0ef39ef7-bd77-426f-9cc4-9da5839a5cf2.png">

- `T1 → R1 → T3 → R2 → T1` 의 사이클을 갖는다.
    - 하지만, 교착 상태가 없다.
    - 프로세스 `T4` 가 자원 유형 `R2` 의 인스턴스를 방출할 수 있다.
    - 뒤이어 그 자원이 `T3` 에 할당될 수 있고, 사이클이 없어진다.

</br>

→ **자원 할당 그래프에 사이클이 없다면**, 시스템은 **교착 상태가 아니다.**

→ **반면, 사이클이 있다면** 시스템은 **교착 상태일 수도 있고 아닐 수도 있다.**

---

## 4. 교착 상태 처리 방법

→ ***원칙적으로 교착 상태 문제를 처리하는 데는 세 가지 다른 방법이 있다.***

1. **문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않는 척 한다.**
    - Linux와 Windows를 포함해 대부분의 운영체제가 사용한다.

</br>

2. **시스템이 결코 교착 상태가 되지 않도록 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.**
    - 응용 개발자는 교착 상태를 처리하는 프로그램을 작성한다.

</br>

3. **시스템이 교착 상태가 되도록 허용한 다음에 복구한다.**
    - 데이터베이스와 같은 일부 시스템이 사용한다.

</br>

> **교착 상태가 발생하지 않도록 하기 위해, 시스템은 교착 상태 예방이나 회피 기법을 사용할 수 있다.**

- **교착 상태 예방** : 상호 배제, 점유하며 대기, 비선점, 순환 대기 중 적어도 하나가 성립하지 않도록 보장하는 방법

</br>

- **교착 상태 회피** : 스레드가 평생 요구하고 사용할 자원에 대한 부가적인 정보를 미리 제공할 것을 요구한다.
    - 운영체제는 각 요청을 위해 그 스레드가 기다려야 할지 않을지를 결정할 수 있다.

</br>

> **시스템이 교착 상태 예방이나 교착 상태 회피 알고리즘을 사용하지 않으면, 교착 상태가 발생할 수 있다.**

- 이런 환경에서 시스템은, 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 조사하는 알고리즘과 교착 상태로부터 복구하기 위한 알고리즘을 제공할 수 있다.

</br>

- 교착 상태를 탐지하고 복구하는 알고리즘이 없다면, 시스템은 교착 상태에 이를 수 있고, 발생한 것을 인식하지 못할 수 있다.
    - 이 경우, 탐지되지 않은 교착 상태는 수행할 수 없는 스레드에 의해 자원이 점유되어 있다.
    - 또한, **많은 스레드들이 이러한 자원을 요청함에 따라 계속 교착 상태로 진입하기 때문에, 시스템 성능을 저하**하게 된다.

---

## 5. 교착 상태 예방

→ ***교착 상태가 발생하려면 네 가지의 필요조건이 성립해야 한다.***

- **이들 조건 중에서 최소한 하나가 성립하지 않도록 보장**함으로써, 교착 상태의 발생을 예방할 수 있다!

</br>

### 상호 배제

→ ***적어도 하나의 자원은 공유가 불가능한 자원이어야 한다.***

- 반면, **공유 가능한 자원들은 배타적인 접근을 요구하지 않으며, 교착 상태에 관련될 수 없다.**
    - ex) 읽기-전용 파일

</br>

- 일반적으로 상호 배제 조건을 거부함으로써 교착 상태를 예방하는 것을 불가능하다.
    - 어떤 자원들은 근본적으로 공유가 불가능하다.
        - ex) mutex 락

</br>

### 점유하며 대기

→ ***시스템에서 점유하여 대기 조건이 발생하지 않도록 하려면, 스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해야 한다.***

- 우리가 사용할 수 있는 하나의 프로토콜은 **각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당해야 한다.**
    - 이것은 자원 요청의 동적 특성으로 인해 대부분의 응용 프로그램에는 실용적이지 않다.

</br>

> **한 대안 프로토콜은 스레드가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 허용한다.**

- 스레드는 일부 자원을 요청하고 사용할 수도 있다.
    - 스레드가 추가의 자원을 요청할 수 있으려면, 자신에게 할당된 모든 자원을 반드시 먼저 방출해야 한다.

</br>

→ 이 두 프로토콜은 **두 가지 주요 단점**이 존재한다.

1. 자원이 할당되었지만, 장기간 사용되지 않을 수 있기 때문에 **자원 이용률이 낮을 수 있다.**
2. **기아**가 발생할 수 있다.

</br>

### 비선점

→ ***이미 할당된 자원은 선점되지 않아야 한다.***

- 만일 어떤 자원을 점유하고 있는 스레드가 즉시 할당할 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원이 선점된다.
    - 선점된 자원들은 그 스레드가 기다리고 있는 자원들의 리스트에 추가된다.

</br>

> **대안으로, 한 스레드가 어떤 자원들을 요청하면 이들이 사용 가능한지를 검사한다.**

- 만약 사용 가능하다면, 이들을 할당한다.
    - 사용 불가능하다면, 그 자원들이 추가의 자원을 위해 대기하고 있는 어떤 다른 스레드에 할당되어 있는지를 검사한다.
    - 그렇다면, 대기 중인 스레드로부터 원하는 자원을 선점해 이들을 요청하는 스레드에게 할당한다.

</br>

- 만약 자원을 이용할 수 없거나 다른 대기 스레드에 점유되어 있지 않다면, 요청 스레드는 반드시 대기해야 한다.
    - 스레드가 대기하는 동안, 그 스레드의 자원들 중 일부는 다른 스레드가 이들을 요청하는 경우에만 선점될 수 있다.
    - 스레드가 요청 중인 새로운 자원을 할당받고, 또한 대기 중에 선점되었던 모든 자원을 회복할 때만 다시 시작할 수 있다.

</br>

→ **이 프로토콜은 CPU 레지스터나 데이터베이스 트랜잭션처럼 그 상태가 쉽게 저장되고, 후에 복원될 수 있는 자원에 종종 적용**된다.

- 일반적으로 **mutex 락과 세마포에는 적용될 수 없다.**

</br>

### 순환 대기

→ ***순환 대기 조건은 필요한 조건 중 하나를 무효화하여 실용적인 해결책을 제공할 수 있는 기회를 제공한다.***

- 순환 대기 조건이 성립되지 않도록 하는 한 가지 방법
    - 모든 **자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구하는 것**

</br>

→ **하지만, 순서나 계층 구조를 정하는 것 자체만으로는 교착 상태를 예방할 수 없다!**

- 락이 동적으로 획득될 수 있다면 락 순서를 부여한다고 해서 교착 상태 예방을 보장하지는 않는다.

---

## 6. 교착 상태 회피

→ ***교착 상태 예방 알고리즘은 요청 방법에 제한을 두어 교착 상태를 예방한다.***

- 하지만 이런 방식으로 교착 상태를 예방할 때의 문제점이 존재한다.
    - **장치의 이용률이 저하되고, 시스템 총 처리율이 감소**한다.

</br>

> **교착 상태를 회피하는 다른 대안 : 자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하는 것**

- 각 스레드의 요청과 방출에 대한 완전한 순서를 파악하고 있다면, **각 요청에 대해서 교착 상태를 피하고자 스레드가 대기해야 하는지의 여부**를 결정할 수 있다!

</br>

> **이 방법을 사용하는 다양한 알고리즘들은 필요한 정보의 양과 유형에서 차이가 있다.**

→ ***가장 단순하고 제일 유용한 모델은 각 스레드가 자신이 필요로 하는 각 유형의 자원마다 최대 수를 선언하도록 요구하는 것이다.***

- 각 스레드가 요청할 각 유형의 자원의 최대 수 정보를 미리 파악할 수 있다면, 시스템이 교착 상태에 들어가지 않을 것을 보장하는 알고리즘을 만들 수 있다.
    - 교착 상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록, 자원 할당 상태를 검사한다.
    - 자원 할당 상태는 가용 자원의 수, 할당된 자원의 수, 스레드들의 최대 요구 수에 의해 정의된다.

</br>

### 안전 상태

→ ***시스템 상태가 안전하다는 말은, 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 야기시키지 않고 차례로 모두 할당해줄 수 있다는 것을 뜻한다.***

- 즉, 시스템이 **안전 순서(safe sequence)** 를 찾을 수 있다면 시스템은 안전하다.

</br>

- 스레드 순서가 안전하다 = **`Ti` 가 요청하는 자원을 시스템에 현재 남아있는 자원과 앞에서 수행을 마칠 모든 스레드 `Tj` 들이 반납하는 자원들로 만족시켜 줄 수 있다.**
    - `Ti` 가 요청할 자원들을 즉시 만족시켜줄 수 없을 것으로 판단되면, `Ti` 가 모든 `Tj` 들이 마친 후까지 기다리게 하면 된다.
    - `Ti` 는 모든 `Tj` 들이 반납한 자원들을 가지고 수행을 할 수 있게 된다.

</br>

> **시스템의 상태가 안전하다면, 교착 상태가 아니다.**

→ **반대로, 교착 상태에 있는 시스템은 불안전한 상태에 있다.**

<img width="193" alt="image" src="https://user-images.githubusercontent.com/106216912/216768604-514d81b5-b378-4e44-8f90-2e67ce8e383c.png">

- 하지만 **시스템 상태가 불안전하다고 해서 반드시 교착 상태로 간다는 것을 뜻하지는 않는다.**
    - 시스템이 안전 상태에 머무는 운영체제는 불안전 상태나 교착 상태 모두를 예방할 수 있다.
    - 하지만, 일단 불안전 상태에 들어가게 되면 운영체제는 교착 상태가 일어날 수도 있는 자원 요청을 막을 수는 없다.

</br>

> **시스템은 안전 상태에 있다가도, 불안전 상태로 전이할 수 있다.**

- 회피 알고리즘의 기본 원칙은 **시스템의 상태가 항상 안전 상태를 떠나지 않도록 고수하는 것이**다.
    - 스레드들이 자원을 요청하면, 시스템은 자원을 즉시 할당할 수 있는지, 아니면 스레드가 대기해야 하는지 결정해야 한다.

</br>

→ 이러한 방식에서는 **스레드가 요청한 자원보다 많은 양을 시스템이 보유하고 있다고 하더라도, 그 프로세스를 기다리게 하는 상황이 벌어질 수 있다!**

- 따라서 자원의 이용률은 회피를 쓰지 않을 때에 비해서 낮아진다.

</br>

### 자원 할당 그래프 알고리즘

→ ***각 자원 유형마다 단지 하나의 인스턴스를 갖는 자원 할당 시스템을 갖고 있다면, 교착 상태 회피를 위해 자원 할당 그래프의 변형을 사용할 수 있다.***

- **예약 간선(claim edge)** 라는 새로운 타입의 간선을 도입한다.
    - 예약 간선 `Ti → Rj` 는 `Ti` 가 미래에 자원 `Rj` 를 요청할 것이라는 의미이다.
    - 요청 간선과 유사하지만, 점선으로 표시한다.

</br>

> **시스템에서 자원이 반드시 예약되어야 함에 유의해야 한다.**

- 즉, **스레드 `Ti` 가 실행되기 전에 스레드의 모든 예약 간선이 자원 할당 그래프에 표시**되어야 한다.
    - 스레드 `Ti` 와 연관된 모든 간선들이 예약 간선일 때만 예약 간선 `Ti → Rj` 를 그래프에 추가하도록 허용해야 한다.

</br>

> **스레드 `Ti` 가 자원 `Rj` 를 요청한다고 가정하면, 요청 간선 `Ti → Rj` 를 할당 간선 `Rj → Ti` 로 변환해도 자원할당 그래프에 사이클을 형성하지 않을 때만 요청을 허용할 수 있다.**
> 

→ **사이클 탐지 알고리즘을 이용해 안전성을 검사한다.**

- 이 그래프에서 사이클을 탐지하는 알고리즘은 `n^2` 차수의 연산이 필요하다.

</br>

- 사이클이 없다면, 자원을 할당해도 시스템은 안전 상태가 된다.
    - 사이클이 발견되면 할당은 시스템을 불안전 상태로 만들 것이다.
    - 그러므로 스레드 `Ti` 는 자신의 요청이 충족될 때까지 반드시 대기해야 한다.

</br>

<img width="183" alt="image" src="https://user-images.githubusercontent.com/106216912/216768676-96542c10-d2af-4d93-9c0a-6c716373e0f2.png">

- `T2` 가 `R2` 를 요청한다고 가정한다.
    - `R2` 가 현재는 가용 상태지만, 이를 `T2` 에 할당할 수 없다.

</br>

<img width="200" alt="image" src="https://user-images.githubusercontent.com/106216912/216768695-9d0d8c13-841e-4087-9a24-56930fc65b40.png">

- 왜냐하면, 할당할 경우 그래프에 사이클이 생기기 때문이다.
    - **사이클 = 시스템이 불안전한 상태**

</br>

### 은행원 알고리즘

→ ***자원 할당 그래프 알고리즘은 종류마다 자원이 여러 개씩 있게 되면, 사용할 수 없다.***

- 은행원 알고리즘은 사용할 수 있지만, 효율성이 다소 떨어진다.

</br>

> **은행원 알고리즘 시스템에서는 스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원 종류마다 미리 신고해야 한다.**

→ ***스레드가 자원들을 요청하면, 시스템은 그것을 들어주었을 때 시스템이 계속 안전 상태에 머무르게 되는지 여부를 판단해야 한다.***

- 계속 안전하게 된다면 그 요청을 들어주지만, 그렇지 않다면 요청은 다른 스레드가 끝날 때까지 기다리게 된다.

</br>

> **은행원 알고리즘을 구현하려면 몇 가지 자료구조가 필요하다.**

→ ***이 자료구조들은 시스템이 자원을 할당하고 있는 상태를 나타내게 된다(n = 스레드 수, m = 자원의 종류 수).***

- `Available` : 각 종류별로 가용한 자원의 개수를 나타내는 벡터로, 크기가 `m` 이다.
- `Max` : 각 스레드가 최대로 필요로 하는 자원의 개수를 나타내는 행렬로, 크기가 `n x m` 이다.
- `Allocation` : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬로, 크기가 `n x m` 이다.
- `Need` : 각 스레드가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬로, 크기가 `n x m` 이다.

</br>

> **안전성 알고리즘(Safety Algorithm)**

→ ***시스템이 안전한지 아닌지를 알아낼 수 있는 알고리즘은 다음과 같다.***

1. `Work` 와 `Finish` 는 크기가 `m` 과 `n` 인 벡터이다.
    - `Work = Available` 로 초기 값을 주고, `i = 0, 1, ..., n-1` 에 대해서는 `Finish[i] = false` 를 초기 값으로 준다.

</br>

2. 아래 두 조건을 만족시키는 `i` 값을 찾는다.
    - `Finish[i] == false`
    - `Needi ≤ Work`
        - 그러한 `i` 값을 찾을 수 없다면 step 4로 간다.

</br>

3. `Work = Work + Allocationi` , `Finish[i] = true`
    - 2번으로 간다.

</br>

4. 모든 `i` 값에 대해 `Finish[i] == true` 이면 이 시스템은 안전 상태에 있다.

</br>

→ 이 알고리즘으로 안전 여부를 알아내는 데에는 `m x n^2` 개의 연산이 필요하다.

</br>

> **자원 요청 알고리즘(Resource-Request Algorithm)**

→ ***자원 요청이 안전하게 들어줄 수 있는지를 검사하는 알고리즘이다.***

- `Requesti` 는 스레드 `Ti` 의 요청 벡터이고, `Ti` 가 자원을 요청하게 되면 아래와 같은 조치가 취해진다.

</br>

1. 만일 `Requesti ≤ Needi` 이면 2번으로 간다.
    - 아니면 시스템에 있는 개수보다 더 많이 요청했으므로, 오류로 처리한다.

</br>

2. 만일 `Requesti ≤ Available` 이면 3번으로 간다.
    - 아니면 요청한 자원이 당장은 없으므로, `Pi` 는 기다려야 한다.

</br>

3. 마치 시스템이 `Ti` 에게 자원을 할당해주는 것처럼, 시스템 상태 정보를 아래처럼 바꾸어 본다.

<img width="242" alt="image" src="https://user-images.githubusercontent.com/106216912/216768810-04f0af58-fb39-4d8f-8ab7-8eff2e15609e.png">

- 만일 이렇게 바뀐 상태가 안전하다면 `Ti` 에 여기에 반영된 정보대로 자원을 할당해준다.
    - 하지만 새로운 상태가 불안전하다면, 위의 자원 할당 상태를 원상태로 복원되고 `Ti` 는 `Requesti` 가 만족하기까지 기다려야만 한다.

---

## 7. 교착 상태 탐지

→ ***시스템이 교착 상태 예방이나 교착 상태 방지 알고리즘을 사용하지 않는다면, 교착 상태가 발생할 수 있다.***

- 이러한 환경에서는 시스템은 다음 알고리즘들을 반드시 지원해야 한다.
    - 교착 상태가 발생했는지 결정하기 위해 시스템의 상태를 검사하는 알고리즘
    - 교착 상태로부터 회복하는 알고리즘

</br>

### 각 자원 유형이 한 개씩 있는 경우

→ ***모든 자원이 한 개의 인스턴스만 있다면, 대기 그래프(wait-for graph)라고 하는 자원 할당 그래프의 변형을 사용해 교착 상태 탐지 알고리즘을 정의할 수 있다.***

- 자원 할당 그래프로부터 자원 유형의 노드를 제거하고 적절한 간선들을 결합함으로써, 대기 그래프를 얻을 수 있다.

</br>

> **대기 그래프에서 `Ti` 에서 `Tj` 로의 간선은 프로세스 `Tj` 가 가지고 있는 자원들에 대해, 프로세스 `Ti` 가 그 자원이 필요하여 방출하기를 기다리는 것이다.**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/216770052-fbf03ccb-d6ec-4f6a-8d90-78a0c4a812e4.png">


- 간선 `Ti → Tj` 는 해당 자원 할당 그래프가 자원 `Rq` 에 대해 두 개의 간선 `Ti → Rq` 와 `Rq → Tj` 를 포함하는 경우에만 대기 그래프에 존재한다.

</br>

> **대기 그래프가 사이클을 포함하는 경우에만 시스템에 교착 상태가 존재한다.**

→ ***교착 상태를 탐지하기 위해 시스템은 대기 그래프를 유지할 필요가 있고, 주기적으로 그래프에서 사이클을 탐지하는 알고리즘을 호출한다.***

- 그래프에서 사이클을 탐지하는 알고리즘은 `O(n^2)` 의 연산을 요구한다.

</br>

### 각 유형의 자원을 여러 개 가진 경우

→ ***대기 그래프는 종류마다 자원이 여러 개씩 존재하는 상황에서는 사용할 수 없다.***

- 아래의 기법은 이러한 상황에서 교착 상태를 탐지할 수 있다.

</br>

1. `Available` : 각 종류의 자원이 현재 몇 개가 가용한지를 나타내는 벡터로, 크기가 `m` 이다.
2. `Allocation` : 각 스레드에 현재 할당된 자원의 개수를 나타내는 행렬로, 크기가 `n x m` 이다.
3. `Request` : 각 스레드가 현재 요청 중인 자원의 개수를 나타내는 행렬로, 크기가 `n x m` 이다.

</br>

> **탐지 알고리즘의 원리 : 가능한 모든 할당 순서를 조사해 보는 방식**

1. `Work` 와 `Finish` 는 크기가 `m` 과 `n` 인 벡터로, `Work = Available` 로 초기 값을 준다.
    - `i = 0, 1, ..., n-1` 에 대해서 `Allocationi ≠ 0` 이면 `Finish[i] = false` 이다.
    - 그렇지 않으면 `Finish[i] = true` 이다.

</br>

2. 아래 두 조건을 만족시키는 `i` 값을 찾는다.
    - `Finish[i] == false`
    - `Requesti ≤ Work`
        - 그러한 `i` 값을 찾을 수 없다면 4번으로 간다.

</br>

3. `Work = Work + Allocationi` , `Finish[i] = true`
    - 2번으로 간다.

</br>

4. 어떠한 `i` 값에 대해 `(0 ≤ i < n) Finish[i] == false` 이면 이 시스템은 교착 상태에 빠져 있는 것이다.
    - 그리고 `Ti` 가 교착 상태에 빠져있다.

</br>

→ 이 탐지 알고리즘을 실행하는데는 `m x n^2` 개의 연산이 필요하다.

</br>

### 탐지 알고리즘 사용

→ ***위에서 설명한 탐지 알고리즘을 언제 돌리느냐는 두 가지 관점에 달려있다.***

1. 교착 상태가 얼마나 자주 일어나는가?
2. 교착 상태가 일어나면 통상 몇 개의 스레드가 거기에 연루되는가?

</br>

→ **교착 상태가 자주 일어난다면 탐지 알고리즘도 자주 돌려야 한다.**

- **교착 상태가 된 스레드로부터 자원을 회수하기까지는 그 자원들은 아무도 못 쓰는 자원으로 교착 상태 기간 내내 묶이게 되기 때문**이다.

</br>

> **교착 상태가 일어나는 시점은 어떤 스레드가 자원을 요청했는데 그것이 즉시 만족되지 못하는 시점이다.**

- 한 극단적인 방법은 스레드의 요청이 즉시 만족하지 않을 때마다 탐지 알고리즘을 돌리는 방법이다.
    - 이처럼 하면 교착 상태에 연루된 스레드뿐 아니라, 교착 상태를 야기한 장본인 스레드도 알아낼 수 있다.

</br>

→ 하지만, **자원을 요청할 때마다 탐지 알고리즘을 호출하면 오버헤드가 너무 크다!**

- 오버헤드를 줄이는 간단한 대안 : **지정된 시간 간격**
    - ex) 한 시간에 한 번, 또는 CPU의 이용률이 40% 이하로 떨어질 때 탐지 알고리즘을 호출한다.

---