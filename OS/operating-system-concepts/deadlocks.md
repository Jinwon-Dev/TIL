> **다중 프로그래밍 환경에서는 여러 스레드가 한정된 자원을 사용하려고 서로 경쟁할 수 있다.**

→ ***한 스레드가 자원을 요청했을 때, 그 시각에 그 자원을 사용할 수 없는 상황이 발생할 수 있다.***

- 이 때, 스레드가 **대기 상태**로 들어간다.

</br>

> **교착 상태란?**

→ ***대기 중인 스레드들이 요청한 자원들이 다른 스레드들에 의해 점유 되어 있고, 그들도 다 대기 상태에 있기 때문에 다시는 그 상태를 변경시킬 수 없는 상황***

---

## 1. 시스템 모델

→ ***시스템은 경쟁하는 스레드들 사이에 분배되어야 할 유한한 수의 자원들로 구성된다.***

- 자원은 다수의 유형으로 분할되며, 각각은 동등한 다수의 인스턴스들로 구성된다.
    - ex) CPU 주기, 파일, I/O 장치 등

</br>

- 한 시스템이 4개의 CPU를 가진다면, 자원 유형 CPU는 4개의 인스턴스를 가진다.
    - 네트워크라는 자원 유형이 2개의 인스턴스를 가질 수 있다.

</br>

> **스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에는 반드시 방출해야 한다.**

→ ***스레드는 지정된 태스크를 수행하기 위해, 필요한 만큼의 자원을 요청할 수 있다.***

- 요청된 자원의 수는 시스템에서 사용 가능한 전체 자원의 수를 초과해서는 안 된다.

</br>

> **정상적인 작동 모드하에서, 프로세스는 다음의 순서로만 자원을 사용할 수 있다.**

1. **요청** : **스레드는 자원을 요청**한다.
    - 요청이 즉시 허용되지 않으면, 요청 스레드는 자원을 얻을 때까지 대기해야 한다.

</br>

2. **사용** : **스레드는 자원에 대해 작업을 수행**할 수 있다.

</br>

3. **방출** : **스레드가 자원을 방출**한다.

</br>

→ **교착 상태** : ***한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해서만 발생될 수 있는 이벤트를 기다리는 현상***

---

## 2. 다중 스레드 응용에서의 교착 상태

→ ***먼저, POSIX mutex 락을 사용해서 다중 스레드 Pthread 프로그램에서 어떻게 교착 상태가 발생할 수 있는지 알아본다.***

- `pthread_mutex_init()` 함수는 가용한 mutex를 초기화한다.
    - Mutex 락은 각각 `pthread_mutex_lock()` 과 `pthread_mutex_unlock()` 함수를 이용해서 획득되고, 방출된다.

</br>

- 한 스레드가 잠긴 mutex 락을 획득하려고 시도하면, `pthread_mutex_lock()` 함수 호출은 mutex 락의 소유주가 `pthread_mutex_unlock()` 함수를 호출할 때까지 이 스레드를 봉쇄한다.

</br>

> **두 mutex 락이 다음과 같은 코드에 의해 생성되고, 초기화된다.**

<img width="288" alt="image" src="https://user-images.githubusercontent.com/106216912/215436924-4d1e95dd-2697-4565-beaf-e76a073fe779.png">

- `thread_one` 과 `thread_two` 가 생성되고, mutex 락에 대한 접근 권한을 갖는다.
    - 두 스레드는 각각 `do_work_one()` 과 `do_work_two()` 함수를 실행한다.

</br>

- `thread_one` 은 첫 번째로 `first_mutex` , 두 번째로는 `second_mutex` 순서로 mutex 락을 획득하려고 한다.
    - 동시에 `thread_two` 는 첫 번째로 `second_mutex` , 두 번째로는 `first_mutex` 순서로 mutex 락을 획득하려 한다.

</br>

→ `thread_one` 이 `first_mutex` 를 획득하고, `thread_two` 가 `second_mutex` 를 획득하게 되면 교착 상태가 가능하다.

- 교착 상태가 가능하더라도, `thread_two` 가 락을 획득하려고 시도하기 전에 `thread_one` 이 `first_mutex` 와 `second_mutex` 를 획득하고 방출할 수 있다면, 교착 상태는 발생하지 않는다.

</br>

### 라이브락

→ ***라이브락(livelock)은 또 다른 형태의 라이브니스 장애이다.***

- 교착 상태와 유사하게 두 개 이상의 스레드가 진행되는 것을 방해하지만, 진행할 수 없는 이유가 다르다.
    - 라이브락은 **실패한 행동을 계속해서 시도할 때 발생**한다.

</br>

> **라이브락은 `Pthreads` 의 `pthread_mutex_trylock()` 함수로 설명할 수 있다.**

→ ***이 함수는 봉쇄되지 않고, mutex 락을 획득하려고 시도한다.***

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/215437252-19431d26-62d3-463b-b94a-85f5c77f11c6.png">

- `thread_one` 이 `first_mutex` 를 획득한 후, `thread two` 가 `second_mutex` 를 획득하면 이 상황을 라이브락으로 이어질 수 있다.
    - 그런 다음 각 스레드는 `pthread_mutex_trylock()` 을 호출하여 실패하고, 각자의 락을 해제한 후 동일한 행동을 무한정 반복한다.

</br>

> **라이브락은 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.**

→ ***따라서, 일반적으로 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.***

- 네트워크 충돌이 발생할 때, Ethernet 네트워크가 취하는 접근법이다.
    - 충돌이 발생한 직후에 패킷을 재전송하려고 시도하는 대신, 충돌한 호스트는 임의의 시간 동안 한 발 뒤로 물러선다.

</br>

→ ***라이브락은 교착 상태만큼 흔하지는 않지만, 병행 응용 프로그램을 설계할 때 어려운 문제이고, 특정 스케줄링 상황에서만 발생할 수 있다.***

---

## 3. 교착 상태 특성

→ ***교착 상태를 특징 짓는 조건을 자세히 알아본다.***

</br>

### 필요 조건들

→ ***교착 상태는 한 시스템에 다음 네 가지 조건이 동시에 성립될 때 발생할 수 있다.***

1. **상호 배제(mutual exclusion)**
- 최소한 하나의 자원이 비공유 모드로 점유되어야 한다.
    - 비공유 모드에서는 한 번에 한 스레드만이 그 자원을 사용할 수 있다.
    - 다른 스레드가 그 자원을 요청하면, 요청 스레드는 자원이 방출될 때까지 반드시 지연되어야 한다.

</br>

2. **점유하며 대기(hold-and-wait)**
- 스레드는 최소한 하나의 자원을 점유한 채, 현재 다른 스레드에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 한다.

</br>

3. **비선점(no preemption)**
- 자원들을 선점할 수 없어야 한다.
    - 즉, 자원이 강제적으로 방출될 수 없고 점유하고 있는 스레드가 태스크를 종료한 후 그 스레드에 의해 자발적으로만 방출될 수 있다.

</br>

4. **순환 대기(circular wait)**
- 대기하고 있는 스레드의 집합에서 `T0` 는 `T1` 이 점유한 자원을 대기한다.
    - 또한, `T1` 은 `T2` 가 점유한 자원을 대기하고, `Tn-1` 은 `Tn` 이 점유한 자원을 대기하며 `Tn` 은 `T0` 가 점유한 자원을 대기한다.

</br>

### 자원 할당 그래프

→ ***교착 상태는 시스템 자원 할당 그래프라고 하는 방향 그래프로 더욱 정확하게 기술할 수 있다.***

- 이 그래프는 **정점(vertex)** `V` 의 집합과 **간선(edge)** `E` 의 집합으로 구성된다.
    - 정점 `V` 의 집합은 시스템 내의 모든 활성 스레드의 집합인 `T = {T1, T2, ..., Tn}` 과 시스템 내의 모든 자원 유형의 집합인 `R = {R1, R2, ..., Rm}` 의 두 가지 유형으로 구별된다.

</br>

- **스레드 `Ti` 로부터 자원 유형 `Rj` 로의 방향 간선** = **요청 간선**
    - `Ti → Rj`
    - 스레드 `Ti` 가 자원 유형 `Rj` 의 인스턴스를 하나 요청하는 것으로, 현재 이 자원을 기다리는 상태

</br>

- **자원 유형 `Rj` 로부터 스레드 `Ti` 로의 방향 간선** = **할당 간선**
    - `Rj → Ti`
    - 자원 유형 `Rj` 의 한 인스턴스가 스레드 `Ti` 에 할당된 것

</br>

> **스레드 `Ti` 는 원으로 표현하고, 자원 유형 `Rj` 는 사각형으로 표현한다.**

<img width="375" alt="image" src="https://user-images.githubusercontent.com/106216912/215803603-e2885de4-f984-470b-923c-faa2fdac1feb.png">

- 자원 유형 `Rj` 가 한 개 이상의 인스턴스를 가질 때는 각 인스턴스를 사각형 내의 하나의 점으로 표시한다.
    - 할당 간선은 반드시 사각형 안의 하나의 점을 지정해야 하지만, 요청 간선은 사각형 `Rj` 만을 가리킨다.

</br>

- 스레드 `Ti` 가 자원 유형 `Rj` 의 한 인스턴스를 요청하면, 요청 간선이 자원 할당 그래프 안에 삽입된다.
    - 이 요청이 만족할 수 있으면, 요청 간선은 즉시 할당 간선으로 변환된다.
    - 스레드가 더 자원에 대한 접근을 해야 하지 않으면 자원을 방출하고, 할당 간선은 삭제된다.

</br>

> **이 자원 할당 그래프는 다음 상황을 묘사한다.**

<img width="181" alt="image" src="https://user-images.githubusercontent.com/106216912/215803772-7f3df9f5-6781-465d-8dda-429ab32c8036.png">

- **집합 `T` , `R` , `E`**
    - `T = {T1, T2, T3}`
    - `R = {R1, R2, R3, R4}`
    - `E = {T1 → R1, T2 → R3, R1 → T2, R2 → T2, R2 → T1, R3 → T3}`

</br>

- **자원의 인스턴스**
    - 자원 유형 `R1` 의 인스턴스가 한 개
    - 자원 유형 `R2` 의 인스턴스가 두 개
    - 자원 유형 `R3` 의 인스턴스가 한 개
    - 자원 유형 `R4` 의 인스턴스가 세 개

</br>

- **스레드 상태**
    - 스레드 `T1` 은 자원 유형 `R2` 의 인스턴스 한 개를 점유하고, 자원 유형 `R1` 의 인스턴스 한 개를 기다리며 대기한다.
    - 스레드 `T2` 는 `R1` 과 `R2` 의 인스턴스를 각각 한 개씩 점유하고, 자원 유형 `R3` 의 인스턴스 한 개를 기다린다.
    - 스레드 `T3` 는 `R3` 의 인스턴스 한 개를 점유하고 있다.

</br>

> **그래프가 사이클을 포함하지 않으면, 시스템 내 어느 스레드도 교착 상태가 아니라는 것을 보일 수 있다.**

- 반면, 그래프가 사이클을 포함하면 **교착 상태가 존재할 수 있다.**

</br>

> **각 자원 유형이 정확하게 하나의 인스턴스만을 가지면, 하나의 사이클은 교착 상태가 발생하였음을 암시한다.**

- 사이클이 각각 하나의 인스턴스만 갖는 자원 유형의 집합만을 포함한다면, **교착 상태가 발생**한 것이다.
- 각 자원 유형이 여러 개의 인스턴스를 가지면, 사이클이 **반드시 교착 상태가 발생했음을 의미하지는 않는다.**

</br>

> **스레드 `T3` 가 자원 유형 `R2` 의 인스턴스를 하나 요청한다고 가정한다.**

<img width="195" alt="image" src="https://user-images.githubusercontent.com/106216912/215804047-0006759a-5062-4607-9488-dc79a7be6c40.png">

- 사용 가능한 자원이 현재 없기 때문에, 요청 간선 `T3 → R2` 를 그래프에 추가한다.
    - 이 시점에서 시스템 내의 두 개의 최소의 사이클이 존재한다.
        - `T1 → R1 → T2 → R3 → T3 → R2 → T1`
        - `T2 → R3 → T3 → R2 → T2`

</br>

- 스레드 `T1, T2, T3` 는 교착 상태이다.
    - 스레드 `T2` 는 스레드 `T3` 이 점유하고 있는 자원 `R3` 를 기다린다.
    - 반면, 스레드 `T3` 는 스레드 `T1` 이나 `T2` 가 자원 `R2` 를 방출하기를 기다린다.
    - 스레드 `T1` 은 `T2` 가 자원 `R1` 을 방출하기를 기다린다.

</br>

<img width="208" alt="image" src="https://user-images.githubusercontent.com/106216912/215804212-0ef39ef7-bd77-426f-9cc4-9da5839a5cf2.png">

- `T1 → R1 → T3 → R2 → T1` 의 사이클을 갖는다.
    - 하지만, 교착 상태가 없다.
    - 프로세스 `T4` 가 자원 유형 `R2` 의 인스턴스를 방출할 수 있다.
    - 뒤이어 그 자원이 `T3` 에 할당될 수 있고, 사이클이 없어진다.

</br>

→ **자원 할당 그래프에 사이클이 없다면**, 시스템은 **교착 상태가 아니다.**

→ **반면, 사이클이 있다면** 시스템은 **교착 상태일 수도 있고 아닐 수도 있다.**

---