> **프로세스란? </br>
→ 실행 중인 프로그램으로, 시스템에서 작업의 단위이다.**

</br>

- 운영체제가 복잡해질수록, 사용자를 위한 더 많은 기능이 기대된다.
    - 운영체제의 주 목적은 사용자 프로그램을 실행하는 것이다.
    - 하지만, 운영체제는 커널 안에서 사용자 공간에서 가장 잘 할 수 있는 다양한 시스템 작업을 처리할 필요가 있다.
    
    → 하나의 시스템은 **일부는 사용자 코드, 일부는 운영체제 코드를 실행하는 프로세스의 집합체**이다.

---

## 1. 프로세스 개념

→ ***모든 CPU 활동들을 어떻게 부를 것인가 하는 의문이 생길 수 있다.***

- 초창기 컴퓨터는 작업을 실행하는 **일괄처리 시스템**이었고, 이후에는 사용자 프로그램 또는 태스크를 실행하는 **시분할 시스템**이다.

</br>

- 단일 사용자 시스템에서도 사용자는 여러 프로그램을 동시에 실행할 수 있다.
- 다중 태스킹을 지원하지 않는 임베디드 장치에서, 컴퓨터는 한 번에 하나의 프로그램만 실행할 수 있다.
    - 하지만, 운영체제는 메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.

        → **이러한 모든 활동이 프로세스이다!**

</br>

### 프로세스

→ ***비공식적으로, 프로세스란 실행 중인 프로그램이다.***

- 프로세스의 현재 활동의 상태는 **프로그램 카운터 값**과, **프로세서 레지스터의 내용**으로 나타낸다.
    - 프로세스의 메모리 배치는 **일반적으로 여러 섹션으로 구분**된다.

</br>

<img width="196" alt="image" src="https://user-images.githubusercontent.com/106216912/210125558-8a8d8566-9814-4c13-be12-b23a9ec4929f.png">

- **텍스트 섹션** : 실행 코드
- **데이터 섹션** : 전역 변수
- **힙 섹션** : 프로그램 실행 중에 동적으로 할당되는 메모리
- **스택 섹션** : 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)

</br>

> **텍스트 및 데이터 섹션의 크기는 고정되기 때문에, 프로그램 실행 시간 동안 크기가 변하지 않는다.**

- 하지만, 스택 및 힙 섹션은 **프로그램 실행 중에 동적으로 크기가 변할 수 있다!**
    - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드가 스택에 푸시된다.
    - 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
        - 힙 섹션 또한 마찬가지이다.

→ **스택 및 힙 섹션이 서로의 방향으로 커지더라도, 운영체제는 서로 겹치지 않도록 해야 한다!**

</br>

> **프로그램 그 자체는 프로세스가 아니다.**

- 프로그램은 명령어 리스트를 내용으로 가진 실행 파일과 같은 **수동적인 존재**이다.
    - 대조적으로, 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재**이다.
        - **실행 파일이 메모리에 적재될 때, 프로그램은 프로세스가 된다.**

</br>

- 두 프로세스들이 **동일한 프로그램에 연관될 수 있지만, 두 개의 별도의 실행 순서로 간주**한다.
    - ex) 동일 사용자가 프로그램의 여러 복사본을 실행하는 것
    - 각각 별도의 프로세스이며, 텍스트 섹션은 같을 수 있더라도 데이터, 힙 및 스택 섹션은 다를 수 있다.

</br>

> **프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다.**

- **Java 프로그래밍** **환경**이 좋은 예시이다.
    - 대부분의 상황에서 실행 가능한 Java 프로그램은, JVM 안에서 실행된다.
    - JVM은 적재된 Java 코드를 해석하고, 그 코드를 대신하여 원 기계어를 이용해서 프로그램을 실행한다.

</br>

### 프로세스 상태

→ ***프로세스는 실행되면서 그 상태가 변한다.***

- 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라 정의된다.

</br>

> **프로세스는 다음 상태 중 하나에 있게 된다.**

<img width="578" alt="image" src="https://user-images.githubusercontent.com/106216912/210125617-bb094a29-aac3-40dc-aae0-2b59191e51bd.png">

- **새로운(new)** : 프로세스가 생성 중이다.
- **실행(running)** : 명령어들이 실행되고 있다.
- **대기(waiting)** : 프로세스가 어떤 이벤트(입출력 완료나 신호의 수신 등)가 일어나기를 기다린다.
- **준비(ready)** : 프로세스가 처리기에 할당되기를 기다린다.
- **종료(terminated)** : 프로세스의 실행이 종료되었다.

</br>

→ **대부분의 프로세스들은 준비, 또는 대기 상태**이며, **어느 한 순간에 한 처리기에서는 오직 하나의 프로세스만이 실행**된다!

</br>

### 프로세스 제어 블록(Process Control Block)

→ ***각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.***

- 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 여러가지를 포함한다.

</br>

> **프로세스 제어 블록(Process Control Block)이 포함하는 것**

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/210125655-87023e37-d315-41e8-9d7c-94ec21b8cc2c.png">

- **프로세스 상태**
    - 상태는 새로운(new), 준비(ready), 실행(running), 대기(waiting), 정지(halted) 등이다.

</br>

- **프로그램 카운터**
    - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.

</br>

- **CPU 레지스터**
    - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보가 포함된다.
        - 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서, 이 상태 정보는 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 한다.

</br>

- **메모리 관리 정보**
    - 운영체제에 의해 사용되는 메모리 시스템에 따라, 여러 정보들을 포함한다.
        - 기준(base) 레지스터와 한계(limit) 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등

</br>

- **회계 정보**
    - CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 프로세스 번호 등을 포함한다.

</br>

- **입출력 상태 정보**
    - 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

</br>

> **요약 : 프로세스 제어 블록은 약간의 회계 데이터와, 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역할을 한다!**

</br>

### 스레드

→ ***지금까지 논의한 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이였다.***

- 단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다.
- 따라서 **사용자는 두 가지 작업을 동시에 진행할 수 없다.**

</br>

> **현대 운영체제는 프로세스 개념을 확장하여, 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.**

- 따라서, **프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용**한다.
    - **다중 처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행**될 수 있다.
    - 스레드를 지원하는 시스템에서는 PCB는 스레드에 관한 정보도 포함하도록 확장된다.

---

## 2. 프로세스 스케줄링

→ ***다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위해, 항상 어떤 프로세스가 실행되도록 하는 데 있다.***

</br>

> **시분할 시스템의 목적**

→ ***각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록, 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것***

- 따라서, **프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택**한다.

</br>

- 각 **CPU 코어는 한 번에 하나의 프로세스를 실행**할 수 있다.
    - **단일 CPU 코어 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만,**
    - **다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다.**
        - 코어보다 많은 프로세스가 있는 경우, 초과되는 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다.
        - **다중 프로그래밍 정도** : 현재 메모리에 있는 프로세스 수

</br>

> **다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면, 프로세스의 일반적인 동작을 고려해야 한다.**

→ 일반적으로 대부분의 프로세스는 I/O 바운드, CPU 바운드로 설명할 수 있다.

- **I/O 바운드 프로세스** : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
- **CPU 바운드 프로세스** : 계산에 더 많은 시간을 사용하여, I/O 요청을 자주 생성하지 않는 프로세스

</br>

### 스케줄링 큐(Scheduling Queue)

→ ***프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.***

- 이 큐는 일반적으로 **연결 리스트**로 저장된다.
    - 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장된다.
    - 또한, **각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함**된다.

</br>

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128484-b44716ea-d4c7-41d6-97f3-98ae34182aa6.png">

- 시스템에는 다른 큐도 존재한다.
    - 프로세스에 CPU 코어가 할당되면, 프로세스는 잠시 동안 실행되어 결국 종료되거나, 인터럽트 되거나, I/O 요청 같은 특정 이벤트가 발생할 때까지 기다린다.
        - **I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스**는 **대기 큐(waiting queue)** 에 삽입된다.

</br>

> **프로세스 스케줄링의 일반적인 표현은 큐잉 다이어그램이다.**

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128506-5dc5e57e-fc4b-4896-833d-9ab3c1b58e88.png">

- 새 프로세스는 처음에 **준비 큐**에 놓인다.
    - 프로세스는 실행을 위해 **선택**되거나, **디스패치** 될 때가지 기다린다.

</br>

- **프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생**할 수 있다.
    1. 프로세스가 I/O 요청을 공표한 다음, **I/O 대기 큐**에 놓일 수 있다.
    2. 프로세스는 새 자식 프로세스를 만든 다음, 자식의 종료를 기다리는 동안 **대기 큐**에 놓일 수 있다.
    3. 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되고, **준비 큐**로 돌아갈 수 있다.

</br>

→ **처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환되고, 준비 큐에 다시 들어간다.**

- **프로세스는 종료될 때가지 이 주기를 반복하고, 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환**된다.

</br>

### CPU 스케줄링(CPU Scheduling)

→ ***프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.***

> **CPU 스케줄러의 역할 : 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것**
> 
- **CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.**
    - I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다.
    - CPU 바운드 프로세스는 오랜 시간 동안 CPU 코어가 필요하지만, 스케줄러는 프로세스에게 코어를 장기간 부여할 수 없다.
    
    → **대신, 프로세스에서 CPU를 강제로 제거하고, 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다.**

</br>
    
> **일부 운영체제는 스와핑이라고 알려진 중간 형태의 스케줄링을 가지고 있다.**

- **스와핑 : 프로세스를 메모리에서 디스크로 “스왑아웃”하고 현재 상태를 저장하고, 디스크에서 메모리로 “스왑인”하여 상태를 복원할 수 있는 기법**
    - 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시킬 수 있다.
    - 일반적으로 메모리가 초과 사용되어, 가용공간을 확보해야 할 때만 필요하다.

</br>

### 문맥 교환(Context Switch)

→ ***인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어, 커널 루틴을 실행할 수 있게 한다.***

- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에, 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.

</br>

- 문맥은 프로세스의 PCB에 표현된다.
    - **문맥** : CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등

</br>

- 일반적으로 커널 모드, 사용자 모드 둘 다 **CPU의 현재 상태를 저장하는 작업을 수행**하고, 나중에 **연산을 재개하기 위해서 상태 복구 작업을 수행**한다.

</br>

> **문맥 교환(Context Switch)이란? </br>
→ CPU 코어를 다른 프로세스로 교환하기 위해 이전의 프로세스의 상태를 보관하고, 새로운 프로세스의 보관된 상태를 복구하는 작업**

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/210128553-8219d772-b594-4d34-8e7a-00baa29b5a40.png">

→ 문맥 교환이 일어나면, **커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구**한다.

- **문맥 교환 시간 동안 시스템은 유용한 일을 하지 못하기 때문에 문맥 교환 시간은 순수한 오버헤드**이다!

</br>

> **문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.**

- 또한, 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다.
- 문맥 교환 시, 현재 프로세스의 주소 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되어야 한다.
    - 주소 공간이 어떻게 보존되고, 보존을 위해 수행해야 할 작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

---

## 3. 프로세스에 대한 연산

→ ***대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 동적으로 생성되고, 제거되어야 한다.***

- 따라서, **운영체제는 프로세스 생성 및 종료를 위한 기법을 제공**해야 한다.

</br>

### 프로세스 생성

→ ***실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다.***

- **부모 프로세스** : 생성하는 프로세스
- **자식 프로세스** : 새로운 프로세스
    - 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 프로세스의 **트리**를 형성한다.

</br>

- UNIX, Linux 및 Windows와 같은 대부분의 현대 운영체제들은 유일한 **프로세스 식별자(pid)** 를 사용하여 프로세스를 구분한다.
    - 식별자는 보통 정수이다.
    - **pid는 시스템의 각 프로세스에 고유한 값을 가지도록 할당**된다.
    - 이 식별자를 통해, **커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용**된다.

</br>

<img width="531" alt="image" src="https://user-images.githubusercontent.com/106216912/210130724-5ffb8bc1-a950-4c11-86f5-fc8a01fec56a.png">

- pid가 1인 `systemd` 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고, **시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스**이다.
    - 시스템이 부팅되면 `systemd` 프로세스는 다양한 사용자 프로세스를 생성한다.

</br>

- `logind` 프로세스는 **시스템에 직접 로그인하는 클라이언트를 관리하는 책임**을 진다.
    - `sshd` 프로세스는 `ssh` 를 사용하여 **시스템에 접속하는 클라이언트의 관리를 책임**진다.

</br>

- UNIX와 Linux 시스템에서는 `ps` 명령어를 이용해서 프로세스들의 목록을 얻을 수 있다.
    - ex) `$ ps -el`

</br>

> **프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 자신의 임무를 달성하기 위해 자원이 필요하다.**

→ ***자식 프로세스는 이 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 일부만을 사용하도록 제한될 수 있다.***

- 부모 프로세스는 **자원을 분할하여 자식 프로세스에게 나누어 주거나, 같이 사용**하게 할 수 있다.
    - 일부분만 사용하도록 제한을 두어, 자식 프로세스들을 많이 생성하여 시스템을 과부하 상태로 만드는 프로세스를 방지할 수 있다.

</br>

> **프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 방법이 존재한다.**

1. **부모는 자식과 병행하게 실행을 계속**한다.
2. **부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.**

</br>

> **새로운 프로세스들의 주소 공간 측면에서 볼 때, 두 가지 가능성이 있다.**

1. **자식 프로세스는 부모 프로세스의 복사본**이다.
    - 자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.
2. **자식 프로세스가 자신에게 적재될 새로운 프로그램**을 가지고 있다.

</br>

> **UNIX 운영체제에서의 프로세스 생성**

→ **각 프로세스는 프로세스 식별자로 확인되는데, 유일한 정수이다.**

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/210130748-f204761c-0c5a-4d78-97b8-098690cdee66.png">

1. **새로운 프로세스는 `fork()` 시스템 콜로 생성된다.**
    - 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다.
    - 이 기법은 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다.

<img width="575" alt="image" src="https://user-images.githubusercontent.com/106216912/210130768-8c282439-b52f-432a-b736-ff8aad2f9016.png">

</br>

2. **두 프로세스 중 한 프로세스가 `exec()` 시스템 콜을 사용해서 자신의 메모리 공간을 새로운 프로그램으로 교체한다.**
    - 이진 파일을 메모리로 적재하고, 그 프로그램의 실행을 시작한다.

</br>

3. **자식이 실행하는 동안 할 일이 없으면, 자식이 종료될 때까지 준비 큐에서 자신을 제거하기 위해 `wait()` 시스템 콜을 한다.**

</br>

→ **자식 프로세스가 `exec()` 을 호출하지 않고 부모 프로세스의 복사본을 계속 실행하는 것을 막을 방법은 없다!**

- 부모와 자식은 같은 코드를 실행하는 병행 프로세스이다.
- 또한, 자식은 부모의 복사본이기 때문에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가지고 있다.

</br>

> **Windows 운영체제에서의 프로세스 생성**
> 
- 프로세스는 `createProcess()` 함수를 이용하여 생성된다.
    - 부모 프로세스가 새로운 자식 프로세스를 생성한다는 점에서 `fork()` 와 유사하다.
    - 하지만, 차이점이 존재한다.
        - `fork()` : **부모 프로세스로부터 주소 공간을 상속받는 자식 프로세스를 생성**하고, 매개 변수가 요구되지 않는다.
        - `createProcess()` : **자식 프로세스가 생성될 때 주소 공간에 명시된 프로그램을 적재**하고, 매개 변수가 많이 요구된다.

</br>

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/210130798-e926e0e3-c37e-495a-b80e-3ebb2acd7740.png">

- `STARTUPINFO` : 윈도우 크기와 모양 표준 입력과 출력 파일에 대한 핸들과 같은 새로운 프로세스의 특성을 지정한다.
- `PROCESS_INFORMATION` : 새로 생성된 프로세스와 스레드에 대한 핸들과 식별자들을 포함한다.

</br>

- `WaitForSingleObject()` = UNIX의 `wait()`
    - 자식 프로세스의 핸들을 전달받고, 이 프로세스가 종료되기를 기다린다.

</br>

### 프로세스 종료

→ ***프로세스가 마지막 문장의 실행을 끝내고, `exit` 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료된다.***

- 프로세스는 자신을 기다리고 있는 부모 프로세스에게 상태 값을 반환할 수 있다.
    - 프로세스의 **모든 자원이 할당 해제되고, 운영체제로 반납**된다.

</br>

> **프로세스 종료가 발생하는 다른 경우가 있다.**

- 한 프로세스는 **시스템 콜을 통해서 다른 프로세스의 종료를 유발할 수 있다.**
    - 이러한 **시스템 콜은 단지 종료될 프로세스의 부모만이 호출**할 수 있다.
    - 그렇지 않으면, **사용자 또는 오작동하는 프로세스가 다른 사용자의 프로세스를 임의로 중단**시킬 수 있다.
        - 부모가 자식을 종료시키기 위해서는 자식의 pid를 알아야 한다.

</br>

> **부모는 여러 가지 이유로 인하여 자식 중 하나의 실행을 종료할 수 있다.**

- 자식이 자신에게 할당된 자원을 초과하여 사용할 때
- 자식에게 할당된 태스크가 더 이상 필요 없을 때
- 부모가 `exit` 를 하는데, 운영체제는 부모가 `exit` 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우

</br>

→ **몇몇 시스템에서는 부모 프로세스가 종료한 이후에, 자식 프로세스가 존재할 수 없다.**

- **연쇄식 종료** : 부모 프로세스가 종료되면, 모든 자식 프로세스들도 종료되어야 한다.

</br>

> **프로세스가 종료되어도, 부모 프로세스가 `wait()` 를 호출하지 않았다면 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 남아 있게 된다.**

- **Zombie(좀비) 프로세스** : **종료되었지만 부모 프로세스가 아직 `wait()` 호출을 하지 않은 프로세스**
    - 종료하게 되면 모든 프로세스는 좀비 상태가 되지만, 아주 짧은 시간 동안만 머무른다.
    - 부모가 `wait()` 를 호출하면, 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환된다.

</br>

- **Orphan(고아) 프로세스** : **부모 프로세스가 `wait()` 를 호출하는 대신 종료하는 경우**
    - UNIX는 새로운 부모 프로세스를 `init` 프로세스로 지정하고, 주기적으로 `wait()` 를 호출해서 고아 프로세스를 종료해준다.
    - Linux는 `systemd` 이외의 프로세스가 고아 프로세스를 상속하고 종료할 수 있게 허용한다.

</br>

> **Android 프로세스 계층**

→ ***제한된 메모리와 같은 자원 제약 때문에, 모바일 운영체제는 제한된 시스템 자원을 회수하기 위해 기존 프로세스를 종료해야 할 수도 있다.***

- Android는 아무 프로세스나 종료하지 않고, **프로세스의 중요도 계층을 식별하여 중요도가 낮은 프로세스부터 종료**한다.
    1. **전경 프로세스** : 사용자가 현재 상호 작용하고 있는 응용 프로그램이고, 화면에 보이는 현재 프로세스
    2. **가시적 프로세스** : 전경에서 직접 볼 수 없지만, 전경 프로세스가 참조하는 활동을 수행하는 프로세스
    3. **서비스 프로세스** : 백그라운드 프로세스와 유사하지만, 사용자가 인지할 수 있는 활동을 수행하는 프로세스
    4. **백그라운드 프로세스** : 활동을 수행하고 있지만, 사용자가 인식하지 못하는 프로세스
    5. **빈 프로세스** : 응용 프로그램과 관련된 활성 구성요소가 없는 프로세스

---

## 4. 프로세스 간 통신

→ ***운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나, 협력적인 프로세스들일 수 있다.***

- **독립적인 프로세스** : 프로세스가 시스템에서 실행 중인 다른 프로세스들과 데이터를 공유하지 않는 프로세스
- **협력적인 프로세스** : 프로세스가 시스템에서 실행 중인 다른 프로세스들에 영향을 주고 받는 프로세스

</br>

> **프로세스 협력을 허용하는 환경을 제공하는 이유**

- **정보 공유**
    - 여러 응용 프로그램이 동일한 정보에 흥미를 느낄 수 있으므로, **정보를 병행적으로 접근할 수 있는 환경을 제공**해야 한다.

</br>

- **계산 가속화**
    - 만약 특정 태스크를 빨리 실행하고자 한다면, **작업을 서브 태스크로 나누어 각각 다른 서브태스크들과 병렬로 실행되게** 해야 한다.
    - 가속화는 여러 개의 처리 코어를 가진 경우에만 가능하다.

</br>

- **모듈성**
    - 우리는 시스템 기능을 별도의 프로세스들, 또는 스레드들로 나누어, **모듈식 형태로 시스템을 구성**하기를 원한다.

</br>

> **협력적 프로세스들은 데이터를 교환할 수 있는 프로세스 간 통신(IPC) 기법이 필요하다.**

→ ***프로세스 간 통신에는 기본적으로 공유 메모리(shared memory)와 메시지 전달(message passing)의 두 가지 모델이 존재한다.***

</br>

<img width="493" alt="image" src="https://user-images.githubusercontent.com/106216912/210131650-9b7d4514-8bdc-49cd-a444-137e3156386b.png">

- **공유 메모리 모델**
    - **협력 프로세스들에 의해 공유되는 메모리의 영역이 구축**된다.
    - **장점 : 공유 메모리 영역을 구축할 때만 시스템 콜이 필요하므로, 메시지 전달 모델보다 더 빠르다.**
    - **모든 접근은 일반적인 메모리 접근으로 취급되므로, 커널의 도움이 필요없다.**

</br>

- **메시지 전달 모델**
    - **통신이 협력 프로세스들 사이에 교환되는 메시지를 통해 이루어진다.**
    - **장점 : 충돌을 회피할 필요가 없어, 적은 양의 데이터를 교환하는 데 유용하다.**
    - **단점 : 시스템 콜을 사용하여 구현되므로, 부가적인 시간 소비 작업이 필요하다.**

</br>

→ **운영체제에서는 두 모델이 모두 통상적이며, 많은 시스템이 두 가지를 모두 구현한다!**

---

## 5. 공유 메모리 시스템에서의 프로세스 간 통신

→ ***공유 메모리를 사용하는 프로세스 간 통신에서는, 통신하는 프로세스들이 공유 메모리 영역을 구축해야 한다.***

- 공유 메모리 영역은 **공유 메모리 세그먼트를 생성하는 프로세스의 주소 공간에 위치**한다.
    - 이 공유 메모리 세그먼트를 이용해서, 통신하고자 하는 다른 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가해야 한다.

</br>

> **일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지한다.**

- 공유 메모리는 **둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 동의**해야 한다.
    - 또한, 프로세스들은 동시에 동일한 위치에 쓰지 않도록 해야한다.

</br>

> **협력하는 프로세스의 일반적인 패러다임인 생산자-소비자 문제**

- **생산자 프로세스** : 정보를 생산한다.
- **소비자 프로세스** : 정보를 소비한다.

→ **우리는 일반적으로 서버를 생산자, 클라이언트를 소비자로 생각한다.**

</br>

- 생산자-소비자 문제의 해결책은, **공유 메모리를 사용하는 것**이다.
    - 생산자와 소비자 프로세스가 병행으로 실행되게 하려면, 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 **버퍼**가 반드시 사용 가능해야 한다.

</br>

- **버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재**하게 된다.
    - 생산자가 한 항목을 생산하고, 그동안에 소비자는 다른 항목을 소비할 수 있다.
    - 생산자와 소비자가 반드시 **동기화**되어야 한다!

</br>

> **두 가지 유형의 버퍼가 사용된다.**

- **무한 버퍼**
    - 무한 버퍼의 생산자 소비자 문제에서는 **버퍼의 크기에 실질적인 한계가 없다.**
    - 생산자는 항상 새로운 항목을 생산할 수 있다

</br>

- **유한 버퍼**
    - **버퍼의 크기가 고정되어 있다고 가정**한다.
    - 버퍼가 비어 있으면 소비자는 반드시 대기해야 하고, 모든 버퍼가 채워져 있다면 생산자가 대기해야 한다.

</br>

→ **한 문제는 생산자와 소비자가 병행하게 공유 버퍼를 접근하는 상황에 대한 고려이다!**

---

## 6. 메시지 전달 시스템에서의 프로세스 간 통신

→ ***운영체제가 메시지 전달 설비를 통해 서로 협력하는 프로세스 간의 통신 수단을 제공할 수 있다.***

- 메시지 전달 방식은 **동일한 주소 공간을 공유하지 않고도 프로세스들이 통신을 하고, 그들의 동작을 동기화할 수 있도록 허용하는 기법**을 제공한다.
    - 메시지 전달 방식은 **분산 환경**에서 특히 유용하다.

</br>

> **메시지 전달 시스템은 최소한 두 가지 연산을 제공한다.**

- `send(message)`
- `receive(message)`

</br>

- 프로세스가 보낸 메시지는 **고정 길이일 수도 있고, 가변 길이일 수도** 있다.
    - **고정 길이 메시지**만 보낼 수 있다면 시스템 수준의 구현은 직선적이다.
        - 하지만, 이러한 제한은 프로그래밍 작업을 더 힘들게 한다.
    - 반면, **가변 길이 메시지**는 보다 복잡한 시스템 수준의 구현이 있어야 한다.
        - 하지만, 프로그래밍 작업은 더 간단해진다.

</br>

> **두 프로세스가 통신을 원하면, 반드시 서로 메시지를 보내고 받아야 한다.**

→ ***이들 사이에 통신 연결(Communication Link)이 설정되어야 한다.***

- 하나의 링크와 `send()` / `receive()` 연산을 논리적으로 구현하는 다수의 방법은 다음과 같다.
    - **직접 또는 간접 통신**
    - **동기식 또는 비동기식 통신**
    - **자동 또는 명시적 버퍼링**

</br>

### 명명

→ ***통신을 원하는 프로세스들은 서로를 가리킬 방법이 있어야 한다.***

- 이들은 **간접 통신**, 또는 **직접 통신**을 사용할 수 있다.

</br>

> **직접 통신에서는, 통신을 원하는 각 프로세스는 통신의 수신자 또는 송신자의 이름을 명시해야 한다.**
> 

→ 이 기법에서는 `send()` , `receive()` 프리미티브들은 다음과 같이 정의한다.

- `send(P, message)` : 프로세스 P에 메시지를 전송한다.
- `receive(Q, message)` : 프로세스 Q로부터 메시지를 수신한다.

</br>

- 이 기법에서 통신 연결은 다음의 특성을 가진다.
    - **통신을 원하는 각 프로세스의 쌍들 사이에 연결이 자동으로 구축**된다.
        - 프로세스들은 통신을 위해 상대방의 신원만 알면 된다.
    - **연결은 정확히 두 프로세스 사이에만 연결**된다.
    - **통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재**해야 한다.

</br>

- 이 기법은 주소 방식에서 **대칭성**을 보인다.
    - **송신자와 수신자 프로세스가 모두 통신하려면 상대방의 이름을 제시**해야 한다.

</br>

> **이 기법을 변형하여, 주소 지정 시에 비대칭을 사용할 수도 있다.**

→ **송신자만 수신자 이름을 지명하며, 수신자는 송신자의 이름을 제시할 필요가 없다.**

- 이 기법에서는 `send()` 와 `receive()` 프리미티브들을 다음과 같이 정의한다.
    - `send(P, message)` : 메시지를 프로세스 P에 전송한다.
    - `receive(id, message)` : 임의의 프로세스로부터 메시지를 수신한다.

</br>

→ **대칭적, 그리고 비대칭적 기법은 모두 프로세스를 지정하는 방식 때문에, 모듈성을 제한한다는 것이 단점**이다.

</br>

> **간접 통신에서 메시지들은 메일 박스, 또는 포트로 송신되고, 수신된다.**

- 각 메일 박스는 **고유의 id**를 가진다.
    - **프로세스는 다수의 상이한 메일 박스를 통해 다른 프로세스들과 통신**할 수 있다.
    - **두 프로세스들이 공유 메일 박스를 가질 때만, 이들 프로세스가 통신**할 수 있다.

</br>

- `send()` 와 `receive()` 프리미티브들은 다음과 같이 정의할 수 있다.
    - `send(A, message)` : 메시지를 메일 박스 A로 송신한다.
    - `receive(A, message)` : 메시지를 메일 박스 A로부터 수신한다.

</br>

- 이 기법에서 통신 연결은 다음의 성질을 가진다.
    - **한 쌍의 프로세스들 사이의 연결은, 이들 프로세스가 공유 메일 박스를 가질 때만 구축**된다.
    - **연결은 두 개 이상의 프로세스들과 연관될 수 있다.**
    - **통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일 박스에 대응**된다.

</br>

> **프로세스 P1, P2, P3가 모두 메일 박스 A를 공유한다고 가정하고, 프로세스 P1은 메시지를 A에 송신하고, P2, P3는 각각 A로부터 `receive()` 를 실행한다.**

→ ***어느 프로세스가 P1이 보낸 메시지를 수신할까? = 우리가 선택할 기법에 좌우된다.***

1. 하나의 링크는 최대 두 개의 프로세스와 연관되도록 허용한다.
2. 한순간에 최대로 하나의 프로세스가 `receive()` 연산을 실행하도록 허용한다.
3. 어느 프로세스가 메시지를 수신할 것인지 시스템이 임의로 선택하도록 한다.
    - 시스템이 어느 프로세스가 수신할 것인지를 선택하는 알고리즘을 정의할 수 있다.
    - 시스템은 송신자에게 수신자를 알려 줄 수 있다.

</br>

> **메일 박스는 한 프로세스, 또는 운영체제에 의해 소유될 수 있다.**

- **프로세스에 의해 소유된다면, 소유자와 메일 박스의 사용자를 구분할 수 있다.**
    - 각 메일 박스가 고유한 소유자를 가지고 있기 때문이다.

</br>

- **운영체제가 소유한 메일 박스는 자체적으로 존재**한다.
    - 독립적인 것으로, 어떤 특정한 프로세스에 예속되지 않는다.

</br>

- **운영체제는 한 프로세스에 대해 다음을 할 수 있도록 허용하는 기법을 반드시 제공**해야 한다.
    - 새로운 메일 박스를 생성한다.
    - 메일 박스를 통해 메시지를 송신하고 수신한다.
    - 메일 박스를 삭제한다.

</br>

### 동기화

→ ***프로세스 간 통신은 `send` 와 `receive` 프리미티브에 대한 호출에 의해 발생한다.***

- 메시지 전달은 **봉쇄형이거나 비봉쇄형 방식으로 전달**된다.
    - 이 두 방식은 각각 **동기식, 비동기식**이라고도 알려져 있다.

</br>

- **봉쇄형 보내기** : 송신하는 프로세스는 메시지가 수신 프로세스 또는 메일 박스에 의해 수신될 때까지 봉쇄된다.
- **비봉쇄형 보내기** : 송신하는 프로세스가 메시지를 보내고 작업을 재시작한다.
- **봉쇄형 받기** : 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다.
- **비봉쇄형 받기** : 송신하는 프로세스가 유효한 메시지 또는 널을 받는다.

</br>

> **`send()` 와 `receive()` 의 다른 조합도 가능하다.**

- `send()` 와 `receive()` 가 모두 봉쇄형일 때, 송신자와 수신자 간에 **랑데부(rendezvous)** 를 하게 된다.

</br>

### 버퍼링

→ ***통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어있고, 이러한 큐를 구현하는 방식은 세 가지가 있다.***

- **무용량(zero capacity)**
    - 큐의 최대 길이가 0이다.
    - 링크는 자체 안에 대기하는 메시지들을 가질 수 없다.
    - 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다.

</br>

- **유한 용량(bounded capacity)**
    - 큐는 유한한 길이 `n` 을 가진다.
    - 최대 `n` 개의 메시지가 그 안에 들어 있을 수 있다.
    - 새로운 메시지가 전송될 때, 큐가 꽉 차있지 않더라면, 메시지는 큐에 놓이고 송신자는 대기하지 않고 실행을 계속한다.
    - 하지만, 링크가 꽉 차있다면, 송신자는 큐 안에 공간이 이용 가능할 때까지 봉쇄되어야 한다.

</br>

- **무한 용량(unbounded capacity)**
    - 큐는 잠재적으로 무한한 길이를 가진다.
    - 메시지들이 얼마든지 큐 안에서 대기할 수 있다.
    - 송신자는 절대 봉쇄되지 않는다.

---