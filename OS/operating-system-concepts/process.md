> **프로세스란? </br>
→ 실행 중인 프로그램으로, 시스템에서 작업의 단위이다.**

</br>

- 운영체제가 복잡해질수록, 사용자를 위한 더 많은 기능이 기대된다.
    - 운영체제의 주 목적은 사용자 프로그램을 실행하는 것이다.
    - 하지만, 운영체제는 커널 안에서 사용자 공간에서 가장 잘 할 수 있는 다양한 시스템 작업을 처리할 필요가 있다.
    
    → 하나의 시스템은 **일부는 사용자 코드, 일부는 운영체제 코드를 실행하는 프로세스의 집합체**이다.

---

## 1. 프로세스 개념

→ ***모든 CPU 활동들을 어떻게 부를 것인가 하는 의문이 생길 수 있다.***

- 초창기 컴퓨터는 작업을 실행하는 **일괄처리 시스템**이었고, 이후에는 사용자 프로그램 또는 태스크를 실행하는 **시분할 시스템**이다.

</br>

- 단일 사용자 시스템에서도 사용자는 여러 프로그램을 동시에 실행할 수 있다.
- 다중 태스킹을 지원하지 않는 임베디드 장치에서, 컴퓨터는 한 번에 하나의 프로그램만 실행할 수 있다.
    - 하지만, 운영체제는 메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.

        → **이러한 모든 활동이 프로세스이다!**

</br>

### 프로세스

→ ***비공식적으로, 프로세스란 실행 중인 프로그램이다.***

- 프로세스의 현재 활동의 상태는 **프로그램 카운터 값**과, **프로세서 레지스터의 내용**으로 나타낸다.
    - 프로세스의 메모리 배치는 **일반적으로 여러 섹션으로 구분**된다.

</br>

<img width="196" alt="image" src="https://user-images.githubusercontent.com/106216912/210125558-8a8d8566-9814-4c13-be12-b23a9ec4929f.png">

- **텍스트 섹션** : 실행 코드
- **데이터 섹션** : 전역 변수
- **힙 섹션** : 프로그램 실행 중에 동적으로 할당되는 메모리
- **스택 섹션** : 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)

</br>

> **텍스트 및 데이터 섹션의 크기는 고정되기 때문에, 프로그램 실행 시간 동안 크기가 변하지 않는다.**

- 하지만, 스택 및 힙 섹션은 **프로그램 실행 중에 동적으로 크기가 변할 수 있다!**
    - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드가 스택에 푸시된다.
    - 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
        - 힙 섹션 또한 마찬가지이다.

→ **스택 및 힙 섹션이 서로의 방향으로 커지더라도, 운영체제는 서로 겹치지 않도록 해야 한다!**

</br>

> **프로그램 그 자체는 프로세스가 아니다.**

- 프로그램은 명령어 리스트를 내용으로 가진 실행 파일과 같은 **수동적인 존재**이다.
    - 대조적으로, 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재**이다.
        - **실행 파일이 메모리에 적재될 때, 프로그램은 프로세스가 된다.**

</br>

- 두 프로세스들이 **동일한 프로그램에 연관될 수 있지만, 두 개의 별도의 실행 순서로 간주**한다.
    - ex) 동일 사용자가 프로그램의 여러 복사본을 실행하는 것
    - 각각 별도의 프로세스이며, 텍스트 섹션은 같을 수 있더라도 데이터, 힙 및 스택 섹션은 다를 수 있다.

</br>

> **프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다.**

- **Java 프로그래밍** **환경**이 좋은 예시이다.
    - 대부분의 상황에서 실행 가능한 Java 프로그램은, JVM 안에서 실행된다.
    - JVM은 적재된 Java 코드를 해석하고, 그 코드를 대신하여 원 기계어를 이용해서 프로그램을 실행한다.

</br>

### 프로세스 상태

→ ***프로세스는 실행되면서 그 상태가 변한다.***

- 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라 정의된다.

</br>

> **프로세스는 다음 상태 중 하나에 있게 된다.**

<img width="578" alt="image" src="https://user-images.githubusercontent.com/106216912/210125617-bb094a29-aac3-40dc-aae0-2b59191e51bd.png">

- **새로운(new)** : 프로세스가 생성 중이다.
- **실행(running)** : 명령어들이 실행되고 있다.
- **대기(waiting)** : 프로세스가 어떤 이벤트(입출력 완료나 신호의 수신 등)가 일어나기를 기다린다.
- **준비(ready)** : 프로세스가 처리기에 할당되기를 기다린다.
- **종료(terminated)** : 프로세스의 실행이 종료되었다.

</br>

→ **대부분의 프로세스들은 준비, 또는 대기 상태**이며, **어느 한 순간에 한 처리기에서는 오직 하나의 프로세스만이 실행**된다!

</br>

### 프로세스 제어 블록(Process Control Block)

→ ***각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.***

- 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 여러가지를 포함한다.

</br>

> **프로세스 제어 블록(Process Control Block)이 포함하는 것**

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/210125655-87023e37-d315-41e8-9d7c-94ec21b8cc2c.png">

- **프로세스 상태**
    - 상태는 새로운(new), 준비(ready), 실행(running), 대기(waiting), 정지(halted) 등이다.

</br>

- **프로그램 카운터**
    - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.

</br>

- **CPU 레지스터**
    - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보가 포함된다.
        - 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서, 이 상태 정보는 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 한다.

</br>

- **메모리 관리 정보**
    - 운영체제에 의해 사용되는 메모리 시스템에 따라, 여러 정보들을 포함한다.
        - 기준(base) 레지스터와 한계(limit) 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등

</br>

- **회계 정보**
    - CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 프로세스 번호 등을 포함한다.

</br>

- **입출력 상태 정보**
    - 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

</br>

> **요약 : 프로세스 제어 블록은 약간의 회계 데이터와, 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역할을 한다!**

</br>

### 스레드

→ ***지금까지 논의한 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이였다.***

- 단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다.
- 따라서 **사용자는 두 가지 작업을 동시에 진행할 수 없다.**

</br>

> **현대 운영체제는 프로세스 개념을 확장하여, 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.**

- 따라서, **프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용**한다.
    - **다중 처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행**될 수 있다.
    - 스레드를 지원하는 시스템에서는 PCB는 스레드에 관한 정보도 포함하도록 확장된다.

---

## 2. 프로세스 스케줄링

→ ***다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위해, 항상 어떤 프로세스가 실행되도록 하는 데 있다.***

</br>

> **시분할 시스템의 목적**

→ ***각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록, 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것***

- 따라서, **프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택**한다.

</br>

- 각 **CPU 코어는 한 번에 하나의 프로세스를 실행**할 수 있다.
    - **단일 CPU 코어 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만,**
    - **다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다.**
        - 코어보다 많은 프로세스가 있는 경우, 초과되는 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다.
        - **다중 프로그래밍 정도** : 현재 메모리에 있는 프로세스 수

</br>

> **다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면, 프로세스의 일반적인 동작을 고려해야 한다.**

→ 일반적으로 대부분의 프로세스는 I/O 바운드, CPU 바운드로 설명할 수 있다.

- **I/O 바운드 프로세스** : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
- **CPU 바운드 프로세스** : 계산에 더 많은 시간을 사용하여, I/O 요청을 자주 생성하지 않는 프로세스

</br>

### 스케줄링 큐(Scheduling Queue)

→ ***프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.***

- 이 큐는 일반적으로 **연결 리스트**로 저장된다.
    - 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장된다.
    - 또한, **각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함**된다.

</br>

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128484-b44716ea-d4c7-41d6-97f3-98ae34182aa6.png">

- 시스템에는 다른 큐도 존재한다.
    - 프로세스에 CPU 코어가 할당되면, 프로세스는 잠시 동안 실행되어 결국 종료되거나, 인터럽트 되거나, I/O 요청 같은 특정 이벤트가 발생할 때까지 기다린다.
        - **I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스**는 **대기 큐(waiting queue)** 에 삽입된다.

</br>

> **프로세스 스케줄링의 일반적인 표현은 큐잉 다이어그램이다.**

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128506-5dc5e57e-fc4b-4896-833d-9ab3c1b58e88.png">

- 새 프로세스는 처음에 **준비 큐**에 놓인다.
    - 프로세스는 실행을 위해 **선택**되거나, **디스패치** 될 때가지 기다린다.

</br>

- **프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생**할 수 있다.
    1. 프로세스가 I/O 요청을 공표한 다음, **I/O 대기 큐**에 놓일 수 있다.
    2. 프로세스는 새 자식 프로세스를 만든 다음, 자식의 종료를 기다리는 동안 **대기 큐**에 놓일 수 있다.
    3. 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되고, **준비 큐**로 돌아갈 수 있다.

</br>

→ **처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환되고, 준비 큐에 다시 들어간다.**

- **프로세스는 종료될 때가지 이 주기를 반복하고, 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환**된다.

</br>

### CPU 스케줄링(CPU Scheduling)

→ ***프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.***

> **CPU 스케줄러의 역할 : 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것**
> 
- **CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.**
    - I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다.
    - CPU 바운드 프로세스는 오랜 시간 동안 CPU 코어가 필요하지만, 스케줄러는 프로세스에게 코어를 장기간 부여할 수 없다.
    
    → **대신, 프로세스에서 CPU를 강제로 제거하고, 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다.**

</br>
    
> **일부 운영체제는 스와핑이라고 알려진 중간 형태의 스케줄링을 가지고 있다.**

- **스와핑 : 프로세스를 메모리에서 디스크로 “스왑아웃”하고 현재 상태를 저장하고, 디스크에서 메모리로 “스왑인”하여 상태를 복원할 수 있는 기법**
    - 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시킬 수 있다.
    - 일반적으로 메모리가 초과 사용되어, 가용공간을 확보해야 할 때만 필요하다.

</br>

### 문맥 교환(Context Switch)

→ ***인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어, 커널 루틴을 실행할 수 있게 한다.***

- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에, 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.

</br>

- 문맥은 프로세스의 PCB에 표현된다.
    - **문맥** : CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등

</br>

- 일반적으로 커널 모드, 사용자 모드 둘 다 **CPU의 현재 상태를 저장하는 작업을 수행**하고, 나중에 **연산을 재개하기 위해서 상태 복구 작업을 수행**한다.

</br>

> **문맥 교환(Context Switch)이란? </br>
→ CPU 코어를 다른 프로세스로 교환하기 위해 이전의 프로세스의 상태를 보관하고, 새로운 프로세스의 보관된 상태를 복구하는 작업**

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/210128553-8219d772-b594-4d34-8e7a-00baa29b5a40.png">

→ 문맥 교환이 일어나면, **커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구**한다.

- **문맥 교환 시간 동안 시스템은 유용한 일을 하지 못하기 때문에 문맥 교환 시간은 순수한 오버헤드**이다!

</br>

> **문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.**

- 또한, 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다.
- 문맥 교환 시, 현재 프로세스의 주소 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되어야 한다.
    - 주소 공간이 어떻게 보존되고, 보존을 위해 수행해야 할 작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

---

## 3. 프로세스에 대한 연산

→ ***대부분 시스템 내의 프로세스들은 병행 실행될 수 있으며, 동적으로 생성되고, 제거되어야 한다.***

- 따라서, **운영체제는 프로세스 생성 및 종료를 위한 기법을 제공**해야 한다.

</br>

### 프로세스 생성

→ ***실행되는 동안 프로세스는 여러 개의 새로운 프로세스들을 생성할 수 있다.***

- **부모 프로세스** : 생성하는 프로세스
- **자식 프로세스** : 새로운 프로세스
    - 이 새로운 프로세스들은 각각 다시 다른 프로세스들을 생성할 수 있으며, 프로세스의 **트리**를 형성한다.

</br>

- UNIX, Linux 및 Windows와 같은 대부분의 현대 운영체제들은 유일한 **프로세스 식별자(pid)** 를 사용하여 프로세스를 구분한다.
    - 식별자는 보통 정수이다.
    - **pid는 시스템의 각 프로세스에 고유한 값을 가지도록 할당**된다.
    - 이 식별자를 통해, **커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용**된다.

</br>

<img width="531" alt="image" src="https://user-images.githubusercontent.com/106216912/210130724-5ffb8bc1-a950-4c11-86f5-fc8a01fec56a.png">

- pid가 1인 `systemd` 프로세스가 모든 사용자 프로세스의 루트 부모 프로세스 역할을 수행하고, **시스템이 부트될 때 생성되는 첫 번째 사용자 프로세스**이다.
    - 시스템이 부팅되면 `systemd` 프로세스는 다양한 사용자 프로세스를 생성한다.

</br>

- `logind` 프로세스는 **시스템에 직접 로그인하는 클라이언트를 관리하는 책임**을 진다.
    - `sshd` 프로세스는 `ssh` 를 사용하여 **시스템에 접속하는 클라이언트의 관리를 책임**진다.

</br>

- UNIX와 Linux 시스템에서는 `ps` 명령어를 이용해서 프로세스들의 목록을 얻을 수 있다.
    - ex) `$ ps -el`

</br>

> **프로세스가 자식 프로세스를 생성할 때, 자식 프로세스는 자신의 임무를 달성하기 위해 자원이 필요하다.**

→ ***자식 프로세스는 이 자원을 운영체제로부터 직접 얻거나, 부모 프로세스가 가진 자원의 일부만을 사용하도록 제한될 수 있다.***

- 부모 프로세스는 **자원을 분할하여 자식 프로세스에게 나누어 주거나, 같이 사용**하게 할 수 있다.
    - 일부분만 사용하도록 제한을 두어, 자식 프로세스들을 많이 생성하여 시스템을 과부하 상태로 만드는 프로세스를 방지할 수 있다.

</br>

> **프로세스가 새로운 프로세스를 생성할 때, 두 프로세스를 실행시키는 데 두 가지 방법이 존재한다.**

1. **부모는 자식과 병행하게 실행을 계속**한다.
2. **부모는 일부 또는 모든 자식이 실행을 종료할 때까지 기다린다.**

</br>

> **새로운 프로세스들의 주소 공간 측면에서 볼 때, 두 가지 가능성이 있다.**

1. **자식 프로세스는 부모 프로세스의 복사본**이다.
    - 자식 프로세스는 부모와 똑같은 프로그램과 데이터를 가진다.
2. **자식 프로세스가 자신에게 적재될 새로운 프로그램**을 가지고 있다.

</br>

> **UNIX 운영체제에서의 프로세스 생성**

→ **각 프로세스는 프로세스 식별자로 확인되는데, 유일한 정수이다.**

</br>

<img width="434" alt="image" src="https://user-images.githubusercontent.com/106216912/210130748-f204761c-0c5a-4d78-97b8-098690cdee66.png">

1. **새로운 프로세스는 `fork()` 시스템 콜로 생성된다.**
    - 새로운 프로세스는 원래 프로세스의 주소 공간의 복사본으로 구성된다.
    - 이 기법은 부모 프로세스가 쉽게 자식 프로세스와 통신할 수 있게 한다.

<img width="575" alt="image" src="https://user-images.githubusercontent.com/106216912/210130768-8c282439-b52f-432a-b736-ff8aad2f9016.png">

</br>

2. **두 프로세스 중 한 프로세스가 `exec()` 시스템 콜을 사용해서 자신의 메모리 공간을 새로운 프로그램으로 교체한다.**
    - 이진 파일을 메모리로 적재하고, 그 프로그램의 실행을 시작한다.

</br>

3. **자식이 실행하는 동안 할 일이 없으면, 자식이 종료될 때까지 준비 큐에서 자신을 제거하기 위해 `wait()` 시스템 콜을 한다.**

</br>

→ **자식 프로세스가 `exec()` 을 호출하지 않고 부모 프로세스의 복사본을 계속 실행하는 것을 막을 방법은 없다!**

- 부모와 자식은 같은 코드를 실행하는 병행 프로세스이다.
- 또한, 자식은 부모의 복사본이기 때문에 각 프로세스는 모든 데이터에 대해 자신만의 복사본을 가지고 있다.

</br>

> **Windows 운영체제에서의 프로세스 생성**
> 
- 프로세스는 `createProcess()` 함수를 이용하여 생성된다.
    - 부모 프로세스가 새로운 자식 프로세스를 생성한다는 점에서 `fork()` 와 유사하다.
    - 하지만, 차이점이 존재한다.
        - `fork()` : **부모 프로세스로부터 주소 공간을 상속받는 자식 프로세스를 생성**하고, 매개 변수가 요구되지 않는다.
        - `createProcess()` : **자식 프로세스가 생성될 때 주소 공간에 명시된 프로그램을 적재**하고, 매개 변수가 많이 요구된다.

</br>

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/210130798-e926e0e3-c37e-495a-b80e-3ebb2acd7740.png">

- `STARTUPINFO` : 윈도우 크기와 모양 표준 입력과 출력 파일에 대한 핸들과 같은 새로운 프로세스의 특성을 지정한다.
- `PROCESS_INFORMATION` : 새로 생성된 프로세스와 스레드에 대한 핸들과 식별자들을 포함한다.

</br>

- `WaitForSingleObject()` = UNIX의 `wait()`
    - 자식 프로세스의 핸들을 전달받고, 이 프로세스가 종료되기를 기다린다.

</br>

### 프로세스 종료

→ ***프로세스가 마지막 문장의 실행을 끝내고, `exit` 시스템 콜을 사용하여 운영체제에 자신의 삭제를 요청하면 종료된다.***

- 프로세스는 자신을 기다리고 있는 부모 프로세스에게 상태 값을 반환할 수 있다.
    - 프로세스의 **모든 자원이 할당 해제되고, 운영체제로 반납**된다.

</br>

> **프로세스 종료가 발생하는 다른 경우가 있다.**

- 한 프로세스는 **시스템 콜을 통해서 다른 프로세스의 종료를 유발할 수 있다.**
    - 이러한 **시스템 콜은 단지 종료될 프로세스의 부모만이 호출**할 수 있다.
    - 그렇지 않으면, **사용자 또는 오작동하는 프로세스가 다른 사용자의 프로세스를 임의로 중단**시킬 수 있다.
        - 부모가 자식을 종료시키기 위해서는 자식의 pid를 알아야 한다.

</br>

> **부모는 여러 가지 이유로 인하여 자식 중 하나의 실행을 종료할 수 있다.**

- 자식이 자신에게 할당된 자원을 초과하여 사용할 때
- 자식에게 할당된 태스크가 더 이상 필요 없을 때
- 부모가 `exit` 를 하는데, 운영체제는 부모가 `exit` 한 후에 자식이 실행을 계속하는 것을 허용하지 않는 경우

</br>

→ **몇몇 시스템에서는 부모 프로세스가 종료한 이후에, 자식 프로세스가 존재할 수 없다.**

- **연쇄식 종료** : 부모 프로세스가 종료되면, 모든 자식 프로세스들도 종료되어야 한다.

</br>

> **프로세스가 종료되어도, 부모 프로세스가 `wait()` 를 호출하지 않았다면 프로세스의 종료 상태가 저장되는 프로세스 테이블의 해당 항목은 남아 있게 된다.**

- **Zombie(좀비) 프로세스** : **종료되었지만 부모 프로세스가 아직 `wait()` 호출을 하지 않은 프로세스**
    - 종료하게 되면 모든 프로세스는 좀비 상태가 되지만, 아주 짧은 시간 동안만 머무른다.
    - 부모가 `wait()` 를 호출하면, 좀비 프로세스의 프로세스 식별자와 프로세스 테이블의 해당 항목이 운영체제에 반환된다.

</br>

- **Orphan(고아) 프로세스** : **부모 프로세스가 `wait()` 를 호출하는 대신 종료하는 경우**
    - UNIX는 새로운 부모 프로세스를 `init` 프로세스로 지정하고, 주기적으로 `wait()` 를 호출해서 고아 프로세스를 종료해준다.
    - Linux는 `systemd` 이외의 프로세스가 고아 프로세스를 상속하고 종료할 수 있게 허용한다.

</br>

> **Android 프로세스 계층**

→ ***제한된 메모리와 같은 자원 제약 때문에, 모바일 운영체제는 제한된 시스템 자원을 회수하기 위해 기존 프로세스를 종료해야 할 수도 있다.***

- Android는 아무 프로세스나 종료하지 않고, **프로세스의 중요도 계층을 식별하여 중요도가 낮은 프로세스부터 종료**한다.
    1. **전경 프로세스** : 사용자가 현재 상호 작용하고 있는 응용 프로그램이고, 화면에 보이는 현재 프로세스
    2. **가시적 프로세스** : 전경에서 직접 볼 수 없지만, 전경 프로세스가 참조하는 활동을 수행하는 프로세스
    3. **서비스 프로세스** : 백그라운드 프로세스와 유사하지만, 사용자가 인지할 수 있는 활동을 수행하는 프로세스
    4. **백그라운드 프로세스** : 활동을 수행하고 있지만, 사용자가 인식하지 못하는 프로세스
    5. **빈 프로세스** : 응용 프로그램과 관련된 활성 구성요소가 없는 프로세스

---