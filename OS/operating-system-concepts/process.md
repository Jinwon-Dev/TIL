> **프로세스란? </br>
→ 실행 중인 프로그램으로, 시스템에서 작업의 단위이다.**

</br>

- 운영체제가 복잡해질수록, 사용자를 위한 더 많은 기능이 기대된다.
    - 운영체제의 주 목적은 사용자 프로그램을 실행하는 것이다.
    - 하지만, 운영체제는 커널 안에서 사용자 공간에서 가장 잘 할 수 있는 다양한 시스템 작업을 처리할 필요가 있다.
    
    → 하나의 시스템은 **일부는 사용자 코드, 일부는 운영체제 코드를 실행하는 프로세스의 집합체**이다.

---

## 1. 프로세스 개념

→ ***모든 CPU 활동들을 어떻게 부를 것인가 하는 의문이 생길 수 있다.***

- 초창기 컴퓨터는 작업을 실행하는 **일괄처리 시스템**이었고, 이후에는 사용자 프로그램 또는 태스크를 실행하는 **시분할 시스템**이다.

</br>

- 단일 사용자 시스템에서도 사용자는 여러 프로그램을 동시에 실행할 수 있다.
- 다중 태스킹을 지원하지 않는 임베디드 장치에서, 컴퓨터는 한 번에 하나의 프로그램만 실행할 수 있다.
    - 하지만, 운영체제는 메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.

        → **이러한 모든 활동이 프로세스이다!**

</br>

### 프로세스

→ ***비공식적으로, 프로세스란 실행 중인 프로그램이다.***

- 프로세스의 현재 활동의 상태는 **프로그램 카운터 값**과, **프로세서 레지스터의 내용**으로 나타낸다.
    - 프로세스의 메모리 배치는 **일반적으로 여러 섹션으로 구분**된다.

</br>

<img width="196" alt="image" src="https://user-images.githubusercontent.com/106216912/210125558-8a8d8566-9814-4c13-be12-b23a9ec4929f.png">

- **텍스트 섹션** : 실행 코드
- **데이터 섹션** : 전역 변수
- **힙 섹션** : 프로그램 실행 중에 동적으로 할당되는 메모리
- **스택 섹션** : 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)

</br>

> **텍스트 및 데이터 섹션의 크기는 고정되기 때문에, 프로그램 실행 시간 동안 크기가 변하지 않는다.**

- 하지만, 스택 및 힙 섹션은 **프로그램 실행 중에 동적으로 크기가 변할 수 있다!**
    - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드가 스택에 푸시된다.
    - 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
        - 힙 섹션 또한 마찬가지이다.

→ **스택 및 힙 섹션이 서로의 방향으로 커지더라도, 운영체제는 서로 겹치지 않도록 해야 한다!**

</br>

> **프로그램 그 자체는 프로세스가 아니다.**

- 프로그램은 명령어 리스트를 내용으로 가진 실행 파일과 같은 **수동적인 존재**이다.
    - 대조적으로, 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재**이다.
        - **실행 파일이 메모리에 적재될 때, 프로그램은 프로세스가 된다.**

</br>

- 두 프로세스들이 **동일한 프로그램에 연관될 수 있지만, 두 개의 별도의 실행 순서로 간주**한다.
    - ex) 동일 사용자가 프로그램의 여러 복사본을 실행하는 것
    - 각각 별도의 프로세스이며, 텍스트 섹션은 같을 수 있더라도 데이터, 힙 및 스택 섹션은 다를 수 있다.

</br>

> **프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다.**

- **Java 프로그래밍** **환경**이 좋은 예시이다.
    - 대부분의 상황에서 실행 가능한 Java 프로그램은, JVM 안에서 실행된다.
    - JVM은 적재된 Java 코드를 해석하고, 그 코드를 대신하여 원 기계어를 이용해서 프로그램을 실행한다.

</br>

### 프로세스 상태

→ ***프로세스는 실행되면서 그 상태가 변한다.***

- 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라 정의된다.

</br>

> **프로세스는 다음 상태 중 하나에 있게 된다.**

<img width="578" alt="image" src="https://user-images.githubusercontent.com/106216912/210125617-bb094a29-aac3-40dc-aae0-2b59191e51bd.png">

- **새로운(new)** : 프로세스가 생성 중이다.
- **실행(running)** : 명령어들이 실행되고 있다.
- **대기(waiting)** : 프로세스가 어떤 이벤트(입출력 완료나 신호의 수신 등)가 일어나기를 기다린다.
- **준비(ready)** : 프로세스가 처리기에 할당되기를 기다린다.
- **종료(terminated)** : 프로세스의 실행이 종료되었다.

</br>

→ **대부분의 프로세스들은 준비, 또는 대기 상태**이며, **어느 한 순간에 한 처리기에서는 오직 하나의 프로세스만이 실행**된다!

</br>

### 프로세스 제어 블록(Process Control Block)

→ ***각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.***

- 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 여러가지를 포함한다.

</br>

> **프로세스 제어 블록(Process Control Block)이 포함하는 것**

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/210125655-87023e37-d315-41e8-9d7c-94ec21b8cc2c.png">

- **프로세스 상태**
    - 상태는 새로운(new), 준비(ready), 실행(running), 대기(waiting), 정지(halted) 등이다.

</br>

- **프로그램 카운터**
    - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.

</br>

- **CPU 레지스터**
    - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보가 포함된다.
        - 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서, 이 상태 정보는 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 한다.

</br>

- **메모리 관리 정보**
    - 운영체제에 의해 사용되는 메모리 시스템에 따라, 여러 정보들을 포함한다.
        - 기준(base) 레지스터와 한계(limit) 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등

</br>

- **회계 정보**
    - CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 프로세스 번호 등을 포함한다.

</br>

- **입출력 상태 정보**
    - 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

</br>

> **요약 : 프로세스 제어 블록은 약간의 회계 데이터와, 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역할을 한다!**

</br>

### 스레드

→ ***지금까지 논의한 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이였다.***

- 단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다.
- 따라서 **사용자는 두 가지 작업을 동시에 진행할 수 없다.**

</br>

> **현대 운영체제는 프로세스 개념을 확장하여, 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.**

- 따라서, **프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용**한다.
    - **다중 처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행**될 수 있다.
    - 스레드를 지원하는 시스템에서는 PCB는 스레드에 관한 정보도 포함하도록 확장된다.

---

## 2. 프로세스 스케줄링

→ ***다중 프로그래밍의 목적은 CPU 이용을 최대화하기 위해, 항상 어떤 프로세스가 실행되도록 하는 데 있다.***

</br>

> **시분할 시스템의 목적**

→ ***각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록, 프로세스들 사이에서 CPU 코어를 빈번하게 교체하는 것***

- 따라서, **프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택**한다.

</br>

- 각 **CPU 코어는 한 번에 하나의 프로세스를 실행**할 수 있다.
    - **단일 CPU 코어 시스템의 경우 한 번에 2개 이상의 프로세스가 실행될 수 없지만,**
    - **다중 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다.**
        - 코어보다 많은 프로세스가 있는 경우, 초과되는 프로세스는 코어가 사용 가능해지고 다시 스케줄 될 때까지 기다려야 한다.
        - **다중 프로그래밍 정도** : 현재 메모리에 있는 프로세스 수

</br>

> **다중 프로그래밍 및 시간 공유의 목표를 균형 있게 유지하려면, 프로세스의 일반적인 동작을 고려해야 한다.**

→ 일반적으로 대부분의 프로세스는 I/O 바운드, CPU 바운드로 설명할 수 있다.

- **I/O 바운드 프로세스** : 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
- **CPU 바운드 프로세스** : 계산에 더 많은 시간을 사용하여, I/O 요청을 자주 생성하지 않는 프로세스

</br>

### 스케줄링 큐(Scheduling Queue)

→ ***프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 기다린다.***

- 이 큐는 일반적으로 **연결 리스트**로 저장된다.
    - 준비 큐 헤더에는 리스트의 첫 번째 PCB에 대한 포인터가 저장된다.
    - 또한, **각 PCB에는 준비 큐의 다음 PCB를 가리키는 포인터 필드가 포함**된다.

</br>

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128484-b44716ea-d4c7-41d6-97f3-98ae34182aa6.png">

- 시스템에는 다른 큐도 존재한다.
    - 프로세스에 CPU 코어가 할당되면, 프로세스는 잠시 동안 실행되어 결국 종료되거나, 인터럽트 되거나, I/O 요청 같은 특정 이벤트가 발생할 때까지 기다린다.
        - **I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스**는 **대기 큐(waiting queue)** 에 삽입된다.

</br>

> **프로세스 스케줄링의 일반적인 표현은 큐잉 다이어그램이다.**

<img width="512" alt="image" src="https://user-images.githubusercontent.com/106216912/210128506-5dc5e57e-fc4b-4896-833d-9ab3c1b58e88.png">

- 새 프로세스는 처음에 **준비 큐**에 놓인다.
    - 프로세스는 실행을 위해 **선택**되거나, **디스패치** 될 때가지 기다린다.

</br>

- **프로세스에 CPU 코어가 할당되고 실행 상태가 되면, 여러 이벤트 중 하나가 발생**할 수 있다.
    1. 프로세스가 I/O 요청을 공표한 다음, **I/O 대기 큐**에 놓일 수 있다.
    2. 프로세스는 새 자식 프로세스를 만든 다음, 자식의 종료를 기다리는 동안 **대기 큐**에 놓일 수 있다.
    3. 인터럽트 또는 타임 슬라이스가 만료되어 프로세스가 코어에서 강제로 제거되고, **준비 큐**로 돌아갈 수 있다.

</br>

→ **처음 두 경우에는 프로세스가 결국 대기 상태에서 준비 상태로 전환되고, 준비 큐에 다시 들어간다.**

- **프로세스는 종료될 때가지 이 주기를 반복하고, 종료 시점에 모든 큐에서 제거되고 PCB 및 자원이 반환**된다.

</br>

### CPU 스케줄링(CPU Scheduling)

→ ***프로세스는 수명주기 동안 준비 큐와 다양한 대기 큐를 이주한다.***

> **CPU 스케줄러의 역할 : 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU 코어를 할당하는 것**
> 
- **CPU 스케줄러는 CPU를 할당하기 위한 새 프로세스를 자주 선택해야 한다.**
    - I/O 바운드 프로세스는 I/O 요청을 대기하기 전에 몇 밀리초 동안만 실행할 수 있다.
    - CPU 바운드 프로세스는 오랜 시간 동안 CPU 코어가 필요하지만, 스케줄러는 프로세스에게 코어를 장기간 부여할 수 없다.
    
    → **대신, 프로세스에서 CPU를 강제로 제거하고, 실행될 다른 프로세스를 스케줄 하도록 설계될 가능성이 높다.**

</br>
    
> **일부 운영체제는 스와핑이라고 알려진 중간 형태의 스케줄링을 가지고 있다.**

- **스와핑 : 프로세스를 메모리에서 디스크로 “스왑아웃”하고 현재 상태를 저장하고, 디스크에서 메모리로 “스왑인”하여 상태를 복원할 수 있는 기법**
    - 메모리에서 프로세스를 제거하여 다중 프로그래밍의 정도를 감소시킬 수 있다.
    - 일반적으로 메모리가 초과 사용되어, 가용공간을 확보해야 할 때만 필요하다.

</br>

### 문맥 교환(Context Switch)

→ ***인터럽트는 운영체제가 CPU 코어를 현재 작업에서 뺏어 내어, 커널 루틴을 실행할 수 있게 한다.***

- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에, 문맥을 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있다.

</br>

- 문맥은 프로세스의 PCB에 표현된다.
    - **문맥** : CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등

</br>

- 일반적으로 커널 모드, 사용자 모드 둘 다 **CPU의 현재 상태를 저장하는 작업을 수행**하고, 나중에 **연산을 재개하기 위해서 상태 복구 작업을 수행**한다.

</br>

> **문맥 교환(Context Switch)이란? </br>
→ CPU 코어를 다른 프로세스로 교환하기 위해 이전의 프로세스의 상태를 보관하고, 새로운 프로세스의 보관된 상태를 복구하는 작업**

<img width="489" alt="image" src="https://user-images.githubusercontent.com/106216912/210128553-8219d772-b594-4d34-8e7a-00baa29b5a40.png">

→ 문맥 교환이 일어나면, **커널은 과거 프로세스의 문맥을 PCB에 저장하고, 실행이 스케줄된 새로운 프로세스의 저장된 문맥을 복구**한다.

- **문맥 교환 시간 동안 시스템은 유용한 일을 하지 못하기 때문에 문맥 교환 시간은 순수한 오버헤드**이다!

</br>

> **문맥 교환 시간은 하드웨어의 지원에 크게 좌우된다.**

- 또한, 운영체제가 복잡할수록, 문맥 교환 시 해야 할 작업의 양이 더 많아진다.
- 문맥 교환 시, 현재 프로세스의 주소 공간은 다음 태스크의 공간이 사용 준비되는 동안 반드시 보존되어야 한다.
    - 주소 공간이 어떻게 보존되고, 보존을 위해 수행해야 할 작업의 양은 운영체제의 메모리 관리 기법에 따라 달라진다.

---