> **프로세스란? </br>
→ 실행 중인 프로그램으로, 시스템에서 작업의 단위이다.**

</br>

- 운영체제가 복잡해질수록, 사용자를 위한 더 많은 기능이 기대된다.
    - 운영체제의 주 목적은 사용자 프로그램을 실행하는 것이다.
    - 하지만, 운영체제는 커널 안에서 사용자 공간에서 가장 잘 할 수 있는 다양한 시스템 작업을 처리할 필요가 있다.
    
    → 하나의 시스템은 **일부는 사용자 코드, 일부는 운영체제 코드를 실행하는 프로세스의 집합체**이다.

---

## 1. 프로세스 개념

→ ***모든 CPU 활동들을 어떻게 부를 것인가 하는 의문이 생길 수 있다.***

- 초창기 컴퓨터는 작업을 실행하는 **일괄처리 시스템**이었고, 이후에는 사용자 프로그램 또는 태스크를 실행하는 **시분할 시스템**이다.

</br>

- 단일 사용자 시스템에서도 사용자는 여러 프로그램을 동시에 실행할 수 있다.
- 다중 태스킹을 지원하지 않는 임베디드 장치에서, 컴퓨터는 한 번에 하나의 프로그램만 실행할 수 있다.
    - 하지만, 운영체제는 메모리 관리와 같은 자체 프로그램된 내부 활동을 지원해야 할 수도 있다.

        → **이러한 모든 활동이 프로세스이다!**

</br>

### 프로세스

→ ***비공식적으로, 프로세스란 실행 중인 프로그램이다.***

- 프로세스의 현재 활동의 상태는 **프로그램 카운터 값**과, **프로세서 레지스터의 내용**으로 나타낸다.
    - 프로세스의 메모리 배치는 **일반적으로 여러 섹션으로 구분**된다.

</br>

<img width="196" alt="image" src="https://user-images.githubusercontent.com/106216912/210125558-8a8d8566-9814-4c13-be12-b23a9ec4929f.png">

- **텍스트 섹션** : 실행 코드
- **데이터 섹션** : 전역 변수
- **힙 섹션** : 프로그램 실행 중에 동적으로 할당되는 메모리
- **스택 섹션** : 함수를 호출할 때 임시 데이터 저장장소(함수 매개변수, 복귀 주소 및 지역 변수)

</br>

> **텍스트 및 데이터 섹션의 크기는 고정되기 때문에, 프로그램 실행 시간 동안 크기가 변하지 않는다.**

- 하지만, 스택 및 힙 섹션은 **프로그램 실행 중에 동적으로 크기가 변할 수 있다!**
    - 함수가 호출될 때마다 함수 매개변수, 지역 변수 및 복귀 주소를 포함하는 활성화 레코드가 스택에 푸시된다.
    - 함수에서 제어가 되돌아오면 스택에서 활성화 레코드가 팝 된다.
        - 힙 섹션 또한 마찬가지이다.

→ **스택 및 힙 섹션이 서로의 방향으로 커지더라도, 운영체제는 서로 겹치지 않도록 해야 한다!**

</br>

> **프로그램 그 자체는 프로세스가 아니다.**

- 프로그램은 명령어 리스트를 내용으로 가진 실행 파일과 같은 **수동적인 존재**이다.
    - 대조적으로, 프로세스는 다음에 실행할 명령어를 지정하는 프로그램 카운터와 관련 자원의 집합을 가진 **능동적인 존재**이다.
        - **실행 파일이 메모리에 적재될 때, 프로그램은 프로세스가 된다.**

</br>

- 두 프로세스들이 **동일한 프로그램에 연관될 수 있지만, 두 개의 별도의 실행 순서로 간주**한다.
    - ex) 동일 사용자가 프로그램의 여러 복사본을 실행하는 것
    - 각각 별도의 프로세스이며, 텍스트 섹션은 같을 수 있더라도 데이터, 힙 및 스택 섹션은 다를 수 있다.

</br>

> **프로세스 자체가 다른 개체를 위한 실행 환경으로 동작할 수 있다.**

- **Java 프로그래밍** **환경**이 좋은 예시이다.
    - 대부분의 상황에서 실행 가능한 Java 프로그램은, JVM 안에서 실행된다.
    - JVM은 적재된 Java 코드를 해석하고, 그 코드를 대신하여 원 기계어를 이용해서 프로그램을 실행한다.

</br>

### 프로세스 상태

→ ***프로세스는 실행되면서 그 상태가 변한다.***

- 프로세스의 상태는 부분적으로 그 프로세스의 현재의 활동에 따라 정의된다.

</br>

> **프로세스는 다음 상태 중 하나에 있게 된다.**

<img width="578" alt="image" src="https://user-images.githubusercontent.com/106216912/210125617-bb094a29-aac3-40dc-aae0-2b59191e51bd.png">

- **새로운(new)** : 프로세스가 생성 중이다.
- **실행(running)** : 명령어들이 실행되고 있다.
- **대기(waiting)** : 프로세스가 어떤 이벤트(입출력 완료나 신호의 수신 등)가 일어나기를 기다린다.
- **준비(ready)** : 프로세스가 처리기에 할당되기를 기다린다.
- **종료(terminated)** : 프로세스의 실행이 종료되었다.

</br>

→ **대부분의 프로세스들은 준비, 또는 대기 상태**이며, **어느 한 순간에 한 처리기에서는 오직 하나의 프로세스만이 실행**된다!

</br>

### 프로세스 제어 블록(Process Control Block)

→ ***각 프로세스는 운영체제에서 프로세스 제어 블록(PCB)에 의해 표현된다.***

- 프로세스 제어 블록은 특정 프로세스와 연관된 여러 정보를 수록하며, 여러가지를 포함한다.

</br>

> **프로세스 제어 블록(Process Control Block)이 포함하는 것**

<img width="150" alt="image" src="https://user-images.githubusercontent.com/106216912/210125655-87023e37-d315-41e8-9d7c-94ec21b8cc2c.png">

- **프로세스 상태**
    - 상태는 새로운(new), 준비(ready), 실행(running), 대기(waiting), 정지(halted) 등이다.

</br>

- **프로그램 카운터**
    - 프로그램 카운터는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킨다.

</br>

- **CPU 레지스터**
    - CPU 레지스터는 컴퓨터의 구조에 따라 다양한 수와 유형을 가진다.
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보가 포함된다.
        - 나중에 프로세스가 다시 스케줄 될 때 계속 올바르게 실행되도록 하기 위해서, 이 상태 정보는 프로그램 카운터와 함께 인터럽트 발생 시 저장되어야 한다.

</br>

- **메모리 관리 정보**
    - 운영체제에 의해 사용되는 메모리 시스템에 따라, 여러 정보들을 포함한다.
        - 기준(base) 레지스터와 한계(limit) 레지스터의 값, 페이지 테이블 또는 세그먼트 테이블 등

</br>

- **회계 정보**
    - CPU 사용 시간과 경과된 실시간, 시간 제한, 계정 번호, 프로세스 번호 등을 포함한다.

</br>

- **입출력 상태 정보**
    - 이 프로세스에 할당된 입출력 장치들과 열린 파일의 목록 등을 포함한다.

</br>

> **요약 : 프로세스 제어 블록은 약간의 회계 데이터와, 프로세스를 시작시키거나 다시 시작시키는 데 필요한 모든 데이터를 위한 저장소 역할을 한다!**

</br>

### 스레드

→ ***지금까지 논의한 프로세스 모델은 단일의 실행 스레드를 실행하는 프로그램이였다.***

- 단일 제어 스레드는 프로세스가 한 번에 한 가지 일만 실행하도록 허용한다.
- 따라서 **사용자는 두 가지 작업을 동시에 진행할 수 없다.**

</br>

> **현대 운영체제는 프로세스 개념을 확장하여, 한 프로세스가 다수의 실행 스레드를 가질 수 있도록 허용한다.**

- 따라서, **프로세스가 한 번에 하나 이상의 일을 수행할 수 있도록 허용**한다.
    - **다중 처리기 시스템에서 이익을 얻을 수 있는데, 여러 스레드가 병렬로 실행**될 수 있다.
    - 스레드를 지원하는 시스템에서는 PCB는 스레드에 관한 정보도 포함하도록 확장된다.

---