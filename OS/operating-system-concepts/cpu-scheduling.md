> **CPU 스케줄링(scheduling)**

→ ***다중 프로그램 운영체제의 기본으로, 운영체제는 CPU를 프로세스 간에 교환함으로써 컴퓨터를 보다 생산적으로 만든다.***

- 이번 단원에서는 기본적인 스케줄링 개념 및 여러 스케줄링 알고리즘을 학습한다!

---

## 1. 기본 개념

→ ***코어가 하나인 시스템에서는 한순간에 오직 하나의 프로세스만이 실행될 수 있다.***

- **나머지 프로세스는 CPU의 코어가 가용 상태가 되어 다시 스케줄 될 수 있을 때까지 기다려야 한다.**

</br>

> **다중 프로그래밍의 목적**

→ ***CPU 이용률을 최대화하기 위해, 항상 실행 중인 프로세스를 가지게 하는 것이다.***

- 하나의 프로세스는 어떤 입출력 요청이 완료되기를 기다려야만 실행된다.
    - 단순한 컴퓨터 시스템에서 **CPU는 놀고 있게 되고, 대기 시간은 낭비되며 유용한 작업도 수행하지 못한다.**

</br>

→ **다중 프로그래밍에서는 이러한 시간을 생산적으로 활용하려고 시도한다.**

- 다수의 프로세스를 메모리 내에 유지하고, 어떤 프로세스가 대기해야 할 경우 **운영체제는 CPU를 그 프로세스로부터 회수**한다.
    - 그 후, **다른 프로세스에 할당**한다.

</br>

> **스케줄링은 운영체제의 기본적인 기능이며, 운영체제 설계의 핵심이 된다.**

</br>

### CPU-I/O 버스트 사이클

→ ***CPU 스케줄링의 성공은 프로세스들의 다음과 같은 성질에 의해 좌우된다.***

- 프로세스 실행은 **CPU 실행과 I/O 대기의 사이클**로 구성된다.
    - 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.

</br>

- 프로세스 실행은 **CPU 버스트**로 시작된다.
    - 뒤이어 **I/O 버스트**가 발생하고, 또 다른 CPU 버스트가 발생하며, 이어서 또 다른 I/O 버스트 등등으로 진행된다.
    - 마지막 CPU 버스트는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

<img width="263" alt="image" src="https://user-images.githubusercontent.com/106216912/211205048-fababfcf-e7d2-41b8-950f-6cda0d23e346.png">

</br>

> **CPU 버스트들의 지속 시간은 컴퓨터 마다 변화가 크지만, 다음 그림과 유사한 빈도수 곡선을 갖는 경향이 있다.**

<img width="476" alt="image" src="https://user-images.githubusercontent.com/106216912/211205081-16f56b39-8c8d-41d2-90c4-f19852ebf073.png">

- 짧은 CPU 버스트가 많고, 긴 CPU 버스트는 적다.
- 입출력 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가질 것이고, CPU 지향 프로그램은 다수의 긴 CPU 버스트를 가질 수 있다.

</br>

### CPU 스케줄러

→ ***CPU가 쉬는 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중에서 하나를 선택해 실행해야 한다.***

- 선택 절차는 **CPU 스케줄러에 의해 수행**된다.
- 스케줄러는 **실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택해서, 이들 중 하나에게 CPU를 할당**한다.

</br>

> **준비 큐는 반드시 선입선출(FIFO) 방식의 큐는 아니다!**

- 준비 큐는 선입 선출 큐, 우선순위 큐, 트리, 연결 리스트 등으로 구현할 수 있다.
- 큐에 있는 레코드들은 일반적으로 프로세스들의 **프로세스 제어 블록(PCB)** 들이다.

</br>

### 선점 및 비선점 스케줄링

→ ***CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다.***

<img width="488" alt="image" src="https://user-images.githubusercontent.com/106216912/211205153-78eb929a-56da-46fb-ad55-3240868838b0.png">

1. **한 프로세스가 실행 상태에서 대기 상태로 전환될 때**
2. **프로세스가 실행 상태에서 준비 완료 상태로 전환될 때**
3. **프로세스가 대기 상태에서 준비 완료 상태로 전환될 때**
4. **프로세스가 종료할 때**

</br>

→ 상황 1과 4의 경우에는 **스케줄링 면에서 선택의 여지가 없고, 실행을 위해 새로운 프로세스가 반드시 선택되어야 한다.**

- 하지만, 상황 2와 3에서는 선택의 여지가 있다.

</br>

> **상황 1과 4에서만 스케줄링이 발생할 경우, 이러한 스케줄링 방법을 비선점 또는 협조적이라고 한다.**

→ 그렇지 않은 경우는, **선점**이라고 한다.

</br>

- **비선점 스케줄링**
    - CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.

</br>

- **선점 스케줄링**
    - 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.
    - 데이터가 다수의 프로세스에 의해 공유될 때, 경쟁 조건을 초래할 수 있다.
    - 운영체제 커널 설계에 영향을 준다.

</br>

> **운영체제 커널은 선점, 또는 비선점 방식으로 설계될 수 있다.**

- **비선점형 커널**
    - 문맥 교환을 하기 전에, 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄되기를 기다린다.
    - 커널이 프로세스를 선점하지 않기 때문에, 커널 구조가 단순하다.
    - 주어진 시간 안에 태스크의 실행이 완료되어야 하는 실시간 컴퓨팅에서는 좋은 모델이 아니다.

</br>

- **선점형 커널**
    - 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해, mutex 락 같은 기법이 필요하다.

</br>

→ **인터럽트는 언제든지 일어날 수 있고, 항상 무시될 수는 없기 때문에 반드시 동시 사용으로부터 보호되어야 한다!**

</br>

### 디스패처

→ ***CPU 스케줄링 기능에 포함된 또 하나의 요소는 디스패처(dispatcher)이다.***

- **디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈**로, 다음과 같은 작업을 포함한다.
    - 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
    - 사용자 모드로 전환하는 일
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일

</br>

> **디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 한 빨리 수행되어야 한다.**

<img width="206" alt="image" src="https://user-images.githubusercontent.com/106216912/211205253-1dc5a5af-eb77-4269-b4c8-7192b0c8f241.png">

→ **디스패치 지연(dispatch latency)** : **디스패처가 하나의 프로세스를 정지하고, 다른 프로세스의 수행을 시작하는데까지 소요되는 시간**

</br>

> **자발적 문맥 교환과 비자발적 문맥 교환의 차이점**

- **자발적 문맥 교환** : 현재 사용 불가능한 자원을 요청했기 때문에, 프로세스가 CPU 제어를 포기한 경우 발생
- **비자발적 문맥 교환** : 타임 슬라이스가 만료되었거나, 우선순위가 더 높은 프로세스에 의해 선점된 경우와 같이 CPU를 빼앗겼을 때 발생

---