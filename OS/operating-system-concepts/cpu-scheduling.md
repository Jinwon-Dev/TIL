> **CPU 스케줄링(scheduling)**

→ ***다중 프로그램 운영체제의 기본으로, 운영체제는 CPU를 프로세스 간에 교환함으로써 컴퓨터를 보다 생산적으로 만든다.***

- 이번 단원에서는 기본적인 스케줄링 개념 및 여러 스케줄링 알고리즘을 학습한다!

---

## 1. 기본 개념

→ ***코어가 하나인 시스템에서는 한순간에 오직 하나의 프로세스만이 실행될 수 있다.***

- **나머지 프로세스는 CPU의 코어가 가용 상태가 되어 다시 스케줄 될 수 있을 때까지 기다려야 한다.**

</br>

> **다중 프로그래밍의 목적**

→ ***CPU 이용률을 최대화하기 위해, 항상 실행 중인 프로세스를 가지게 하는 것이다.***

- 하나의 프로세스는 어떤 입출력 요청이 완료되기를 기다려야만 실행된다.
    - 단순한 컴퓨터 시스템에서 **CPU는 놀고 있게 되고, 대기 시간은 낭비되며 유용한 작업도 수행하지 못한다.**

</br>

→ **다중 프로그래밍에서는 이러한 시간을 생산적으로 활용하려고 시도한다.**

- 다수의 프로세스를 메모리 내에 유지하고, 어떤 프로세스가 대기해야 할 경우 **운영체제는 CPU를 그 프로세스로부터 회수**한다.
    - 그 후, **다른 프로세스에 할당**한다.

</br>

> **스케줄링은 운영체제의 기본적인 기능이며, 운영체제 설계의 핵심이 된다.**

</br>

### CPU-I/O 버스트 사이클

→ ***CPU 스케줄링의 성공은 프로세스들의 다음과 같은 성질에 의해 좌우된다.***

- 프로세스 실행은 **CPU 실행과 I/O 대기의 사이클**로 구성된다.
    - 프로세스들은 이들 두 상태 사이를 교대로 왔다 갔다 한다.

</br>

- 프로세스 실행은 **CPU 버스트**로 시작된다.
    - 뒤이어 **I/O 버스트**가 발생하고, 또 다른 CPU 버스트가 발생하며, 이어서 또 다른 I/O 버스트 등등으로 진행된다.
    - 마지막 CPU 버스트는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

<img width="263" alt="image" src="https://user-images.githubusercontent.com/106216912/211205048-fababfcf-e7d2-41b8-950f-6cda0d23e346.png">

</br>

> **CPU 버스트들의 지속 시간은 컴퓨터 마다 변화가 크지만, 다음 그림과 유사한 빈도수 곡선을 갖는 경향이 있다.**

<img width="476" alt="image" src="https://user-images.githubusercontent.com/106216912/211205081-16f56b39-8c8d-41d2-90c4-f19852ebf073.png">

- 짧은 CPU 버스트가 많고, 긴 CPU 버스트는 적다.
- 입출력 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가질 것이고, CPU 지향 프로그램은 다수의 긴 CPU 버스트를 가질 수 있다.

</br>

### CPU 스케줄러

→ ***CPU가 쉬는 상태가 될 때마다, 운영체제는 준비 큐에 있는 프로세스 중에서 하나를 선택해 실행해야 한다.***

- 선택 절차는 **CPU 스케줄러에 의해 수행**된다.
- 스케줄러는 **실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택해서, 이들 중 하나에게 CPU를 할당**한다.

</br>

> **준비 큐는 반드시 선입선출(FIFO) 방식의 큐는 아니다!**

- 준비 큐는 선입 선출 큐, 우선순위 큐, 트리, 연결 리스트 등으로 구현할 수 있다.
- 큐에 있는 레코드들은 일반적으로 프로세스들의 **프로세스 제어 블록(PCB)** 들이다.

</br>

### 선점 및 비선점 스케줄링

→ ***CPU 스케줄링 결정은 다음의 네 가지 상황에서 발생할 수 있다.***

<img width="488" alt="image" src="https://user-images.githubusercontent.com/106216912/211205153-78eb929a-56da-46fb-ad55-3240868838b0.png">

1. **한 프로세스가 실행 상태에서 대기 상태로 전환될 때**
2. **프로세스가 실행 상태에서 준비 완료 상태로 전환될 때**
3. **프로세스가 대기 상태에서 준비 완료 상태로 전환될 때**
4. **프로세스가 종료할 때**

</br>

→ 상황 1과 4의 경우에는 **스케줄링 면에서 선택의 여지가 없고, 실행을 위해 새로운 프로세스가 반드시 선택되어야 한다.**

- 하지만, 상황 2와 3에서는 선택의 여지가 있다.

</br>

> **상황 1과 4에서만 스케줄링이 발생할 경우, 이러한 스케줄링 방법을 비선점 또는 협조적이라고 한다.**

→ 그렇지 않은 경우는, **선점**이라고 한다.

</br>

- **비선점 스케줄링**
    - CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.

</br>

- **선점 스케줄링**
    - 거의 모든 최신 운영체제들은 선점 스케줄링 알고리즘을 사용한다.
    - 데이터가 다수의 프로세스에 의해 공유될 때, 경쟁 조건을 초래할 수 있다.
    - 운영체제 커널 설계에 영향을 준다.

</br>

> **운영체제 커널은 선점, 또는 비선점 방식으로 설계될 수 있다.**

- **비선점형 커널**
    - 문맥 교환을 하기 전에, 시스템 콜이 완료되거나 입출력 완료를 기다리며 프로세스가 봉쇄되기를 기다린다.
    - 커널이 프로세스를 선점하지 않기 때문에, 커널 구조가 단순하다.
    - 주어진 시간 안에 태스크의 실행이 완료되어야 하는 실시간 컴퓨팅에서는 좋은 모델이 아니다.

</br>

- **선점형 커널**
    - 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해, mutex 락 같은 기법이 필요하다.

</br>

→ **인터럽트는 언제든지 일어날 수 있고, 항상 무시될 수는 없기 때문에 반드시 동시 사용으로부터 보호되어야 한다!**

</br>

### 디스패처

→ ***CPU 스케줄링 기능에 포함된 또 하나의 요소는 디스패처(dispatcher)이다.***

- **디스패처는 CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈**로, 다음과 같은 작업을 포함한다.
    - 한 프로세스에서 다른 프로세스로 문맥을 교환하는 일
    - 사용자 모드로 전환하는 일
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동하는 일

</br>

> **디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 한 빨리 수행되어야 한다.**

<img width="206" alt="image" src="https://user-images.githubusercontent.com/106216912/211205253-1dc5a5af-eb77-4269-b4c8-7192b0c8f241.png">

→ **디스패치 지연(dispatch latency)** : **디스패처가 하나의 프로세스를 정지하고, 다른 프로세스의 수행을 시작하는데까지 소요되는 시간**

</br>

> **자발적 문맥 교환과 비자발적 문맥 교환의 차이점**

- **자발적 문맥 교환** : 현재 사용 불가능한 자원을 요청했기 때문에, 프로세스가 CPU 제어를 포기한 경우 발생
- **비자발적 문맥 교환** : 타임 슬라이스가 만료되었거나, 우선순위가 더 높은 프로세스에 의해 선점된 경우와 같이 CPU를 빼앗겼을 때 발생

---

## 2. 스케줄링 기준

→ ***서로 다른 CPU 스케줄링 알고리즘들은 다른 특성을 갖고 있다.***

- 어떠한 알고리즘을 선택하려면, 다양한 알고리즘들의 서로 다른 특성을 고려해야 한다.

</br>

> **CPU 스케줄링 알고리즘을 비교하기 위한 여러 기준**

- **CPU 이용률(utilization)**
    - 우리는 가능한 한 CPU를 최대한 바쁘게 유지하기를 원한다.

</br>

- **처리량(throughput)**
    - **단위 시간당 완료된 프로세스의 개수**이다.

</br>

- **총처리 시간(turnaround time)**
    - 프로세스의 제출 시간과 완료 시간의 간격이다.
    - **준비 큐에서 대기한 시간 + CPU에서 실행하는 시간 + I/O 시간**

</br>

- **대기 시간(waiting time)**
    - **준비 큐에서 대기하면서 보낸 시간의 합**
    - 스케줄링 알고리즘은 프로세스가 준비 큐에서 대기하는 시간의 양에만 영향을 준다.

</br>

- **응답 시간(response time)**
    - **요구를 제출한 후, 첫 번째 응답이 나올 때까지의 시간**
    - 응답이 시작되는 데까지의 시간이고, 응답을 출력하는 데 걸리는 시간은 아니다.

</br>

> **CPU 이용률과 처리량은 최대화하고, 총처리 시간, 대기 시간, 응답 시간은 최소화하는 것이 바람직하다!**

- 대부분, 평균 측정 시간을 최적화하려고 한다.
    - 하지만 평균보다는 최솟값, 또는 최댓값을 최적화하는 것이 바람직할 수도 있다.

---

## 3. 스케줄링 알고리즘

→ ***CPU 스케줄링은 준비 큐에 있는 어느 프로세스에 CPU 코어를 할당할 것인지를 결정한다.***

- 여러 가지 다른 CPU 스케줄링 알고리즘이 존재한다.
    - 이 절에서는, 스케줄링 알고리즘을 처리 코어가 하나뿐이라고 가정하고 설명한다.

</br>

### 선입 선처리 스케줄링(First-Come, First-Served Scheduling)

→ ***가장 간단한 CPU 스케줄링 알고리즘은 선입 선처리(FCFS) 스케줄링 알고리즘이다.***

- **CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다!**
    - 선입선출(FIFO) 큐로 쉽게 관리할 수 있다.
    - **단점 : 평균 대기 시간이 종종 대단히 길 수 있다.**

</br>

> **FCFS 스케줄링 알고리즘의 예시**

- 프로세스들은 **P1, P2, P3 순으로 도착**하고, 선입 선처리 순으로 서비스받는다고 가정한다.

<img width="243" alt="image" src="https://user-images.githubusercontent.com/106216912/211245871-83368fe9-3421-4cbf-a71a-8d96b32098c2.png">

</br>

→ 결과는 다음 Gantt 차트와 같다.

<img width="485" alt="image" src="https://user-images.githubusercontent.com/106216912/211245936-957f593f-5cd8-492d-bb2e-5dc447155bf4.png">

- **평균 대기 시간 : (0 + 24 + 27) / 3 = 17밀리초**

</br>

→ 프로세스들이 **P2, P3, P1 순으로 도착**하면, 결과는 다음과 같다.

<img width="483" alt="image" src="https://user-images.githubusercontent.com/106216912/211246012-f87f1cf2-acee-4fe6-9c52-311576bf6634.png">

- **평균 대기 시간 : (6 + 0 + 3) / 3 = 3밀리초**
    - **평균 대기 시간은 일반적으로 최소가 아니며, 프로세스 CPU 버스트 시간이 변할 경우에는 평균 대기 시간도 변할 수 있다!**

</br>

> **동적 상황에서의 선입 선처리 스케줄링의 성능**

1. CPU 중심 프로세스가 CPU를 할당받아서 점유한다.
    - 그동안 다른 모든 프로세스는 입출력을 끝내고, 준비 큐로 이동하여 CPU를 기다릴 것이다.
    - 프로세스들이 준비 큐에서 기다리는 동안, I/O 장치들은 쉬고 있다.

</br>

2. CPU 중심 프로세스가 자신의 CPU 버스트를 끝내고, I/O 장치로 이동한다.
    - 모든 I/O 중심의 프로세스들은 매우 짧은 CPU 버스트를 갖고 있기 때문에, CPU 작업을 신속하게 끝내고 다시 I/O 큐로 이동한다.
    - 이 시점에서, CPU가 쉬게 된다.

</br>

3. CPU 중심 프로세스는 다시 준비 큐로 이동해, CPU를 할당받는다.
    - CPU 중심 프로세스가 끝날 때까지 모든 I/O 프로세스들은 다시 준비 큐에서 기다리게 된다.

</br>

→ **호위 효과(convoy effect)** : **모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것**

- 짧은 프로세스들이 먼저 처리되도록 할 때보다 **CPU와 장치 이용률이 저하**된다.

</br>

> **비선점형이란**

→ ***CPU가 한 프로세스에 할당되면, 그 프로세스가 종료하든지, I/O 처리를 요구하든지 하여 CPU를 방출할 때까지 CPU를 점유한다.***

- **선입 선처리 알고리즘은 대화형 시스템에서 문제**가 된다.
    - 대화형 시스템에서는 각 프로세스가 규칙적인 간격으로 CPU의 몫을 얻는 것이 매우 중요하기 때문이다.

</br>

### 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)

→ ***CPU 스케줄링의 다른 접근 방법은 최단 작업 우선(SJF) 알고리즘이다.***

- 각 프로세스에 다음 CPU 버스트 길이를 연관시킨다.
    - **CPU가 이용 가능해지면, 다음 CPU 버스트가 가장 짧은 프로세스에게 할당한다!**
        - 만약 **길이가 동일하다면, 순위를 정하기 위해 선입 선처리 스케줄링을 적용**한다.
    - 프로세스의 전체 길이가 아니라, 다음 CPU 버스트의 길이에 의해 스케줄링 된다.

</br>

> **SJF 스케줄링 알고리즘의 예시**

<img width="241" alt="image" src="https://user-images.githubusercontent.com/106216912/211246427-f1e12eaf-7d27-4fd1-a11d-6c9869be002c.png">

</br>

→ **SJF 스케줄링을 이용**하면, 결과는 다음의 Gantt 차트와 같다.

<img width="483" alt="image" src="https://user-images.githubusercontent.com/106216912/211246507-57690212-9644-4e31-890a-11fa5c53646a.png">

- **평균 대기 시간 : (3 + 16 +9 + 0) / 4 = 7밀리초**
    - **선입 선출 스케줄링을 사용했다면, 10.25밀리초**이다.

</br>

> **SJF 스케줄링 알고리즘은 주어진 프로세스 집합에 대해 최소의 평균 대기 시간을 가지므로, 최적이다.**

- 짧은 프로세스의 대기 시간은 줄이고, 긴 프로세스의 대기 시간은 증가한다.
    - **결과적으로, 평균 대기 시작이 줄어든다.**

</br>

→ **SJF 알고리즘은 최적이긴 하지만 CPU 스케줄링 수준에서는 구현할 수 없다!**

- **다음 CPU 버스트의 길이를 알 방법이 없기 때문**이다.
    - 다음 CPU 버스트의 길이를 알 수는 없으나, 그 값을 예측해 근삿값을 사용할 수는 있다.
        - 다음 CPU 버스트가 앞의 버스트와 길이가 유사하다고 간주한다.

<img width="430" alt="image" src="https://user-images.githubusercontent.com/106216912/211246594-e093ae5b-e5a7-4d56-8a16-05e45733950c.png">

</br>

> **SJF 알고리즘은 선점형이거나, 또는 비선점형일 수 있다.**

- **선점형**
    - **새로운 프로세스가 현재 실행되고 있는 프로세스의 남은 시간보다도 짧은 버스트를 가지면, 현재 실행중인 프로세스를 선점**한다.

</br>

- **비선점형**
    - **실행중인 프로세스가 CPU 버스트를 완료할 때까지 선점하지 않고, 자신의 CPU 버스트를 끝내도록 허용**한다.

</br>

→ 선점형 SJF 알고리즘 = **최소 잔여 시간 우선 스케줄링(shortest remaining time first)**

</br>

> **선점형 SJF 스케줄링 알고리즘의 예시**

<img width="378" alt="image" src="https://user-images.githubusercontent.com/106216912/211246658-30527921-b7e0-4c8e-bffe-e82278d3f5c1.png">

</br>

→ **선점형 SJF 스케줄을 사용**하면, 결과는 다음의 Gantt 차트와 같다.

<img width="532" alt="image" src="https://user-images.githubusercontent.com/106216912/211246722-fd71af51-5af1-4134-9ca3-2a2201341a05.png">

- **비선점형일 때의 평균 대기 시간 : (0 + 7 + 15 + 9) / 4 = 7.75밀리초**
- **선점형일 때의 평균 대기 시간 : (9 + 0 + 15 + 2) / 4 = 6.5밀리초**

</br>

### 라운드 로빈 스케줄링(Round-Robin Scheduling)

→ ***라운드 로빈(RR) 스케줄링 알고리즘은 선입 선처리와 유사하지만, 시스템이 프로세스들 사이를 옮겨 다닐 수 있도록 선점이 추가된다.***

- **시간 할당량(time quantum), 또는 타임슬라이스(time slice)** 라고 하는 작은 단위의 시간을 사용한다.
    - CPU 스케줄러는 준비 큐를 돌면서 **한 번에 한 프로세스에 한 번의 시간 할당량 동안 CPU를 할당**한다.

</br>

> **라운드 로빈 스케줄링의 구현**

- 준비 큐가 선입 선출 큐로 동작하게 만든다.
    - 새로운 프로세스들은 준비 큐의 꼬리에 추가된다.
    - CPU 스케줄러는 준비 큐에서 첫 번째 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치 한다.

</br>

- 두 가지 경우 중 하나가 발생한다.
    1. 프로세스의 CPU 버스트가 한 번의 시간 할당량 보다 작은 경우에는, 프로세스 자신이 CPU를 자발적으로 방출하고, 스케줄러는 준비 큐에 있는 다음 프로세스로 진행한다.
    2. 현재 실행 중인 프로세스의 CPU 버스트가 한 번의 시간 할당량 보다 긴 경우로, 타이머가 끝나면서 인터럽트가 발생한다.
        - 그 후, 문맥 교환이 일어나고 실행하던 프로세스는 준비 큐의 꼬리에 넣어지고, CPU 스케줄러는 준비 큐의 다음 프로세스를 선택한다.

</br>

> **라운드 로빈 스케줄링 알고리즘의 예시**

<img width="238" alt="image" src="https://user-images.githubusercontent.com/106216912/211246817-288ee6f0-f10a-4f96-94fe-e4466f05b080.png">

</br>

→ **라운드 로빈 스케줄**의 결과는 다음과 같다.

- **시간 할당량 : 4밀리초**

<img width="528" alt="image" src="https://user-images.githubusercontent.com/106216912/211246901-7ac706da-e387-4eaf-8d5f-77d8c801ba39.png">

- **평균 대기 시간 : (6 + 4 + 7) / 3 = 5.66밀리초**

</br>

> **라운드 로빈 스케줄링 알고리즘에서는, 유일하게 실행 가능한 프로세스가 아니라면 연속적으로 두 번 이상의 시간 할당량을 할당받는 프로세스는 없다!**
> 
- 만약 CPU 버스트가 한 번의 시간 할당량을 초과하면, 프로세스는 선점되고 준비 큐로 되돌아간다.
    
    → **RR 스케줄링 알고리즘은 선점형이다!**

</br>

> **RR 알고리즘의 성능은 시간 할당량의 크기에 매우 많은 영향을 받는다!**

- **시간 할당량이 매우 크면, 선입 선처리 정책과 같다.**
- **시간 할당량이 매우 적다면, 매우 많은 문맥 교환을 야기한다.**

<img width="480" alt="image" src="https://user-images.githubusercontent.com/106216912/211246966-e4dcd183-52a0-4044-a422-932152344733.png">

</br>

> **총처리 시간 또한 시간 할당량의 크기에 좌우된다.**

<img width="389" alt="image" src="https://user-images.githubusercontent.com/106216912/211247027-9a79a930-dd5b-4a0d-840a-e0f6c15b7437.png">

- 프로세스 집합의 평균 총처리 시간은 시간 할당량의 크기가 증가하더라도, 반드시 개선되지는 않는다.
    - **대부분의 프로세스가 단일 시간 할당량 안에 CPU 버스트를 끝낸다면, 평균 총처리 시간은 개선**된다.

</br>

- 문맥 교환 시간이 추가된다면 더 많은 문맥 교환이 요구된다.
    - 따라서, 더 작은 시간 할당량에 대해서는 평균 총처리 시간이 증가한다.

</br>

### 우선순위 스케줄링(Priority Scheduling)

→ ***SJF 알고리즘은 일반적인 우선순위 스케줄링 알고리즘의 특별한 경우이다.***

- **우선순위가 각 프로세스에게 주어지고, CPU는 가장 높은 우선순위를 가진 프로세스에 할당된다!**
    - **우선순위가 같은 프로세스들은 선입 선처리 순서로 스케줄** 된다.
    - SJF 알고리즘은 우선순위가 다음 CPU 버스트의 길이를 기준으로 하는 우선 순위 스케줄링 알고리즘의 특별한 경우이다.

</br>

- 우선순위는 일반적으로 0에서 7, 또는 0에서 4,095까지의 일정 범위의 수가 사용된다.
    - 하지만, 0이 무조건 최상위, 또는 최하위 우선순위는 아니다.
    - **시스템마다 낮은 값이 낮은 우선순위 인지, 높은 우선순위 인지는 다르다.**

</br>

> **우선순위 스케줄링의 예시**

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/211247108-1015b9b0-40b6-4c7f-a894-f2f155897c94.png">

</br>

→ **우선순위 스케줄링의 결과**는 다음과 같다.

<img width="525" alt="image" src="https://user-images.githubusercontent.com/106216912/211247156-7e720380-5155-42d6-8fd4-cc2a858ca47b.png">

- **평균 대기 시간 : (6 + 0 + 16 + 18 + 1) / 5 = 8.2밀리초**

</br>

> **우선순위는 내부적, 또는 외부적으로 정의될 수 있다.**

- **내부적 우선순위** : 프로세스의 우선순위를 계산하기 위해 어떤 측정 가능한 양들을 사용한다.
    - 시간 제한, 메모리 요구, 열린 파일의 수, 평균 CPU 버스트에 대한 비율 등

</br>

- **외부적 우선순위** : 프로세스의 중요성, 컴퓨터 사용을 위해 지불되는 비용의 유형과 양 등

</br>

> **우선순위 스케줄링은 선점형이거나, 비선점형일 수 있다.**

- **선점형** : **새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높다면, CPU를 선점**한다.

</br>

- **비선점형** : **단순히 준비 큐의 머리 부분에 새로운 프로세스를 넣는다.**

</br>

> **우선순위 스케줄링 알고리즘의 문제는 무한 봉쇄(indefinite blocking) 또는 기아 상태(starvation)이다.**
> 
- 부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서, 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수도 있다.
    - **낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우가 발생한다!**

</br>

→ **첫 번째 해결 방안 : 노화(aging)**

- 에이징은 **오랫동안 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가**시킨다.
    - ex) 우선순위가 127(낮음)에서 0(높음)까지의 범위라면, 주기적으로(1초) 대기 중인 프로세스의 우선순위를 1씩 증가시킨다.

</br>

→ **두 번째 해결 방안 : 라운드 로빈과 우선순위 스케줄링을 결합하는 방법**

- **시스템이 우선순위가 가장 높은 프로세스를 실행하고, 우선순위가 같은 프로세스들은 라운드 로빈 스케줄링을 사용하여 스케줄링하는 방식**이다.

</br>

> **라운드 로빈과 우선순위 스케줄링을 결합하는 방법의 예시**

<img width="342" alt="image" src="https://user-images.githubusercontent.com/106216912/211247353-584761b7-d156-47ed-888a-f5cce139f799.png">

</br>

→ **우선순위 스케줄링을 사용하고, 우선순위가 같은 프로세스들은 라운드 로빈으로 스케줄링하면 결과**는 다음과 같다.

- **시간 할당량 : 2밀리초**

<img width="535" alt="image" src="https://user-images.githubusercontent.com/106216912/211247449-75293f2b-82b3-4d87-b269-671d008e4ce0.png">

- **평균 대기 시간 : (22 + 11 + 12 + 0 + 24) / 5 = 13.8밀리초**

</br>

### 다단계 큐 스케줄링(Multilevel Queue Scheduling)

→ ***우선순위와 라운드 로빈 스케줄링을 사용할 때, 모든 프로세스가 단일 큐에 배치되고 스케줄러는 우선순위가 가장 높은 프로세스를 선택하여 실행시킬 수 있다.***

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/211247508-ec58b268-db24-4e55-90a1-036e13b995ee.png">

- **다단계 큐** : **우선순위마다 별도의 큐를 갖는 것**이 더 쉬운 때도 있으며, 우선순위 스케줄링은 우선순위가 가장 높은 큐에서 프로세스를 스케줄한다.
    - 우선순위 스케줄링이 라운드 로빈과 결합한 경우, 효과적이다.
    - 우선순위가 가장 높은 큐에 여러 프로세스가 있는 경우, 라운드 로빈 순서로 실행된다.
    - 우선순위는 각 프로세스에 정적으로 할당되며, 프로세스는 실행시간 동안 동일한 큐에 남아 있다.

</br>

> **프로세스 유형에 따라 프로세스를 여러 개의 개별 큐로 분할하기 위해 다단계 큐 스케줄링 알고리즘을 사용할 수도 있다.**

<img width="437" alt="image" src="https://user-images.githubusercontent.com/106216912/211247585-0f81b147-3d6e-456e-918d-e673eab4bdad.png">

- ex) 포그라운드(대화형) 프로세스와 백그라운드(배치) 프로세스를 구분한다.
    - 두 유형의 프로세스는 응답 시간 요구 사항이 다르므로, 스케줄링 요구 사항이 다를 수 있다.

</br>

> **큐와 큐 사이에 스케줄링도 반드시 있어야 하며, 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다.**

- 각 큐는 다음과 같은 우선순위를 갖는다.
    1. **실시간 프로세스**
    2. **시스템 프로세스**
    3. **대화형 프로세스**
    4. **배치 프로세스**

</br>

→ **각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가진다.**

→ **또한, 큐들 사이에 시간을 나누어 사용한다.**

</br>

### 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)

→ ***다단계 큐 스케줄링 알고리즘에서는, 프로세스들이 시스템 진입 시에 영구적으로 하나의 큐에 할당된다.***

- 즉, 프로세스들은 큐들 사이로 이동하지 않는다.
    - **스케줄링 오버헤드는 적으나, 융통성이 적다.**

</br>

> **다단계 피드백 큐 스케줄링 알고리즘에서는 프로세스가 큐들 사이를 이동하는 것을 허용한다!**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/211247648-2f886986-7549-4b4d-9920-a31d04e36b25.png">

- 프로세스들을 CPU 버스트 성격에 따라서 구분한다.
    - **어떤 프로세스가 CPU 시간을 너무 많이 사용하면 낮은 우선순위의 큐로 이동**된다.
    - **낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동**할 수 있다.

</br>

- 다단계 피드백 큐 스케줄링 알고리즘은 CPU 버스트가 8밀리초 이하인 모든 프로세스에게 최고의 우선순위를 부여한다.
    - 이러한 프로세스는 CPU를 빨리 할당받아서, CPU 버스트를 끝내고 다음의 I/O 버스트로 간다.

</br>

> **일반적으로, 다단계 피드백 큐 스케줄러는 다음의 매개변수에 의해 정의된다.**

- **큐의 개수**
- **각 큐를 위한 스케줄링 알고리즘**
- **한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법**
- **한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법**
- **프로세스에 서비스가 필요할 때 프로세스가 들어갈 큐를 결정하는 방법**

</br>

→ **가장 일반적인 CPU 스케줄링 알고리즘이다!**

- 설계 중인 특정 시스템에 부합하도록 구성 가능하다.
- **단점 : 매개변수들의 값을 선정하는 특정 방법이 필요하기 때문에, 가장 복잡하다.**

---