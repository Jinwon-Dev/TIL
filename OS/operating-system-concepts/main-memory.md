## 1. 배경

→ ***메인 메모리는 현대 컴퓨터 시스템의 운영에 중심적인 역할을 한다.***

- 메모리는 각각 주소가 할당된 일련의 바이트들로 구성된다.
    - CPU는 PC(Program Counter)가 지시하는 대로 메모리로부터 다음 수행할 명령어를 가져온다.
        - 그 명령어는 필요한 경우 추가적인 데이터를 가져올 수도 있고, 데이터를 메모리에서 내보낼 수도 있다.

</br>

- 전형적인 명령어 실행은 메모리로부터 한 명령어를 가져오는 데서부터 시작된다.
    - 그 후 명령어를 해독하고, 메모리에서 피연산자(operand)를 가져와 피연산자에 대해 명령어를 실행한다.
    - 그리고 계산 결과를 메모리에 다시 저장한다.

</br>

→ **메모리는 주소에 지시한 대로 읽기, 쓰기만 할 뿐 이 주소들이 어떻게 생성되었는지, 그 주소가 가리키는 내용이 무엇인지는 모른다!**

</br>

### 기본 하드웨어

→ ***메인 메모리와 각 처리 코어에 내장된 레지스터들은 CPU가 직접 접근할 수 있는 유일한 범용 저장장치이다.***

- 기계 명령어들은 메모리 주소만을 인수로 취하고, 디스크의 주소를 인수로 취하지 않는다.
    - 따라서 모든 실행되는 명령어와 데이터들은 CPU가 직접적으로 접근할 수 있는 메인 메모리와 레지스터에 있어야 한다.
        - 만약 데이터가 메모리에 없다면, CPU가 처리하기 전에 메모리에 이동시켜야 한다.

</br>

> **메인 메모리의 접근을 완료하기 위해서는 많은 CPU 클록 틱 사이클이 소요된다.**

- 이 경우, CPU가 필요한 데이터가 없어서 명령어를 수행하지 못하고 지연되는(stall) 현상이 발생하게 된다.
    - 해결 방법 : CPU와 메인 메모리 사이에 빠른 속도의 **캐시 메모리**를 추가하는 것
        - CPU에 구축된 캐시를 관리하여 하드웨어는 어떠한 운영체제의 도움 없이 메모리 접근 속도를 향상한다.

</br>

> **물리 메모리의 상대적인 접근 속도의 차이를 고려하는 것에 추가로 올바른 동작을 보장해야만 한다.**

- 시스템이 올바르게 동작하기 위해서는 사용자 프로그램으로부터 운영체제 영역을 보호하고, 사용자 프로그램 사이도 서로 보호해야 한다.
    - 운영체제가 CPU와 메모리 간의 접근 중에 개입하게 되면 성능이 떨어지기 때문에, 보호 기법은 반드시 하드웨어가 지원해야 한다.

</br>

> **먼저, 각각의 프로세스가 독립된 메모리 공간을 가지도록 보장해야 한다.**

- 개별적인 프로세스별 메모리 공간은 서로를 보호하고, 병행 실행을 위해 여러 프로세스가 메모리에 적재되게 하는 것이 필수적이다.
    - 개별적인 메모리 공간을 분리하기 위해, **특정 프로세스만 접근할 수 있는 합법적인 메모리 주소 영역을 설정하고, 합법적인 영역만 접근하도록 하는 것**이 필요하다.

</br>

<img width="295" alt="image" src="https://user-images.githubusercontent.com/106216912/221346230-25764e99-5f46-47c1-a1ff-1d4c42a06e24.png">

- **기준(base)와 상한(limit)라고 불리는 두 개의 레지스터를 사용해서 보호 기법을 제공**한다.
    - **기준 레지스터** : 가장 작은 합법적인 물리 메모리 주소의 값을 저장
    - **상한 레지스터** : 주어진 영역의 크기를 저장

</br>

<img width="383" alt="image" src="https://user-images.githubusercontent.com/106216912/221346264-f21aa07b-cd92-4b03-89f5-f7232d641e89.png">

- 메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 이루어진다.
    - 사용자 모드에서 수행되는 프로그램이 **운영체제의 메모리 공간이나, 다른 사용자 프로그램의 메모리 공간에 접근하면 운영체제는 치명적인 오류로 간주하고, 트랩(trap)을 발생**시킨다.

</br>

→ **이러한 기법은 사용자 프로그램이 운영체제나 다른 사용자 프로그램의 코드나 데이터 구조를 수정하는 것을 막는다.**

</br>

> **기준과 상한 레지스터는 여러 가지 특권 명령을 사용하는 운영체제에 의해서만 적재(load)된다.**

- 특권 명령은 오직 커널 모드에서만 수행되고, 운영체제만 커널 모드에서 수행되기 때문이다.
    - 운영체제만 레지스터들의 값을 변경할 수 있도록 허가하여, 사용자 프로그램이 레지스터의 내용을 변경하는 것을 막는다.

</br>

> **커널 모드에서 수행되는 운영체제는 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 어떠한 제약도 받지 않는다.**

- 따라서, 운영체제는 사용자 프로그램을 사용자 메모리 영역에 적재한다.
    - 그 후, 오류가 발생한 경우에 그 프로그램을 덤프(dump out), 시스템 콜의 매개 변수를 변경, 사용자 메모리로부터의 입출력과 다른 많은 서비스를 제공할 수 있다.

</br>

### 주소의 할당

→ ***프로그램은 원래 이진 실행 파일 형태로 디스크에 저장되어 있다.***

- 실행하려면 프로그램을 메모리로 가져와서 프로세스 문맥내에 배치해야 한다.

</br>

> **대부분의 시스템은 사용자 프로세스가 메모리 내 어느 부분으로도 올라올 수 있도록 지원한다.**

<img width="281" alt="image" src="https://user-images.githubusercontent.com/106216912/221346321-9085a559-bb4a-4e6d-9260-a93a91337222.png">

→ ***사용자 프로그램은 여러 단계를 거쳐 실행되기 때문에, 단계를 거치는 동안 주소들은 여러 다른 표현 방식을 거치게 된다.***

- 원시 프로그램에서 주소는 숫자가 아닌 **심볼 형태**로 표현된다.
    - 컴파일러는 이 심볼 주소를 **재배치 가능 주소**로 바인딩시킨다.
    - 그 후, 링커나 로더가 재배치 가능 주소를 **절대 주소**로 바인딩시킨다.

</br>

> **메모리 주소 공간에서 명령어와 데이터의 바인딩은 그 바인딩이 이루어지는 시점에 따라 구분된다.**
> 
- **컴파일 시간 바인딩**
    - **프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 아는 경우**
    - 컴파일러는 절대 코드를 생성할 수 있다.

- **적재 시간 바인딩**
    - **프로세스가 메모리 내에 적재될 위치를 컴파일 시점에 알지 못하는 경우**
    - 컴파일러는 이진 코드를 재배치 가능 코드로 만들고, 최종 바인딩은 적재 시간까지 연기한다.

- **실행 시간 바인딩**
    - **프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨질 수 있는 경우**
    - 바인딩을 실행 시간까지 연기한다.

</br>

### 논리 대 물리 주소 공간

- **논리 주소(logical address)** : CPU가 생성하는 주소
- **물리 주소(physical address)** : 메모리가 취급하게 되는 주소

</br>

> **컴파일, 또는 적재 시에 주소를 바인딩 하면 논리 주소와 물리 주소가 같다.**

- 하지만, 실행 시간 바인딩 기법에서는 논리, 물리 주소가 다르다!
    - 이 때는 논리 주소를 **가상 주소(virtual address)** 라고 한다.
    - 논리 주소 = 가상 주소

</br>

<img width="429" alt="image" src="https://user-images.githubusercontent.com/106216912/221346386-8b1fd6a6-fe22-4dd8-b068-972040143905.png">

- **메모리 관리 장치(MMU : memory management unit)**
    - **프로그램의 실행 중에 가장 주소를 물리 주소로 바꿔주는 변환 작업을 실행**한다.

</br>

> **여기서는 기준 레지스터 기법을 일반화시킨 아주 단순한 MMU 기법에 따른 변환을 설명한다.**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/221346409-36b31f57-d1d0-4203-84d6-dbdee49ade45.png">

- 기준 레지스터 = **재배치(relocation) 레지스터**
    - 재배치 레지스터 속에 들어있는 값은, **주소가 메모리로 보내질 때마다 그 모든 주소에 더해진다.**
        - ex) 재배치 레지스터 값 = 14000, 프로세스가 346번지에 액세스하면, 사실은 메인 메모리에 14346번지에 액세스하게 되는 것

</br>

### 동적 적재

→ ***메모리 공간의 더 효율적 이용을 위해서는 동적 적재(dynamic loading)을 해야한다.***

- **동적 적재에서 각 루틴은 실제 호출되기 전까지는 메모리에 올라오지 않고, 재배치 가능한 상태로 디스크에서 대기**하고 있다.
    - 이 루틴이 다른 루틴을 호출하였는데 적재되어 있지 않다면, 재배치 가능 연결 적재기가 요구된 루틴을 메모리로 가져오고, 테이블에 기록한다.

</br>

> **동적 적재의 장점**

→ ***루틴이 필요한 경우에만 적재된다.***

- 오류 처리 루틴과 같은 아주 간혹 발생하면서도, 실행할 코드가 많은 경우에 특히 유용하다.

</br>

→ **동적 적재는 운영체제로부터 특별한 지원이 필요없다.**

- 사용자 자신이 프로그램의 설계를 책임져야 하고, 운영체제는 동적 적재를 구현하는 라이브러리 루틴을 제공한다.

</br>

### 동적 연결 및 공유 라이브러리

→ ***동적 연결 라이브러리(DLL)는 사용자 프로그램이 실행될 때, 사용자 프로그램에 연결되는 시스템 라이브러리이다.***

- **동적 연결에서는 연결이 실행 시기까지 미루어진다.**

</br>

> **DLL의 장점**

- **라이브러리를 여러 프로세스 간에 공유할 수 있다.**
    - 따라서, **메인 메모리에 DLL 인스턴스가 하나**만 있을 수 있다.
    - 라이브러리 루틴을 바꿀 때 유용하다.
    - DLL = **공유 라이브러리**

</br>

> **동적 적재와는 달리, 동적 연결과 공유 라이브러리는 일반적으로 운영체제의 도움이 필요하다.**

- 메모리에 있는 프로세스들이 각자의 공간은 자기만 액세스할 수 있도록 보호된다면, 운영체제만이 기억 공간에 루틴이 있는지를 검사해 줄 수 있다.
    - 또한, 운영체제만이 여러 프로세스가 같은 메모리 주소를 공용할 수 있도록 해줄 수 있다.

---