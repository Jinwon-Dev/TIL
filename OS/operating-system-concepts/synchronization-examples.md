> **이번 장에서는 6장에 제시된 도구를 몇 가지 고전적인 동기화 문제에 적용한다!**

- 또한, Linux, UNIX 및 Windows 운영체제에서 사용되는 동기화 기법을 알아본다.
- Java 및 POSIX 시스템의 API 세부 사항을 학습한다.

---

## 1. 고전적인 동기화 문제들

→ ***많은 클래스의 병행 제어(concurrency control) 문제에 대한 예로서, 중요한 여러 가지의 다른 동기화 문제들을 알아본다.***

- 동기화 문제에 대한 해결책을 제시할 때 전통적으로 세마포를 사용해 왔기 때문에, 우리의 해결안에서도 **세마포**가 사용된다.
    - 그러나 해결책을 실제 구현할 때는 이진 세마포 대신에 mutex 락이 사용될 수 있다.

</br>

### 유한 버퍼 문제(The Bounded-Buffer Problem)

→ ***이 문제는 일반적으로 동기화 프리미티브들의 능력을 설명하기 위해 사용된다.***

- 해결하려는 문제에서 소비자와 생산자는 다음과 같은 자료구조를 공유한다.

<img width="187" alt="image" src="https://user-images.githubusercontent.com/106216912/213464783-89c99083-05b8-406b-8e39-f35e765d15e8.png">

</br>

- `n` 개의 버퍼로 구성된 풀(pool)이 있으며, 각 버퍼는 한 항목을 저장할 수 있다고 가정한다.
    - `mutex` 이진 세마포는 버퍼 풀에 접근하기 위한 상호 배제 기능을 제공하며, `1` 로 초기화된다.
    - `empty` 와 `full` 세마포들은 각각 비어 있는 버퍼의 수, 꽉 찬 버퍼의 수를 기록한다.

</br>

> **생산자 코드**

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/213464918-0c4d0318-d758-4e90-8d72-c216494903c8.png">

</br>

> **소비자 코드**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/213465016-fec3d2fd-dabc-4422-b0e1-b2d73931ca54.png">

</br>

→ **생산자가 소비자를 위해 꽉 찬 버퍼를 생산해내고, 소비자는 생산자를 위해 비어 있는 버퍼를 생산**해낸다.

</br>

### Readers-Writers 문제

→ ***하나의 데이터베이스가 다수의 병행 프로세스 간에 공유된다고 가정한다.***

- **프로세스 중의 일부는 데이터베이스의 내용을 읽기**만 하고, **어떤 프로세스들은 데이터베이스를 갱신**하기를 원할 수 있다.
    - 전자를 **readers**, 후자를 **writers**로 불러서 두 가지 유형의 프로세스들을 구별한다.
    - 두 reader가 동시에 공유 데이터에 접근하더라도 상관없지만, **하나의 writer와 어떤 다른 스레드(reader 또는 writer)가 동시에 접근한다면, 혼란이 야기**될 수 있다!

</br>

→ **이 동기화 문제를 readers-writers 문제라고 한다.**

- 문제가 발생하지 않도록 보장하기 위해, 우리는 writer가 쓰기 작업 동안에 **공유 데이터베이스에 대해 배타적 접근 권한**을 가지게 할 필요가 있다.

</br>

> **Readers-Writers 문제에는 우선순위와 연관된 여러 가지 변형들이 존재한다.**

1. writer가 공유 객체를 사용할 수 있는 허가를 아직 얻지 못했다면, 어느 reader도 기다리게 해서는 안 된다.
    - 단순히 writer가 기다리고 있기 때문에, 다른 reader들이 끝날 때까지 기다리는 reader가 있어서는 안 된다.

</br>

2. 일단 writer가 준비되면 가능한 한 빨리 쓰기를 수행할 것을 요구한다.
    - writer가 객체에 접근하려고 기다리고 있다면, 새로운 reader들은 읽기를 시작하지 못한다.

</br>

→ 문제에 대한 해결안이 **기아 문제**를 낳을 수 있다!

- 첫 번째 경우는 writer가, 두 번째 경우는 reader가 기아 상태에 빠질 수 있다.

</br>

> **그렇다면 첫 번째 readers-writers 문제에 대한 해결안은?**

- reader 프로세스는 다음과 같은 자료구조를 공유한다.

<img width="217" alt="image" src="https://user-images.githubusercontent.com/106216912/213465302-682ea7e2-1237-4db4-8452-26c0a3f881c1.png">

</br>

- `rw_mutex` 세마포는 reader와 writer가 모두 공유한다.
    - `mutex` 세마포는 `read_count` 를 갱신할 때 상호 배제를 보장하기 위해 사용된다.
    - `read_count` 는 현재 몇 개의 프로세스들이 객체를 읽고 있는지 알려준다.
    - `rw_mutex` 는 다른 reader들이 임계구역 안에 있는 동안 임계구역을 드나드는 reader들은 이것을 사용하지 않는다.

</br>

> **Writer 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465444-8972a7da-1a89-4593-9a48-25ba511f0736.png">

</br>

> **Reader 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465540-f7d2beae-003c-42af-9e21-85c480756f92.png">

</br>

→ **Reader-Writers 문제와 해결안들은 일반화 되어, 몇몇 시스템에서는 reader-writer 락을 제공**한다.

- reader-writer 락을 획득할 때는 **읽기인지, 또는 쓰기인지의 모드를 지정**해야만 한다.
    - 프로세스가 **공유 데이터를 읽기만 원한다면 읽기 모드의 reader-writer 락**을, **공유 데이터의 수정을 원한다면 쓰기 모드의 reader-writer 락**을 요청한다.
    - 읽기 모드의 reader-writer 락은 여러 프로세스의 동시에 획득이 가능하다.
    - 반면, Writer는 공유 데이터를 배타적으로 접근해야 하므로, 오직 하나의 프로세스만이 쓰기 모드의 reader-writer 락을 획득할 수 있다.

</br>

> **Reader-Writer 락은 다음과 같은 상황에서 가장 유용하다.**

- 공유 데이터를 읽기만 하는 프로세스와 쓰기만 하는 스레드를 식별하기 쉬운 응용
- Writer보다 Reader의 개수가 많은 응용
    - 일반적으로 reader-writer 락을 설정하는 데 드는 오버헤드가, 세마포나 상호 배제 락을 설정할 때보다 크다.
    - 이 오버헤드는 동시에 여러 reader가 읽게 하여 병행성을 높임으로써 상쇄할 수 있다.

</br>

### 식사하는 철학자들 문제(The Dining-Philosophers Problem)

→ ***생각하고 먹으면서 그들의 생애를 보내는 5명의 철학자를 고려해 본다.***

<img width="242" alt="image" src="https://user-images.githubusercontent.com/106216912/213465787-aa20aff4-eddd-410a-8dec-9a009efa696c.png">

- 철학자들은 원형 테이블을 공유하며, 이 테이블은 각각 한 철학자에 속하는 5개의 의자로 둘러싸여 있다.
    - 테이블 중앙에는 한 사발의 밥이 있고, 테이블에는 다섯 개의 젓가락이 놓여 있다.
    - 철학자가 생각할 때는 다른 동료들과 상호 작용하지 않는다.
    
</br>

- 때때로 철학자들은 배가 고파지고, **자신에게 가장 가까이 있는 두 개의 젓가락을 집으려고 시도**한다.
    - **철학자는 한 번에 한 개의 젓가락**만 집을 수도 있다.
    - 또한, **철학자는 이미 옆 사람의 손에 들어간 젓가락을 집을 수는 없다.**
    - 배고픈 철학자가 동시에 젓가락 두 개를 집으면 젓가락을 놓지 않고 식사를 하고, 식사를 마치면 젓가락 두 개를 모두 놓는다.

</br>

→ **식사하는 철학자들 문제는 고전적인 동기화 문제로, 많은 부류의 병행 제어 문제의 한 예**이다.

- 교착 상태와 기아를 발생시키지 않고 여러 스레드에게 여러 자원을 할당해야 하는 필요의 예시이다.

</br>

> **세마포 해결안**

→ ***한 가지 간단한 해결책은 각 젓가락을 하나의 세마포로 표현하는 것이다.***

- 철학자는 세마포에 `wait()` 연산을 실행해서 젓가락을 집으려고 시도한다.
    - 또한, 해당 세마포에 `signal()` 연산을 실행함으로써 자신의 젓가락을 놓는다.

</br>

- 공유 자료는 다음과 같다.

<img width="214" alt="image" src="https://user-images.githubusercontent.com/106216912/213466024-fdab8cd5-bdc9-41e7-a0b1-3045cbee6ae5.png">

</br>

- 철학자 `i` 의 구조

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213466148-e838f3dd-cfe6-41b4-b4f1-dc638282f9e5.png">

</br>

→ 이 해결안은 인접한 **두 철학자가 동시에 식사하지 않는다는 것은 보장하지만, 교착 상태를 야기할 가능성**이 있다.

- 5명의 철학자 모두가 동시에 배가 고프게 되어, 각각 자신의 왼쪽 젓가락을 잡는다고 가정한다.
    - `chopstick` 의 모든 원소들은 `0` 이 되고, 각 철학자가 오른쪽 젓가락을 집으려고 하면 영원히 기다려야 한다.

</br>

> **교착 상태 문제에 대한 여러 가지 해결책들**

- 최대 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
- 한 철학자가 젓가락 두 개를 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.
    - 철학자는 임계구역 안에서만 젓가락을 집어야 한다.
- 비대칭 해결안을 사용한다.
    - 홀수 번호의 철학자는 먼저 왼쪽 젓가락을 집고, 다음에 오른쪽 젓가락을 집는다.
    - 짝수 번호의 철학자는 반대로 한다.

</br>

> **모니터 해결안**

→ ***모니터를 사용해 교착 상태가 없는 해결안을 제시할 수 있다.***

- 이 해결안은 철학자는 양쪽 젓가락을 모두 얻을 수 있을 때만 젓가락을 집을 수 있다는 제한을 강제한다.
    - 구현하려면, 철학자가 처할 수 있는 세 가지 상태들을 구분할 필요가 있다.
    - 다음의 자료구조를 도입한다.

<img width="336" alt="image" src="https://user-images.githubusercontent.com/106216912/213466322-8ed28b0c-62d6-469e-b3f1-ee7782069a66.png">

</br>

- 철학자 `i` 는 그의 양쪽 두 이웃이 식사하지 않을 때만 변수 `state[i] = EATING` 으로 설정할 수 있다.
    - 또한, 다음을 선언할 필요가 있다.

<img width="171" alt="image" src="https://user-images.githubusercontent.com/106216912/213466411-78057544-fae7-4beb-b716-bef1b357c83a.png">

</br>

- `self` 는 철학자 `i` 가 배고프지만 자신이 원하는 젓가락을 집을 수 없을 때 젓가락 집기를 미룰 수 있게 한다.

</br>

→ 젓가락의 분배는 모니터 `DiningPhilosophers` 에 의해 제어된다.

<img width="347" alt="image" src="https://user-images.githubusercontent.com/106216912/213466577-01046f1e-7510-4e41-81c1-baed75f74a00.png">

- 각 철학자는 식사하기 전에 `pickup()` 연산을 반드시 호출해야 한다.
    - 이 행동은 철학자 프로세스의 일시 중지를 낳을 수도 있다.
    - 연산이 성공적으로 끝나면, 철학자는 식사할 수 있다.

</br>

- 식사를 마친 후, 철학자는 `putdown()` 연산을 호출한다.
    - 철학자 `i` 는 반드시 다음과 같은 순서로 `pickup()` 과 `putdown()` 연산을 호출해야 한다.

<img width="245" alt="image" src="https://user-images.githubusercontent.com/106216912/213466693-68a0453e-9326-4fed-ba5e-e75bfd8e7d19.png">

</br>

→ 이 해결안은 **이웃한 두 철학자가 동시에 식사하지 않고, 교착 상태가 발생하지 않는다는 것을 보장하지만 철학자가 굶어 죽는 것이 가능**하다.

---

## 2. 커널 안에서의 동기화

→ ***Windows, Linux 운영체제에서 제공되는 동기화 기법을 알아본다.***

</br>

### Windows의 동기화

→ ***Windows 운영체제는 실시간 응용과 다중 처리기 지원을 제공하는 다중 스레드 커널이다.***

- Windows 커널이 단일 처리기에서 전역 정보를 액세스할 때는 동일한 전역 정보를 액세스할 가능성이 있는 인터럽트 핸들러가 실행되지 않도록, 인터럽트를 잠시 동안 못 걸리게 막는다.
    - 다중 처리기 시스템에서는 **스핀락**을 써서 전역 정보 액세스를 통제한다.
    - 하지만, Windows 커널은 짧은 코드에 대해서만 스핀락을 사용한다.
    - 효율성을 위해서 스레드가 스핀락을 가지고 있는 동안은 선점되지 않도록 보장한다.

</br>

> **커널 외부에서 스레드를 동기화하기 위해 dispatcher 객체를 제공한다.**

- 스레드는 dispatcher 객체를 사용해서 mutex 락, 세마포, event 및 타이머를 포함한 다양한 기법에 맞추어 동기화할 수 있다.
    - 시스템은 데이터에 접근하기 위해 스레드가 mutex의 소유권을 획득한 후, 필요한 작업이 끝난 후에는 다시 반납하게 함으로써 공동으로 사용하는 데이터를 보호한다.

</br>

- **Event**는 조건 변수와 유사하다.
    - 즉, 기다리는 조건이 만족하면 기다리고 있는 스레드에 통지해 줄 수 있다.
    - 타이머는 지정한 시간이 만료되면 하나, 또는 둘 이상의 스레드에 통지하는 데 사용된다.

</br>

> **Dispatcher 객체는 signaled 상태에 있을 수도 있고, nonsignaled 상태에 있을 수도 있다.**

<img width="357" alt="image" src="https://user-images.githubusercontent.com/106216912/213477401-d869333e-8595-4e54-97ef-f08c3e52d349.png">

- **Signaled 상태** : 객체가 사용 가능하고, 그 객체를 얻을 때 그 스레드가 봉쇄되지 않음
- **Nonsignaled 상태** : 객체가 사용할 수 없고, 그 객체를 얻으려고 시도하면 그 스레드가 봉쇄됨

</br>

> **Dispatcher 객체의 상태와 스레드 상태 간에는 관련성이 있다.**

- 스레드가 nonsignaled 상태에 있는 dispatcher 객체 때문에 봉쇄되면, 그 스레드의 상태는 준비로부터 대기 상태로 바뀌고 그 스레드는 그 객체의 대기 큐에 넣어지게 된다.
    - 그 후, dispatcher 객체의 상태가 signaled 상태로 바뀌면 커널은 그 객체를 기다리는 스레드가 있는지 여부를 알아내어, 있으면 그 하나의 스레드를 대기 상태로부터 준비 상태로 바꾸어 다시 실행을 재개할 수 있도록 조치한다.

</br>

> **Critical-section 객체는 커널의 개입 없이 획득하거나 방출할 수 있는 사용자 모드 mutex이다.**

- 다중 처리기 시스템에서 **critical-section 객체**는 처음에는 스핀락을 사용하여 다른 스레드가 객체를 방출하기를 기다린다.
    - 회전이 길어지게 되면 락을 획득하려는 프로세스는 커널 mutex를 할당하고, CPU를 양도한다.

</br>

→ Critical-section 객체는 **커널 mutex는 객체에 대한 경쟁이 발생할 때만 할당되기 때문에 효율적**이다.

- 경쟁은 거의 발생하지 않기 때문에, CPU 절약은 상당히 좋아진다.

</br>

### Linux의 동기화

→ ***Linux 커널은 완전히 선점 가능하며, 커널 모드에서 실행 중일 때도 태스크는 선점될 수 있다.***

- Linux는 커널 안에서 동기화를 할 수 있는 많은 다른 기법을 제공한다.
    - 가장 간단한 동기화 기법은 **원자적 정수**이다.
    - 차단된 데이터 형인 `atomic_t` 데이터 형을 사용하여 표현한다.

</br>

- 원자적 정수를 사용하는 모든 수학 연산은 중단됨 없이 수행된다.

<img width="160" alt="image" src="https://user-images.githubusercontent.com/106216912/213477953-b1ff994a-c592-43fa-8c4e-1e6b2d83923b.png">

</br>

- 다음 코드는 다양한 원자적 연산을 수행한 효과를 보여준다.

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/213478079-9e6cf51e-d866-4d4c-acb5-bede545e4cbf.png">

</br>

> **원자적 정수는 `counter` 와 같은 정수형 변수가 갱신되어야 하는 상황에서 특히 효율적이다.**

→ **원자적 연산은 락 기법을 사용할 때의 오버헤드가 필요 없기 때문이다.**

- 하지만 이러한 종류의 상황에서만 유용하다는 제약이 있다.

</br>

> **Linux에서 커널 안의 임계구역을 보호하기 위해 mutex 락이 제공된다.**

- 태스크는 임계구역에 들어가기 전에 `mutex_lock()` 함수를 호출해야 하고, 나오기 전에 `mutex_unlock()` 함수를 호출해야 한다.
    - mutex 락을 획득할 수 없으면 `mutex_lock()` 을 호출한 태스크는 수면 상태에 놓이고, 락의 소유자가 `mutex_unlock()` 을 호출할 때 깨어나게 된다.

</br>

> **Linux 커널은 커널 안에서의 락킹을 위해서 스핀락과 세마포 및 두 락의 reader-writer 버전도 제공한다.**

→ SMP 기계에서는 기본적인 락킹 기법이 **스핀락**이다.

</br>

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/213478373-ace71b80-8540-4da1-be5c-2b21d52aa4d9.png">

- 스핀락이 단지 짧은 시간 동안만 소유되도록 커널이 설계되었다.
    - 하나의 처리 코어를 가진 시스템에서는 스핀락을 획득하는 것이 아니라, 커널이 커널 선점을 불가능하게 한다.
    - 또한, 스핀락을 방출하는 것이 아니라 커널은 커널 선점을 가능하게 한다.

</br>

→ ***Linux 커널에서 스핀락과 mutex 락은 재귀적이지 않다.***

- 즉, **스레드가 이러한 락 중 하나를 획득했다면 획득한 락을 해제하지 않고는 같은 락을 다시 획득할 수 없다.**
    - 해제하지 않으면 락을 획득하려는 두 번째 시도는 봉쇄된다.

</br>

> **Linux는 커널 선점을 불능케 하고 가능케 하는 데 흥미로운 방식을 사용한다.**

→ **`preempt_disable()` 과 `preempt_enable()` 이라는 두 개의 간단한 시스템 콜을 제공한다.**

</br>

→ 스핀락과 커널 선점 불능 및 가능은 오직 **락, 또는 커널 선점 불가능이 짧은 시간 동안만 유지될 때 사용**된다.

- 락이 오랜 시간 동안 유지되어야 한다면, 세마포 또는 mutex 락을 사용하는게 적절하다.

---

## 3. POSIX 동기화

→ ***POSIX API는 사용자 수준에서 프로그래머가 사용할 수 있으며, 특정 운영체제 커널의 일부가 아니다.***

- 이 API는 UNIX, Linux 및 macOS 시스템의 개발자가 스레드를 생성하고 동기화하는 데 널리 사용된다.

</br>

### POSIX mutex 락

→ ***Mutex 락은 Pthreads에서 사용할 수 있는 기본적인 동기화 기법을 제공한다.***

- Mutex 락은 **코드의 임계구역을 보호하기 위해 사용**된다.
    - 즉, 스레드는 **임계구역에 진입하기 전에 락을 획득하고, 임계구역에서 나갈 때 락을 방출**한다.

</br>

- Pthreads는 mutex 락의 데이터 형으로 `pthread_mutex_t` 데이터 형을 사용한다.
    - Mutex는 `pthread_mutex_init()` 함수를 호출하여 생성한다.
    - 첫 번째 매개변수는 mutex를 가리키는 포인터이고, 두 번째 매개변수로 `NULL` 을 전달하여 속성을 디폴트 값으로 초기화한다.

<img width="341" alt="image" src="https://user-images.githubusercontent.com/106216912/213492830-48699e06-d398-4907-bebb-cabdf18f7c77.png">

</br>

- Mutex는 `pthread_mutex_lock()` 과 `pthread_mutex_unlock()` 을 통해 각각 획득되고 방출된다.
    - Mutex 락을 획득할 수 없는 경우에 획득을 요청한 스레드는 락을 가지고 있는 스레드가 `pthread_mutex_unlock()` 을 호출할 때까지 봉쇄된다.

<img width="243" alt="image" src="https://user-images.githubusercontent.com/106216912/213492954-1b677a57-d534-4551-a5c1-7696e050ab79.png">

</br>

→ 모든 mutex 함수는 연산이 성공했을 경우 `0` 을, 오류가 발생한 경우에는 오류 코드를 반환한다.

</br>

### POSIX 세마포

→ ***세마포는 Pthreads 표준의 일부분이 POSIX SEM 확장판의 일부이지만, Pthreads를 구현하는 많은 시스템은 세마포도 함께 제공한다.***

- POSIX는 **기명(named)** 과 **무명(unnamed)** 의 두 유형의 세마포를 명기하고 있다.
    - 기본적으로 이 두 가지는 매우 유사하지만, 프로세스 간에 생성 및 공유되는 방식이 다르다.

</br>

> **POSIX 기명 세마포(POSIX Named Semaphores)**

→ ***`sem_open()` 함수는 POSIX 기명 세마포를 생성하고 여는 데 사용된다.***

<img width="387" alt="image" src="https://user-images.githubusercontent.com/106216912/213493193-907b07ab-a63b-4e9b-922c-bfc7beec0d7a.png">

</br>

- **기명 세마포의 장점**
    - 여러 관련 없는 프로세스가 **세마포 이름만 참조하여 동기화 기법으로 공통 세마포를 동기화 기법으로 쉽게 사용**할 수 있다.

</br>

- 고전적인 `wait()` 및 `signal()` 연산을 POSIX에서는 `sem_wait()` 및 `sem_post()` 로 선언한다.
    - ex) 기명 세마포를 사용해서 임계구역을 보호하는 방법

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213493312-241e4090-fdd6-4ce6-a38d-5805323327f5.png">

</br>

→ Linux 및 macOS 시스템은 모두 POSIX라는 세마포를 제공한다.

</br>

> **POSIX 무명 세마포(POSIX Unnamed Semaphores)**
> 

→ **무명 세마포는 `sem_init()` 함수를 사용해서 생성 및 초기화되며, 세 개의 매개 변수가 전달된다.**

1. 세마포를 가리키는 포인터
2. 공유 수준을 나타내는 플래그
3. 세마포의 초기 값

</br>

<img width="387" alt="image" src="https://user-images.githubusercontent.com/106216912/213493461-9d44549a-9002-4b26-aa1c-fd7a97ada8c6.png">

- 플래그 `0` 을 전달하면 세마포를 만든 프로세스에 속하는 스레드만 이 세마포를 공유할 수 있다.
    - 또한, 세마포를 값 `1` 로 초기화한다.

</br>

- POSIX 무명 세마포는 기명 세마포와 동일한 `sem_wait()` 및 `sem_post()` 연산을 사용한다.
    - ex) 무명 세마포를 사용해서 임계구역을 보호하는 방법

<img width="245" alt="image" src="https://user-images.githubusercontent.com/106216912/213493566-b722f619-6149-412a-8752-71ece348eb98.png">

</br>

→ 모든 세마포 함수는 성공하면 `0` 을, 오류 조건이 발생하면 `0` 이 아닌 값을 반환한다.

</br>

### POSIX 조건 변수

→ ***Pthread의 조건 변수는 모니터 문맥 내에서 사용되며, 모니터가 데이터 무결성을 보장하는 락 기법을 제공한다.***

- Pthread는 일반적으로 C 프로그램에서 사용되며, 조건 변수에 mutex 락을 연결하여 락킹을 제공한다.

</br>

- Pthread의 조건 변수는 `pthread_cond_t` 데이터 유형을 사용하고, `pthread_cond_init()` 함수를 사용해서 초기화된다.
    - ex) 조건 변수 및 관련 mutex 락을 생성하고 초기화한다.

<img width="242" alt="image" src="https://user-images.githubusercontent.com/106216912/213493740-f9a6c80a-6982-4863-aa18-8dd63975bde8.png">

</br>

- `pthread_cond_wait()` 함수는 조건 변수를 기다리는 데 사용된다.
    - ex) Pthread 조건 변수를 사용해서 스레드가 조건 `a == b` 가 `true` 가 될 때까지 대기하는 방법

<img width="293" alt="image" src="https://user-images.githubusercontent.com/106216912/213493907-fc176927-647e-419c-9677-8a77c9216af1.png">

</br>

- 조건 변수와 연관된 mutex 락은 `pthread_cond_wait()` 함수가 호출되기 전에 획득되어야 한다.
    - 가능한 경쟁 조건으로부터 조건 절의 데이터를 보호하는 데 사용된다.

</br>

- 공유 데이터를 변경하는 스레드는 `pthread_cond_signal()` 함수를 호출해서 조건 변수를 기다리는 하나의 스레드에 신호할 수 있다.

<img width="239" alt="image" src="https://user-images.githubusercontent.com/106216912/213494045-2a789254-18e4-483a-9c0a-6178738acc1c.png">

</br>

→ Mutex 락이 해제되면 신호받은 스레드는 mutex 락의 소유자가 되고, `pthread_cond_wait()` 호출에서부터 제어를 넘겨받아 실행을 재개한다.

---

## 4. Java에서의 동기화

→ ***Java 언어와 API는 언어의 기원부터 스레드 동기화에 대한 풍부한 지원을 제공하였다.***

</br>

### Java 모니터

→ ***Java는 스레드 동기화를 위한 모니터와 같은 풍부한 지원을 제공한다.***

- `BoundedBuffer` 클래스로 이 기법을 설명한다.
    - 생산자와 소비자 문제의 해결안을 구현하여, 생산자와 소비자는 각각 `insert()` 및 `remove()` 메소드를 호출한다.

<img width="346" alt="image" src="https://user-images.githubusercontent.com/106216912/213512087-0dd50165-fdd9-4896-a5f1-555a13801a07.png">

</br>

> **Java의 모든 객체는 하나의 락과 연결되어 있다.**

- 메소드가 `synchronized` 로 선언된 경우, 메소드를 호출하려면 그 객체와 연결된 락을 획득해야 한다.

</br>

- `synchronized` 메소드를 호출하려면 `BoundedBuffer` 의 객체 인스턴스와 연결된 락을 소유해야 한다.
    - 다른 스레드가 이미 락을 소유한 경우, `synchronized` 메소드를 호출한 스레드는 봉쇄되어 객체의 락에 설정된 **진입 집합(entry set)**에 추가된다.

</br>

- `synchronized` 메소드를 호출할 때 락이 가용한 경우, 호출 스레드는 객체 락의 소유자가 되어 메소드로 진입한다.
    - 스레드가 메소드를 종료하면 락이 해제된다.
    - 락이 해제될 때 락에 대한 진입 집합이 비어 있지 않으면, JVM은 이 집합에서 락 소유자가 될 스레드를 임의로 선택한다.

<img width="401" alt="image" src="https://user-images.githubusercontent.com/106216912/213512308-7c441f0c-ba56-4d55-bd50-e1192349d56d.png">

</br>

> **락을 갖는 것 외에도 모든 객체는 스레드 집합으로 구성된 대기 집합과 연결된다.**

- 이 대기 집합은 처음에는 비어 있고, 스레드가 `synchronized` 메소드에 들어가면 객체 락을 소유한다.
    - 그러나 이 스레드는 특정 조건이 충족되지 않아 계속할 수 없다고 결정할 수 있다.

</br>

- 스레드가 `wait()` 메소드를 호출하면 다음이 발생한다.
1. 스레드가 객체의 락을 해제한다.
2. 스레드 상태가 봉쇄됨으로 설정된다.
3. 스레드는 그 객체의 대기 집합에 넣어진다.

</br>

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/213512458-3b96c8ab-ecd7-4e7a-a8a4-4c1734b476ee.png">

- 생산자가 `insert()` 메소드를 호출하고 버퍼가 가득 찬 걸 확인하면, `wait()` 메소드를 호출한다.
    - 이 호출은 락을 해제하고 생산자를 봉쇄하여 생산자를 개체의 대기 집합에 둔다.
    - 생산자가 락을 해제했기 때문에, 소비자는 궁극적으로 `remove()` 메소드로 진입하여 생산자를 위한 버퍼의 공간을 비운다.

</br>

- 락을 위한 진입 및 **대기 집합**

<img width="485" alt="image" src="https://user-images.githubusercontent.com/106216912/213512607-ec038037-9f3e-4dbc-b07d-8030b60ed51b.png">

</br>

> **소비자 스레드는 생산자가 이제 진행할 수 있다는 것을 어떻게 알릴까?**

- 보통 스레드가 `synchronized` 메소드를 종료하면 이탈 스레드는 객체와 연결된 락만 해제하여 진입 집합에서 스레드를 제거하고 락 소유권을 넘겨준다.
    - 그러나, `insert()` 및 `remove()` 메소드의 끝에서 `notify()` 를 호출한다.

</br>

- `notify()` 메소드는 다음과 같은 일을 한다.
1. 대기 집합의 스레드 리스트에서 임의의 스레드 `T` 를 선택한다.
2. 스레드 `T` 를 대기 집합에서 진입 집합으로 이동한다.
3. `T` 의 상태를 봉쇄됨에서 실행 가능으로 설정한다.

</br>

- `T` 는 이제 다른 스레드와 락 경쟁을 할 수 있다.
    - `T` 가 락 제어를 다시 획득하면 `wait()` 호출에서 복귀하여 `count` 값을 다시 확인할 수 있다.

</br>

> 다음은 `wait()` 및 `notify()` 메소드를 설명한다.

→ 버퍼는 가득 차 있고, 객체의 락은 사용 가능하다고 가정한다.

- 생산자는 `insert()` 메소드를 호출하고 락이 사용 가능한지 확인한 후, 메소드로 진입한다.
    - 메소드에 들어가면 생산자는 버퍼가 가득 찼음을 확인하고, `wait()` 를 호출한다.
    - `wait()` 호출은 객체 락을 해제하고, 생산자 상태를 봉쇄됨으로 설정하고 생산자를 객체의 대기 집합에 둔다.

</br>

- 소비자는 이제 객체에 대한 락을 사용할 수 있으므로, `remove()` 메소드를 호출하고 진입한다.
    - 소비자는 버퍼에서 항목을 제거하고 `notify()` 를 호출한다.
    - 소비자는 여전히 개체에 대한 락을 소유하고 있다.

</br>

- `notify()` 호출은 객체의 대기 집합에서 생산자를 제거하고 생산자를 진입 집합으로 이동하고, 생산자의 상태를 실행 가능으로 설정한다.

</br>

- 소비자가 `remove()` 메소드를 종료한다.
    - 이 메소드를 종료하면 객체의 락이 해제된다.

</br>

- 생산자가 락을 다시 얻으려고 시도하고 성공한다.
    - `wait()` 호출에서 실행을 재개한다.
    - 생산자는 while 루프를 검사하고 버퍼에 여유 공간이 있는지 확인한 후 `insert()` 메소드의 남은 부분을 진행한다.
    - 객체의 대기 집합에 스레드가 없으면 `notify()` 호출은 무시된다.
    - 생산자가 메소드를 종료하면 객체에 대한 락이 해제된다.

</br>

→ `synchronized wait()` 및 `notify()` 기법은 Java에서 처음부터 제공되었으나, 이후 버전에서는 훨씬 더 융통성 있고 강력한 락 기법이 도입되었다.

</br>

### 재진입 락

→ ***API에서 사용 가능한 가장 간단한 락 기법은 `ReentrantLock` 이다.***

- `ReentrantLock` 은 `synchronized` 명령문처럼 작동한다.
    - 단일 스레드가 소유하며, 공유 자원에 대한 상호 배타적 액세스를 제공하는 데 사용된다.
    - 공정성 매개변수 설정과 같은 몇 가지 추가 기능을 제공한다.
    - **공정성** : 오래 기다린 스레드에 락을 줄 수 있는 설정

</br>

- 스레드는 `lock()` 메소드를 호출해서 `ReentrantLock` 락을 획득한다.
    - 락을 사용할 수 있거나 `lock()` 을 호출한 스레드가 이미 락을 소유하고 있는 경우, `lock()` 은 호출 스레드에게 락 소유권을 주고 제어를 반환한다.
    - 락을 사용할 수 없는 경우, 호출 스레드는 소유자가 `unlock()` 을 호출하여 락이 배정될 때까지 봉쇄된다.

</br>

- `ReentrantLock` 은 `Lock` 인터페이스를 구현한다.

<img width="245" alt="image" src="https://user-images.githubusercontent.com/106216912/213513056-3f924a12-8442-4543-ade9-688819305417.png">

</br>

- `lock()` 메소드를 통해 락을 획득한 경우, 락을 유사하게 해제하는 것이 중요하다.
    - `unlock()` 을 `finally` 절로 묶음으로써, 임계구역이 완료되거나 `try` 블록 내에서 예외가 발생하면 락이 해제되는 것을 보장한다.

</br>

- `ReentrantLock` 은 상호 배제를 제공하지만, 여러 스레드가 공유 데이터를 읽기만 하고 쓰지 않을 때는 너무 보수적인 전략일 수 있다.

</br>

→ 이러한 필요성을 해결하기 위해 Java API는 `ReentrantReadWriteLock` 을 제공한다.

- reader는 여러 개일 수 있지만, writer는 반드시 하나이어야 하는 전략이다.

</br>

### 세마포

→ ***Java API는 카운팅 세마포도 제공한다.***

- 세마포의 생성자는 다음과 같다.

<img width="203" alt="image" src="https://user-images.githubusercontent.com/106216912/213513225-f5accca7-e536-4440-abb0-b91df6dc26c3.png">

</br>

- `value` 는 세마포의 초기값을 지정한다.
    - 락을 획득하려는 스레드가 인터럽트 되면 `acquire()` 메소드가 `InterruptedException` 을 발생시킨다.
    - ex) 상호 배제를 위해 세마포를 사용하는 방법

<img width="294" alt="image" src="https://user-images.githubusercontent.com/106216912/213513303-2f03bd4e-5d53-4885-9de6-3527ccf25310.png">

</br>

### 조건 변수

→ ***Java API에서 다루는 마지막 유틸리티는 조건 변수이다.***

- 조건 변수는 `wait()` 및 `notify()` 메소드와 유사한 기능을 제공한다.
    - 상호 배제를 제공하려면 조건 변수를 재진입 락과 연관시켜야 한다.

</br>

- 먼저 `ReentrantLock` 을 생성하고, `newCondition()` 메소드를 호출해서 조건 변수를 생성한다.
    - 이 메소드는 연관된 `ReentrantLock` 의 조건 변수를 나타내는 `Condition` 객체를 반환한다.

<img width="342" alt="image" src="https://user-images.githubusercontent.com/106216912/213513430-dc81f5d0-7fb6-4fd8-bf3a-f193435b233b.png">

</br>

→ 조건 변수를 얻은 후에는 `wait()` 와 `signal()` 명령과 동일한 방식으로 작동하는 `await()` 및 `signal()` 메소드를 호출할 수 있다.

</br>

- Java는 기명 조건 변수에 대한 지원을 제공하지 않는다.
    - 각 Java 모니터는 무명 조건 변수 하나에만 연결되며, `wait()` 및 `notify()` 연산은 이 하나의 조건 변수에만 적용된다.
    - `notify()` 를 통해 Java 스레드를 깨우면 깨어난 이유에 대한 정보를 받지 않는다.
    - 대기 중인 조건이 충족되었는지 여부를 확인하는 것은 재활성화된 스레드 자신에게 달려 있고, 조건 변수는 통지받을 특정 스레드를 지정할 수 있게 하여 이를 해결한다.

</br>

- 예제

<img width="439" alt="image" src="https://user-images.githubusercontent.com/106216912/213513596-c6719567-fea0-4dc8-9161-3e8bc74054b0.png">

</br>

→ `ReentrantLock` 은 상호 배제를 제공하므로, `dowork()` 는 `synchronized` 로 선언할 필요가 없다.

- 스레드가 조건 변수에서 `await()` 를 호출하면 연관된 `ReentrantLock` 이 해제되어 다른 스레드가 상호 배제 락을 획득할 수 있다.
    - `signal()` 이 호출될 때 조건 변수에만 신호가 전달되고, 락은 `unlock()` 을 호출해서 해제한다.

---

## 5. 대체 방안들

→ ***병행 응용은 경쟁 조건과 교착 상태와 같은 라이브니스 위험을 증가시킨다.***

- 전통적으로 mutex 락, 세마포와 모니터와 같은 기법들이 이러한 쟁점을 해결하기 위해 사용되어 왔다.
    - 하지만, 처리 코어의 개수가 증가할수록 경쟁 조건과 교착 상태 위험이 없는 다중 스레드 응용을 설계하는 작업은 점점 더 어려워진다.

</br>

→ **스레드-안전 병행 응용 설계에 도움을 줄 수 있는 프로그래밍 언어와 하드웨어의 다양한 기능**을 알아본다.

</br>

### 트랜잭션 메모리

→ ***트랜잭션 메모리는 데이터베이스 이론 분야에서 출발한 아이디어지만, 프로세스 동기화 전략을 제공한다.***

- **메모리 트랜잭션** : 메모리 읽기와 쓰기 연산의 원자적인 연속적 순서
    - 한 트랜잭션의 모든 연산이 완수되면 메모리 트랜잭션은 **확정(commit)** 된다.
    - 그렇지 않다면, 그 시점까지 완수된 모든 연산은 취소되고, 트랜잭션 시작 이전의 상태로 **되돌려야(roll-back)** 한다.

</br>

- ex) 공유 데이터를 수정하는 `update()` 함수가 있다고 가정한다.
    - 이 함수는 mutex 락 또는 세마포를 사용해서 구현된다.

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213519772-716a636e-abc8-4137-9a11-2e85417d4a39.png">

</br>

- 하지만, 락과 세마포 같은 동기화 기법을 사용하는 것은 **교착 상태와 같은 많은 잠재적인 문제를 야기**할 수 있다.
    - 또한, 스레드의 개수가 증가할수록 락을 소유하기 위한 스레드의 경쟁 수준이 매우 높아지므로 전통적인 락킹 기법은 규모 적응성을 보이지 않는다.

</br>

> **전통적인 기법에 대한 대안으로, 트랜잭션 메모리의 이점을 취할 수 있는 새로운 기능을 추가할 수 있다.**

- ex) 새로운 구조물 `atomic{S}` 가 추가되었다고 가정한다.
    - 이 구조물은 `S` 내의 연산이 트랜잭션으로 실행된다는 것을 보장한다.

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213519898-7b4d7705-a1d0-41ae-b71e-925ff8aeca26.png">

</br>

- 락 대신 이러한 기법을 사용하는 이점은, **개발자가 아니라 트랜잭션 메모리 시스템이 원자성을 보장할 책임이 있다**는 것이다.
    - 또한 락이 전혀 사용되지 않기 때문에, **교착 상태가 발생하는 것이 불가능**하다.

</br>

> **트랜잭션 메모리는 소프트웨어 또는 하드웨어로 구현될 수 있다.**

- **소프트웨어 트랜잭션 메모리(STM)** 는 특별한 하드웨어 필요 없이 소프트웨어 만으로 구현된다.
    - STM은 트랜잭션 블록 안에 검사 코드를 삽입함으로써 동작한다.
    - 컴파일러에 의해 삽입되어, 명령문들이 동시에 실행될 수 있는 지점과 저수준 락킹이 필요한 지점을 검사함으로써 각 트랜잭션을 관리한다.

</br>

- **하드웨어 트랜잭션 메모리(HTM)** 는 개별 처리기 캐시에 존재하는 공유 데이터의 충돌을 해결하고, 관리하기 위해 하드웨어 캐시 계층 구조와 캐시 일관성 프로토콜을 사용한다.
    - HTM은 코드 계측이 필요없고, STM보다 적은 오버헤드를 가진다.
    - 하지만, 기존의 캐시 계층 구조와 캐시 일관성 프로토콜을 트랜잭션 메모리를 지원하기 위해 변경해야 한다.

</br>

### OpenMP

→ ***OpenMP는 컴파일러 디렉티브와 API로 구성된다.***

- **OpenMP가 가지는 장점** : 스레드의 생성과 관리가 OpenMP 라이브러리에 의해 처리되어 응용 개발자들은 신경 쓰지 않아도 된다.

</br>

- OpenMP는 `#pragma omp parallel` 과 `#pragma omp critical` 디렉티브를 제공한다.
    - 디렉티브 이후에 나오는 코드 구역을 임계구역으로 지정하여, 한 번에 하나의 스레드만이 실행할 수 있게 한다.

</br>

> **임계구역 컴파일러 디렉티브는 이진 세마포, 또는 mutex 락처럼 동작해서 한순간에 오직 하나의 스레드만이 임계구역을 실행한다는 것을 보장하게 한다.**

- **OpenMP에서 임계구역 컴파일러 디렉티브를 사용할 때의 이점**
    - 표준 mutex 락 보다 쉽게 사용할 수 있다.

</br>

- **단점**
    - 응용 개발자가 가능한 경쟁 조건을 직접 발견해야 한다.
    - 컴파일러 디렉티브를 이용해서 공유 메모리를 직접 보호해야 한다.
    - 두 개 이상의 임계구역이 관여되었을 때 교착 상태가 발생할 수 있다.

</br>

### 함수형 프로그래밍 언어

→ ***함수형 프로그래밍 언어는 상태를 유지하지 않는다.***

- 즉, **변수가 정의되어 값을 배정받으면 그 값은 변경될 수 없기 때문에 변하지 않는다.**
    - 변경 가능 상태를 허용하지 않기 때문에, 경쟁 조건이나 교착 상태와 같은 쟁점에 대해 신경 쓸 필요가 없다.
    - 대부분의 문제는 함수형 언어에서는 존재하지 않는다.