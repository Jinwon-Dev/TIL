> **이번 장에서는 6장에 제시된 도구를 몇 가지 고전적인 동기화 문제에 적용한다!**

- 또한, Linux, UNIX 및 Windows 운영체제에서 사용되는 동기화 기법을 알아본다.
- Java 및 POSIX 시스템의 API 세부 사항을 학습한다.

---

## 1. 고전적인 동기화 문제들

→ ***많은 클래스의 병행 제어(concurrency control) 문제에 대한 예로서, 중요한 여러 가지의 다른 동기화 문제들을 알아본다.***

- 동기화 문제에 대한 해결책을 제시할 때 전통적으로 세마포를 사용해 왔기 때문에, 우리의 해결안에서도 **세마포**가 사용된다.
    - 그러나 해결책을 실제 구현할 때는 이진 세마포 대신에 mutex 락이 사용될 수 있다.

</br>

### 유한 버퍼 문제(The Bounded-Buffer Problem)

→ ***이 문제는 일반적으로 동기화 프리미티브들의 능력을 설명하기 위해 사용된다.***

- 해결하려는 문제에서 소비자와 생산자는 다음과 같은 자료구조를 공유한다.

<img width="187" alt="image" src="https://user-images.githubusercontent.com/106216912/213464783-89c99083-05b8-406b-8e39-f35e765d15e8.png">

</br>

- `n` 개의 버퍼로 구성된 풀(pool)이 있으며, 각 버퍼는 한 항목을 저장할 수 있다고 가정한다.
    - `mutex` 이진 세마포는 버퍼 풀에 접근하기 위한 상호 배제 기능을 제공하며, `1` 로 초기화된다.
    - `empty` 와 `full` 세마포들은 각각 비어 있는 버퍼의 수, 꽉 찬 버퍼의 수를 기록한다.

</br>

> **생산자 코드**

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/213464918-0c4d0318-d758-4e90-8d72-c216494903c8.png">

</br>

> **소비자 코드**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/213465016-fec3d2fd-dabc-4422-b0e1-b2d73931ca54.png">

</br>

→ **생산자가 소비자를 위해 꽉 찬 버퍼를 생산해내고, 소비자는 생산자를 위해 비어 있는 버퍼를 생산**해낸다.

</br>

### Readers-Writers 문제

→ ***하나의 데이터베이스가 다수의 병행 프로세스 간에 공유된다고 가정한다.***

- **프로세스 중의 일부는 데이터베이스의 내용을 읽기**만 하고, **어떤 프로세스들은 데이터베이스를 갱신**하기를 원할 수 있다.
    - 전자를 **readers**, 후자를 **writers**로 불러서 두 가지 유형의 프로세스들을 구별한다.
    - 두 reader가 동시에 공유 데이터에 접근하더라도 상관없지만, **하나의 writer와 어떤 다른 스레드(reader 또는 writer)가 동시에 접근한다면, 혼란이 야기**될 수 있다!

</br>

→ **이 동기화 문제를 readers-writers 문제라고 한다.**

- 문제가 발생하지 않도록 보장하기 위해, 우리는 writer가 쓰기 작업 동안에 **공유 데이터베이스에 대해 배타적 접근 권한**을 가지게 할 필요가 있다.

</br>

> **Readers-Writers 문제에는 우선순위와 연관된 여러 가지 변형들이 존재한다.**

1. writer가 공유 객체를 사용할 수 있는 허가를 아직 얻지 못했다면, 어느 reader도 기다리게 해서는 안 된다.
    - 단순히 writer가 기다리고 있기 때문에, 다른 reader들이 끝날 때까지 기다리는 reader가 있어서는 안 된다.

</br>

2. 일단 writer가 준비되면 가능한 한 빨리 쓰기를 수행할 것을 요구한다.
    - writer가 객체에 접근하려고 기다리고 있다면, 새로운 reader들은 읽기를 시작하지 못한다.

</br>

→ 문제에 대한 해결안이 **기아 문제**를 낳을 수 있다!

- 첫 번째 경우는 writer가, 두 번째 경우는 reader가 기아 상태에 빠질 수 있다.

</br>

> **그렇다면 첫 번째 readers-writers 문제에 대한 해결안은?**

- reader 프로세스는 다음과 같은 자료구조를 공유한다.

<img width="217" alt="image" src="https://user-images.githubusercontent.com/106216912/213465302-682ea7e2-1237-4db4-8452-26c0a3f881c1.png">

</br>

- `rw_mutex` 세마포는 reader와 writer가 모두 공유한다.
    - `mutex` 세마포는 `read_count` 를 갱신할 때 상호 배제를 보장하기 위해 사용된다.
    - `read_count` 는 현재 몇 개의 프로세스들이 객체를 읽고 있는지 알려준다.
    - `rw_mutex` 는 다른 reader들이 임계구역 안에 있는 동안 임계구역을 드나드는 reader들은 이것을 사용하지 않는다.

</br>

> **Writer 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465444-8972a7da-1a89-4593-9a48-25ba511f0736.png">

</br>

> **Reader 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465540-f7d2beae-003c-42af-9e21-85c480756f92.png">

</br>

→ **Reader-Writers 문제와 해결안들은 일반화 되어, 몇몇 시스템에서는 reader-writer 락을 제공**한다.

- reader-writer 락을 획득할 때는 **읽기인지, 또는 쓰기인지의 모드를 지정**해야만 한다.
    - 프로세스가 **공유 데이터를 읽기만 원한다면 읽기 모드의 reader-writer 락**을, **공유 데이터의 수정을 원한다면 쓰기 모드의 reader-writer 락**을 요청한다.
    - 읽기 모드의 reader-writer 락은 여러 프로세스의 동시에 획득이 가능하다.
    - 반면, Writer는 공유 데이터를 배타적으로 접근해야 하므로, 오직 하나의 프로세스만이 쓰기 모드의 reader-writer 락을 획득할 수 있다.

</br>

> **Reader-Writer 락은 다음과 같은 상황에서 가장 유용하다.**

- 공유 데이터를 읽기만 하는 프로세스와 쓰기만 하는 스레드를 식별하기 쉬운 응용
- Writer보다 Reader의 개수가 많은 응용
    - 일반적으로 reader-writer 락을 설정하는 데 드는 오버헤드가, 세마포나 상호 배제 락을 설정할 때보다 크다.
    - 이 오버헤드는 동시에 여러 reader가 읽게 하여 병행성을 높임으로써 상쇄할 수 있다.

</br>

### 식사하는 철학자들 문제(The Dining-Philosophers Problem)

→ ***생각하고 먹으면서 그들의 생애를 보내는 5명의 철학자를 고려해 본다.***

<img width="242" alt="image" src="https://user-images.githubusercontent.com/106216912/213465787-aa20aff4-eddd-410a-8dec-9a009efa696c.png">

- 철학자들은 원형 테이블을 공유하며, 이 테이블은 각각 한 철학자에 속하는 5개의 의자로 둘러싸여 있다.
    - 테이블 중앙에는 한 사발의 밥이 있고, 테이블에는 다섯 개의 젓가락이 놓여 있다.
    - 철학자가 생각할 때는 다른 동료들과 상호 작용하지 않는다.
    
</br>

- 때때로 철학자들은 배가 고파지고, **자신에게 가장 가까이 있는 두 개의 젓가락을 집으려고 시도**한다.
    - **철학자는 한 번에 한 개의 젓가락**만 집을 수도 있다.
    - 또한, **철학자는 이미 옆 사람의 손에 들어간 젓가락을 집을 수는 없다.**
    - 배고픈 철학자가 동시에 젓가락 두 개를 집으면 젓가락을 놓지 않고 식사를 하고, 식사를 마치면 젓가락 두 개를 모두 놓는다.

</br>

→ **식사하는 철학자들 문제는 고전적인 동기화 문제로, 많은 부류의 병행 제어 문제의 한 예**이다.

- 교착 상태와 기아를 발생시키지 않고 여러 스레드에게 여러 자원을 할당해야 하는 필요의 예시이다.

</br>

> **세마포 해결안**

→ ***한 가지 간단한 해결책은 각 젓가락을 하나의 세마포로 표현하는 것이다.***

- 철학자는 세마포에 `wait()` 연산을 실행해서 젓가락을 집으려고 시도한다.
    - 또한, 해당 세마포에 `signal()` 연산을 실행함으로써 자신의 젓가락을 놓는다.

</br>

- 공유 자료는 다음과 같다.

<img width="214" alt="image" src="https://user-images.githubusercontent.com/106216912/213466024-fdab8cd5-bdc9-41e7-a0b1-3045cbee6ae5.png">

</br>

- 철학자 `i` 의 구조

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213466148-e838f3dd-cfe6-41b4-b4f1-dc638282f9e5.png">

</br>

→ 이 해결안은 인접한 **두 철학자가 동시에 식사하지 않는다는 것은 보장하지만, 교착 상태를 야기할 가능성**이 있다.

- 5명의 철학자 모두가 동시에 배가 고프게 되어, 각각 자신의 왼쪽 젓가락을 잡는다고 가정한다.
    - `chopstick` 의 모든 원소들은 `0` 이 되고, 각 철학자가 오른쪽 젓가락을 집으려고 하면 영원히 기다려야 한다.

</br>

> **교착 상태 문제에 대한 여러 가지 해결책들**

- 최대 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
- 한 철학자가 젓가락 두 개를 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.
    - 철학자는 임계구역 안에서만 젓가락을 집어야 한다.
- 비대칭 해결안을 사용한다.
    - 홀수 번호의 철학자는 먼저 왼쪽 젓가락을 집고, 다음에 오른쪽 젓가락을 집는다.
    - 짝수 번호의 철학자는 반대로 한다.

</br>

> **모니터 해결안**

→ ***모니터를 사용해 교착 상태가 없는 해결안을 제시할 수 있다.***

- 이 해결안은 철학자는 양쪽 젓가락을 모두 얻을 수 있을 때만 젓가락을 집을 수 있다는 제한을 강제한다.
    - 구현하려면, 철학자가 처할 수 있는 세 가지 상태들을 구분할 필요가 있다.
    - 다음의 자료구조를 도입한다.

<img width="336" alt="image" src="https://user-images.githubusercontent.com/106216912/213466322-8ed28b0c-62d6-469e-b3f1-ee7782069a66.png">

</br>

- 철학자 `i` 는 그의 양쪽 두 이웃이 식사하지 않을 때만 변수 `state[i] = EATING` 으로 설정할 수 있다.
    - 또한, 다음을 선언할 필요가 있다.

<img width="171" alt="image" src="https://user-images.githubusercontent.com/106216912/213466411-78057544-fae7-4beb-b716-bef1b357c83a.png">

</br>

- `self` 는 철학자 `i` 가 배고프지만 자신이 원하는 젓가락을 집을 수 없을 때 젓가락 집기를 미룰 수 있게 한다.

</br>

→ 젓가락의 분배는 모니터 `DiningPhilosophers` 에 의해 제어된다.

<img width="347" alt="image" src="https://user-images.githubusercontent.com/106216912/213466577-01046f1e-7510-4e41-81c1-baed75f74a00.png">

- 각 철학자는 식사하기 전에 `pickup()` 연산을 반드시 호출해야 한다.
    - 이 행동은 철학자 프로세스의 일시 중지를 낳을 수도 있다.
    - 연산이 성공적으로 끝나면, 철학자는 식사할 수 있다.

</br>

- 식사를 마친 후, 철학자는 `putdown()` 연산을 호출한다.
    - 철학자 `i` 는 반드시 다음과 같은 순서로 `pickup()` 과 `putdown()` 연산을 호출해야 한다.

<img width="245" alt="image" src="https://user-images.githubusercontent.com/106216912/213466693-68a0453e-9326-4fed-ba5e-e75bfd8e7d19.png">

</br>

→ 이 해결안은 **이웃한 두 철학자가 동시에 식사하지 않고, 교착 상태가 발생하지 않는다는 것을 보장하지만 철학자가 굶어 죽는 것이 가능**하다.

---