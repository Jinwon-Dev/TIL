> **이번 장에서는 6장에 제시된 도구를 몇 가지 고전적인 동기화 문제에 적용한다!**

- 또한, Linux, UNIX 및 Windows 운영체제에서 사용되는 동기화 기법을 알아본다.
- Java 및 POSIX 시스템의 API 세부 사항을 학습한다.

---

## 1. 고전적인 동기화 문제들

→ ***많은 클래스의 병행 제어(concurrency control) 문제에 대한 예로서, 중요한 여러 가지의 다른 동기화 문제들을 알아본다.***

- 동기화 문제에 대한 해결책을 제시할 때 전통적으로 세마포를 사용해 왔기 때문에, 우리의 해결안에서도 **세마포**가 사용된다.
    - 그러나 해결책을 실제 구현할 때는 이진 세마포 대신에 mutex 락이 사용될 수 있다.

</br>

### 유한 버퍼 문제(The Bounded-Buffer Problem)

→ ***이 문제는 일반적으로 동기화 프리미티브들의 능력을 설명하기 위해 사용된다.***

- 해결하려는 문제에서 소비자와 생산자는 다음과 같은 자료구조를 공유한다.

<img width="187" alt="image" src="https://user-images.githubusercontent.com/106216912/213464783-89c99083-05b8-406b-8e39-f35e765d15e8.png">

</br>

- `n` 개의 버퍼로 구성된 풀(pool)이 있으며, 각 버퍼는 한 항목을 저장할 수 있다고 가정한다.
    - `mutex` 이진 세마포는 버퍼 풀에 접근하기 위한 상호 배제 기능을 제공하며, `1` 로 초기화된다.
    - `empty` 와 `full` 세마포들은 각각 비어 있는 버퍼의 수, 꽉 찬 버퍼의 수를 기록한다.

</br>

> **생산자 코드**

<img width="335" alt="image" src="https://user-images.githubusercontent.com/106216912/213464918-0c4d0318-d758-4e90-8d72-c216494903c8.png">

</br>

> **소비자 코드**

<img width="390" alt="image" src="https://user-images.githubusercontent.com/106216912/213465016-fec3d2fd-dabc-4422-b0e1-b2d73931ca54.png">

</br>

→ **생산자가 소비자를 위해 꽉 찬 버퍼를 생산해내고, 소비자는 생산자를 위해 비어 있는 버퍼를 생산**해낸다.

</br>

### Readers-Writers 문제

→ ***하나의 데이터베이스가 다수의 병행 프로세스 간에 공유된다고 가정한다.***

- **프로세스 중의 일부는 데이터베이스의 내용을 읽기**만 하고, **어떤 프로세스들은 데이터베이스를 갱신**하기를 원할 수 있다.
    - 전자를 **readers**, 후자를 **writers**로 불러서 두 가지 유형의 프로세스들을 구별한다.
    - 두 reader가 동시에 공유 데이터에 접근하더라도 상관없지만, **하나의 writer와 어떤 다른 스레드(reader 또는 writer)가 동시에 접근한다면, 혼란이 야기**될 수 있다!

</br>

→ **이 동기화 문제를 readers-writers 문제라고 한다.**

- 문제가 발생하지 않도록 보장하기 위해, 우리는 writer가 쓰기 작업 동안에 **공유 데이터베이스에 대해 배타적 접근 권한**을 가지게 할 필요가 있다.

</br>

> **Readers-Writers 문제에는 우선순위와 연관된 여러 가지 변형들이 존재한다.**

1. writer가 공유 객체를 사용할 수 있는 허가를 아직 얻지 못했다면, 어느 reader도 기다리게 해서는 안 된다.
    - 단순히 writer가 기다리고 있기 때문에, 다른 reader들이 끝날 때까지 기다리는 reader가 있어서는 안 된다.

</br>

2. 일단 writer가 준비되면 가능한 한 빨리 쓰기를 수행할 것을 요구한다.
    - writer가 객체에 접근하려고 기다리고 있다면, 새로운 reader들은 읽기를 시작하지 못한다.

</br>

→ 문제에 대한 해결안이 **기아 문제**를 낳을 수 있다!

- 첫 번째 경우는 writer가, 두 번째 경우는 reader가 기아 상태에 빠질 수 있다.

</br>

> **그렇다면 첫 번째 readers-writers 문제에 대한 해결안은?**

- reader 프로세스는 다음과 같은 자료구조를 공유한다.

<img width="217" alt="image" src="https://user-images.githubusercontent.com/106216912/213465302-682ea7e2-1237-4db4-8452-26c0a3f881c1.png">

</br>

- `rw_mutex` 세마포는 reader와 writer가 모두 공유한다.
    - `mutex` 세마포는 `read_count` 를 갱신할 때 상호 배제를 보장하기 위해 사용된다.
    - `read_count` 는 현재 몇 개의 프로세스들이 객체를 읽고 있는지 알려준다.
    - `rw_mutex` 는 다른 reader들이 임계구역 안에 있는 동안 임계구역을 드나드는 reader들은 이것을 사용하지 않는다.

</br>

> **Writer 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465444-8972a7da-1a89-4593-9a48-25ba511f0736.png">

</br>

> **Reader 프로세스를 위한 코드**

<img width="244" alt="image" src="https://user-images.githubusercontent.com/106216912/213465540-f7d2beae-003c-42af-9e21-85c480756f92.png">

</br>

→ **Reader-Writers 문제와 해결안들은 일반화 되어, 몇몇 시스템에서는 reader-writer 락을 제공**한다.

- reader-writer 락을 획득할 때는 **읽기인지, 또는 쓰기인지의 모드를 지정**해야만 한다.
    - 프로세스가 **공유 데이터를 읽기만 원한다면 읽기 모드의 reader-writer 락**을, **공유 데이터의 수정을 원한다면 쓰기 모드의 reader-writer 락**을 요청한다.
    - 읽기 모드의 reader-writer 락은 여러 프로세스의 동시에 획득이 가능하다.
    - 반면, Writer는 공유 데이터를 배타적으로 접근해야 하므로, 오직 하나의 프로세스만이 쓰기 모드의 reader-writer 락을 획득할 수 있다.

</br>

> **Reader-Writer 락은 다음과 같은 상황에서 가장 유용하다.**

- 공유 데이터를 읽기만 하는 프로세스와 쓰기만 하는 스레드를 식별하기 쉬운 응용
- Writer보다 Reader의 개수가 많은 응용
    - 일반적으로 reader-writer 락을 설정하는 데 드는 오버헤드가, 세마포나 상호 배제 락을 설정할 때보다 크다.
    - 이 오버헤드는 동시에 여러 reader가 읽게 하여 병행성을 높임으로써 상쇄할 수 있다.

</br>

### 식사하는 철학자들 문제(The Dining-Philosophers Problem)

→ ***생각하고 먹으면서 그들의 생애를 보내는 5명의 철학자를 고려해 본다.***

<img width="242" alt="image" src="https://user-images.githubusercontent.com/106216912/213465787-aa20aff4-eddd-410a-8dec-9a009efa696c.png">

- 철학자들은 원형 테이블을 공유하며, 이 테이블은 각각 한 철학자에 속하는 5개의 의자로 둘러싸여 있다.
    - 테이블 중앙에는 한 사발의 밥이 있고, 테이블에는 다섯 개의 젓가락이 놓여 있다.
    - 철학자가 생각할 때는 다른 동료들과 상호 작용하지 않는다.
    
</br>

- 때때로 철학자들은 배가 고파지고, **자신에게 가장 가까이 있는 두 개의 젓가락을 집으려고 시도**한다.
    - **철학자는 한 번에 한 개의 젓가락**만 집을 수도 있다.
    - 또한, **철학자는 이미 옆 사람의 손에 들어간 젓가락을 집을 수는 없다.**
    - 배고픈 철학자가 동시에 젓가락 두 개를 집으면 젓가락을 놓지 않고 식사를 하고, 식사를 마치면 젓가락 두 개를 모두 놓는다.

</br>

→ **식사하는 철학자들 문제는 고전적인 동기화 문제로, 많은 부류의 병행 제어 문제의 한 예**이다.

- 교착 상태와 기아를 발생시키지 않고 여러 스레드에게 여러 자원을 할당해야 하는 필요의 예시이다.

</br>

> **세마포 해결안**

→ ***한 가지 간단한 해결책은 각 젓가락을 하나의 세마포로 표현하는 것이다.***

- 철학자는 세마포에 `wait()` 연산을 실행해서 젓가락을 집으려고 시도한다.
    - 또한, 해당 세마포에 `signal()` 연산을 실행함으로써 자신의 젓가락을 놓는다.

</br>

- 공유 자료는 다음과 같다.

<img width="214" alt="image" src="https://user-images.githubusercontent.com/106216912/213466024-fdab8cd5-bdc9-41e7-a0b1-3045cbee6ae5.png">

</br>

- 철학자 `i` 의 구조

<img width="291" alt="image" src="https://user-images.githubusercontent.com/106216912/213466148-e838f3dd-cfe6-41b4-b4f1-dc638282f9e5.png">

</br>

→ 이 해결안은 인접한 **두 철학자가 동시에 식사하지 않는다는 것은 보장하지만, 교착 상태를 야기할 가능성**이 있다.

- 5명의 철학자 모두가 동시에 배가 고프게 되어, 각각 자신의 왼쪽 젓가락을 잡는다고 가정한다.
    - `chopstick` 의 모든 원소들은 `0` 이 되고, 각 철학자가 오른쪽 젓가락을 집으려고 하면 영원히 기다려야 한다.

</br>

> **교착 상태 문제에 대한 여러 가지 해결책들**

- 최대 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.
- 한 철학자가 젓가락 두 개를 모두 집을 수 있을 때만 젓가락을 집도록 허용한다.
    - 철학자는 임계구역 안에서만 젓가락을 집어야 한다.
- 비대칭 해결안을 사용한다.
    - 홀수 번호의 철학자는 먼저 왼쪽 젓가락을 집고, 다음에 오른쪽 젓가락을 집는다.
    - 짝수 번호의 철학자는 반대로 한다.

</br>

> **모니터 해결안**

→ ***모니터를 사용해 교착 상태가 없는 해결안을 제시할 수 있다.***

- 이 해결안은 철학자는 양쪽 젓가락을 모두 얻을 수 있을 때만 젓가락을 집을 수 있다는 제한을 강제한다.
    - 구현하려면, 철학자가 처할 수 있는 세 가지 상태들을 구분할 필요가 있다.
    - 다음의 자료구조를 도입한다.

<img width="336" alt="image" src="https://user-images.githubusercontent.com/106216912/213466322-8ed28b0c-62d6-469e-b3f1-ee7782069a66.png">

</br>

- 철학자 `i` 는 그의 양쪽 두 이웃이 식사하지 않을 때만 변수 `state[i] = EATING` 으로 설정할 수 있다.
    - 또한, 다음을 선언할 필요가 있다.

<img width="171" alt="image" src="https://user-images.githubusercontent.com/106216912/213466411-78057544-fae7-4beb-b716-bef1b357c83a.png">

</br>

- `self` 는 철학자 `i` 가 배고프지만 자신이 원하는 젓가락을 집을 수 없을 때 젓가락 집기를 미룰 수 있게 한다.

</br>

→ 젓가락의 분배는 모니터 `DiningPhilosophers` 에 의해 제어된다.

<img width="347" alt="image" src="https://user-images.githubusercontent.com/106216912/213466577-01046f1e-7510-4e41-81c1-baed75f74a00.png">

- 각 철학자는 식사하기 전에 `pickup()` 연산을 반드시 호출해야 한다.
    - 이 행동은 철학자 프로세스의 일시 중지를 낳을 수도 있다.
    - 연산이 성공적으로 끝나면, 철학자는 식사할 수 있다.

</br>

- 식사를 마친 후, 철학자는 `putdown()` 연산을 호출한다.
    - 철학자 `i` 는 반드시 다음과 같은 순서로 `pickup()` 과 `putdown()` 연산을 호출해야 한다.

<img width="245" alt="image" src="https://user-images.githubusercontent.com/106216912/213466693-68a0453e-9326-4fed-ba5e-e75bfd8e7d19.png">

</br>

→ 이 해결안은 **이웃한 두 철학자가 동시에 식사하지 않고, 교착 상태가 발생하지 않는다는 것을 보장하지만 철학자가 굶어 죽는 것이 가능**하다.

---

## 2. 커널 안에서의 동기화

→ ***Windows, Linux 운영체제에서 제공되는 동기화 기법을 알아본다.***

</br>

### Windows의 동기화

→ ***Windows 운영체제는 실시간 응용과 다중 처리기 지원을 제공하는 다중 스레드 커널이다.***

- Windows 커널이 단일 처리기에서 전역 정보를 액세스할 때는 동일한 전역 정보를 액세스할 가능성이 있는 인터럽트 핸들러가 실행되지 않도록, 인터럽트를 잠시 동안 못 걸리게 막는다.
    - 다중 처리기 시스템에서는 **스핀락**을 써서 전역 정보 액세스를 통제한다.
    - 하지만, Windows 커널은 짧은 코드에 대해서만 스핀락을 사용한다.
    - 효율성을 위해서 스레드가 스핀락을 가지고 있는 동안은 선점되지 않도록 보장한다.

</br>

> **커널 외부에서 스레드를 동기화하기 위해 dispatcher 객체를 제공한다.**

- 스레드는 dispatcher 객체를 사용해서 mutex 락, 세마포, event 및 타이머를 포함한 다양한 기법에 맞추어 동기화할 수 있다.
    - 시스템은 데이터에 접근하기 위해 스레드가 mutex의 소유권을 획득한 후, 필요한 작업이 끝난 후에는 다시 반납하게 함으로써 공동으로 사용하는 데이터를 보호한다.

</br>

- **Event**는 조건 변수와 유사하다.
    - 즉, 기다리는 조건이 만족하면 기다리고 있는 스레드에 통지해 줄 수 있다.
    - 타이머는 지정한 시간이 만료되면 하나, 또는 둘 이상의 스레드에 통지하는 데 사용된다.

</br>

> **Dispatcher 객체는 signaled 상태에 있을 수도 있고, nonsignaled 상태에 있을 수도 있다.**

<img width="357" alt="image" src="https://user-images.githubusercontent.com/106216912/213477401-d869333e-8595-4e54-97ef-f08c3e52d349.png">

- **Signaled 상태** : 객체가 사용 가능하고, 그 객체를 얻을 때 그 스레드가 봉쇄되지 않음
- **Nonsignaled 상태** : 객체가 사용할 수 없고, 그 객체를 얻으려고 시도하면 그 스레드가 봉쇄됨

</br>

> **Dispatcher 객체의 상태와 스레드 상태 간에는 관련성이 있다.**

- 스레드가 nonsignaled 상태에 있는 dispatcher 객체 때문에 봉쇄되면, 그 스레드의 상태는 준비로부터 대기 상태로 바뀌고 그 스레드는 그 객체의 대기 큐에 넣어지게 된다.
    - 그 후, dispatcher 객체의 상태가 signaled 상태로 바뀌면 커널은 그 객체를 기다리는 스레드가 있는지 여부를 알아내어, 있으면 그 하나의 스레드를 대기 상태로부터 준비 상태로 바꾸어 다시 실행을 재개할 수 있도록 조치한다.

</br>

> **Critical-section 객체는 커널의 개입 없이 획득하거나 방출할 수 있는 사용자 모드 mutex이다.**

- 다중 처리기 시스템에서 **critical-section 객체**는 처음에는 스핀락을 사용하여 다른 스레드가 객체를 방출하기를 기다린다.
    - 회전이 길어지게 되면 락을 획득하려는 프로세스는 커널 mutex를 할당하고, CPU를 양도한다.

</br>

→ Critical-section 객체는 **커널 mutex는 객체에 대한 경쟁이 발생할 때만 할당되기 때문에 효율적**이다.

- 경쟁은 거의 발생하지 않기 때문에, CPU 절약은 상당히 좋아진다.

</br>

### Linux의 동기화

→ ***Linux 커널은 완전히 선점 가능하며, 커널 모드에서 실행 중일 때도 태스크는 선점될 수 있다.***

- Linux는 커널 안에서 동기화를 할 수 있는 많은 다른 기법을 제공한다.
    - 가장 간단한 동기화 기법은 **원자적 정수**이다.
    - 차단된 데이터 형인 `atomic_t` 데이터 형을 사용하여 표현한다.

</br>

- 원자적 정수를 사용하는 모든 수학 연산은 중단됨 없이 수행된다.

<img width="160" alt="image" src="https://user-images.githubusercontent.com/106216912/213477953-b1ff994a-c592-43fa-8c4e-1e6b2d83923b.png">

</br>

- 다음 코드는 다양한 원자적 연산을 수행한 효과를 보여준다.

<img width="435" alt="image" src="https://user-images.githubusercontent.com/106216912/213478079-9e6cf51e-d866-4d4c-acb5-bede545e4cbf.png">

</br>

> **원자적 정수는 `counter` 와 같은 정수형 변수가 갱신되어야 하는 상황에서 특히 효율적이다.**

→ **원자적 연산은 락 기법을 사용할 때의 오버헤드가 필요 없기 때문이다.**

- 하지만 이러한 종류의 상황에서만 유용하다는 제약이 있다.

</br>

> **Linux에서 커널 안의 임계구역을 보호하기 위해 mutex 락이 제공된다.**

- 태스크는 임계구역에 들어가기 전에 `mutex_lock()` 함수를 호출해야 하고, 나오기 전에 `mutex_unlock()` 함수를 호출해야 한다.
    - mutex 락을 획득할 수 없으면 `mutex_lock()` 을 호출한 태스크는 수면 상태에 놓이고, 락의 소유자가 `mutex_unlock()` 을 호출할 때 깨어나게 된다.

</br>

> **Linux 커널은 커널 안에서의 락킹을 위해서 스핀락과 세마포 및 두 락의 reader-writer 버전도 제공한다.**

→ SMP 기계에서는 기본적인 락킹 기법이 **스핀락**이다.

</br>

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/213478373-ace71b80-8540-4da1-be5c-2b21d52aa4d9.png">

- 스핀락이 단지 짧은 시간 동안만 소유되도록 커널이 설계되었다.
    - 하나의 처리 코어를 가진 시스템에서는 스핀락을 획득하는 것이 아니라, 커널이 커널 선점을 불가능하게 한다.
    - 또한, 스핀락을 방출하는 것이 아니라 커널은 커널 선점을 가능하게 한다.

</br>

→ ***Linux 커널에서 스핀락과 mutex 락은 재귀적이지 않다.***

- 즉, **스레드가 이러한 락 중 하나를 획득했다면 획득한 락을 해제하지 않고는 같은 락을 다시 획득할 수 없다.**
    - 해제하지 않으면 락을 획득하려는 두 번째 시도는 봉쇄된다.

</br>

> **Linux는 커널 선점을 불능케 하고 가능케 하는 데 흥미로운 방식을 사용한다.**

→ **`preempt_disable()` 과 `preempt_enable()` 이라는 두 개의 간단한 시스템 콜을 제공한다.**

</br>

→ 스핀락과 커널 선점 불능 및 가능은 오직 **락, 또는 커널 선점 불가능이 짧은 시간 동안만 유지될 때 사용**된다.

- 락이 오랜 시간 동안 유지되어야 한다면, 세마포 또는 mutex 락을 사용하는게 적절하다.

---