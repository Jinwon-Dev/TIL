## 1. 파일 시스템 구조

→ ***파일 시스템을 유지하기 위한 보조저장장치로 디스크가 대부분 사용된다.***

</br>

> **디스크가 보조저장장치로 사용되는 2가지 이유**
> 
1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
    - 디스크로부터 한 블록을 읽고, 변경하여 같은 블록에 재기록이 가능하다.

</br>

2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.
    - 따라서, 임의의 파일을 순차적 또는 무작위 방법으로 쉽게 접근할 수 있다.

</br>

> **I/O 효율성을 향상하기 위해 메모리와 대용량 스토리지 간의 I/O 전송이 블록 단위로 수행된다.**
> 
- 하드 디스크 드라이브의 각 블록에는 하나 이상의 섹터가 있다.

</br>

> **파일 시스템은 쉽게 데이터를 저장하고, 찾고 또한 인출할 수 있게 함으로써 저장장치를 더욱 효율적이고 편리하게 사용할 수 있게 한다.**
> 
- 파일 시스템은 크게 두 가지의 설계 문제를 제기한다.
    - 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의하는 것
    - 논리 파일 시스템을 물리적인 2차 저장장치로 사상하는 알고리즘과 데이터 구조를 만드는 것

</br>

> **파일 시스템은 여러 층으로 이루어져 있다.**
> 
<img width="147" alt="image" src="https://user-images.githubusercontent.com/106216912/227697066-32c4ccd6-656c-49c5-bb3a-84fcb24da5dd.png">

- **입/출력 제어 층**
    - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져 있어서 메모리와 디스크 시스템 간의 정보 전송을 담당한다.

</br>

- **기본 파일 시스템 층**
    - 적절한 장치 드라이버에게 저장장치상의 블록을 읽고 쓰도록 일반적인 명령을 내린다.
    - 논리 블록 주소를 기반으로 드라이브에 명령일 내리고, I/O 요청 스케줄링도 고려한다.
    - 또한, 다양한 파일 시스템과 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.

</br>

- **파일-구성 모듈**
    - 파일과 상응하는 논리 블록을 알고 있다.
    - 어느 디스크 공간이 비어 있는지를 파악하는 가용 공간 관리자를 포함한다.

</br>

- **논리 파일 시스템 층**
    - 메타데이터 정보를 관리한다.
    - 파일 구조는 파일 제어 블록을 통해 유지된다.
    - **파일 제어 블록(FCB)** 는 소유, 허가 그리고 파일 내용의 위치를 포함하여 파일에 관한 정보를 가지고 있다.

</br>

> **파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드의 중복이 최소화되었다.**
> 
- 다수의 파일 시스템에 의해 I/O 제어와 때로는 기본 파일 시스템 코드가 사용될 수 있다.
    - 그 경우, 각 파일 시스템은 자신의 논리 파일 시스템과 파일 구조 모듈을 가지고 있다.
    - 하지만 계층화는 **더 많은 운영체제 오버헤드를 야기하여 성능을 저하**한다.

---

## 2. 파일 시스템 구현

→ ***이 절에서는 파일 시스템 연산을 구현하는 데 사용되는 구조와 연산에 대해 깊이 살펴본다.***

</br>

### 개요

→ ***여러 저장장치상의 구조와 메모리 내 구조가 파일 시스템을 구현하는 데 사용된다.***

</br>

> **파일 시스템은 저장장치에 저장된 운영체제를 어떻게 부트시키는지, 블록의 총수, 가용 블록의 수와 위치, 디렉터리 구조, 개별 파일에 대한 정보를 디스크 상에 가지고 있다.**
> 
- **부트 제어 블록**
    - 시스템이 그 파티션으로부터 운영체제를 부트시키는 데 필요한 정보를 가지고 있다.
    - 부트 제어 블록은 일반적으로 한 파티션의 첫 번째 블록이다.
    - UFS에서는 **부트 블록**, NTFS에서는 **파티션 부트 섹터**라고 불린다.

</br>

- **볼륨 제어 블록**
    - 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 가용 FCB 수와 포인터 같은 볼륨 정보를 포함한다.
    - UFS에서는 **슈퍼 블록**, NTFS에서는 **마스터 파일 테이블**이라 불린다.

</br>

- **디렉터리 구조**
    - 파일을 조직화하는 데 사용된다.
    - UFS에서는 디렉터리 구조에 파일 이름 및 해당 `inode` 번호가 저장된다.
    - NTFS에서는 마스터 파일 테이블에 이러한 정보가 저장된다.

</br>

- **파일별 FCB**
    - 자세한 파일 정보를 가지고 있다.
    - FCB는 디렉터리 항목과의 연결을 위하여 고유한 식별 번호를 가지고 있다.

</br>

> **메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.**
> 
- **메모리 내 파티션 테이블**
    - 마운트된 모든 파티션 정보를 포함한다.

</br>

- **메모리 내 디렉터리 구조**
    - 최근 접근된 디렉터리의 디렉터리 정보를 가진다.

</br>

- **범 시스템 오픈 파일 테이블**
    - 다른 정보와 더불어 오픈된 각 파일의 FCB의 복사본을 가지고 있다.

</br>

- **프로세스별 오픈 파일 테이블**
    - 프로세스가 연 모든 파일에 대해 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다.

</br>

- **버퍼**
    - 파일 시스템이 파일 시스템으로부터 읽히거나 써질 때, 파일 시스템 블록을 저장한다.

</br>

> **새로운 파일을 생성하기 위해 프로세스는 논리 파일 시스템을 호출한다.**
> 
<img width="333" alt="image" src="https://user-images.githubusercontent.com/106216912/227697888-0b501083-d828-4d04-bef9-28d2a36b4a0d.png">

- 논리 파일 시스템은 디렉터리 구조의 포맷을 알고 있다.
    - 새로운 파일을 생성하기 위해 파일 시스템은 새로운 FCB를 할당하고, 해당 디렉터리를 메모리로 읽어 새로운 파일과 FCB로 디렉터리를 갱신한다.
    - 그 후, 파일 시스템에 다시 쓴다.

</br>

### 사용법

→ ***일단 새로운 파일이 생성되면 입출력을 위해 사용될 수 있다.***

<img width="476" alt="image" src="https://user-images.githubusercontent.com/106216912/227697901-3c3e6ee8-5c3c-4525-9401-9440520de387.png">

- 우선 파일이 반드시 오픈되어야 하며, `open()` 시스템 콜은 논리적 파일 시스템에 파일 이름을 넘겨준다.
    - `open()` 시스템 콜은 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위해 범 시스템 오픈 파일 테이블을 검색한다.
    - 사용 중이면, 기존 범 시스템 오픈 파일 테이블을 가리키는 프로세스별 오픈 파일 테이블 항목이 생성된다.
        - 이 알고리즘은 상당한 오버헤드를 줄일 수 있다.

</br>

- 만일 파일이 오픈되지 않았다면, 주어진 파일 이름을 디렉터리 구조에서 찾는다.
    - 디렉터리 연산의 속도를 향상하기 위해 통상 디렉터리 구조의 일부를 메모리에 캐싱한다.
    - 파일이 발견되면 FCB가 메모리내의 범 시스템 오픈 파일 테이블에 복사된다.

</br>

> **다음으로, 범 시스템 오픈 파일 테이블의 항목에 대한 포인터와 몇 개의 다른 필드를 갖는 새로운 항목이 프로세스별 오픈 파일 테이블 안에 만들어진다.**
> 
- 이 필드들은 파일 안의 현재 위치를 가리키는 포인터와 파일이 오픈된 접근 모드 등을 포함한다.
    - `open()` 시스템 콜은 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 찾아 돌려준다.
    - 그 후, 모든 파일 연산은 이 포인터를 통해 실행된다.

</br>

- **파일 디스크립터(파일 핸들)**
    - 일단 해당 FCB를 디스크에서 찾으면 시스템은 파일 이름을 더는 사용하지 않기 때문에, 파일 이름은 오픈 파일 테이블의 한 부분이 아니다.
    - 그러나, 이것은 같은 파일에 대한 다중 오픈 연산을 빠르게 하기 위해 캐쉬될 수 있다.

</br>

→ **이러한 기법을 사용함으로써, 실제 데이터 블록을 제외한 오픈 파일에 대한 모든 정보는 메모리 내에 존재한다!**

---

## 3. 디렉터리 구현

→ ***디렉터리 공간을 어떻게 할당하고 어떻게 관리하는가는 파일 시스템의 효율, 성능과 신뢰성에 큰 영향을 미친다.***

- 따라서, 이들 알고리즘과 연관되어 있는 문제점들을 이해할 필요가 있다!

</br>

### 선형 리스트

→ ***디렉터리를 구현하는 가장 간단한 방법은, 파일 이름과 데이터 블록에 대한 포인터들의 선형 리스트를 디렉터리에 사용하는 것이다.***

- 이 방법은 프로그램이 쉽지만, 실행 시간이 길다.
    - 새로운 파일을 생성하기 위해서는 먼저 디렉터리를 탐색하여 같은 이름을 가진 파일이 존재하지 않는다는 것을 확인한 후, 디렉터리의 끝부분에 새로운 항목을 첨가하면 된다.
    - 한 파일을 삭제하려면 디렉터리에서 이름을 찾아 그 파일에 할당된 공간을 방출한다.

</br>

- 디렉터리 항목을 재사용하기 위해 여러 가지 중 하나를 수행할 수 있다.
    - 항목을 미사용으로 표시하거나, 가용 디렉터리 항목 리스트에 추가할 수 있다.
    - 사용 가능하게 된 항목에 제일 마지막 항목을 복사해 넣고 디렉터리의 길이를 하나 줄일 수 있다.

</br>

> **선형 리스트로 구성된 디렉터리의 가장 큰 단점**
> 

→ ***선형 탐색을 해야 한다는 점이다.***

- 디렉터리는 빈번하게 사용되고, 속도가 느리면 사용자는 이를 바로 느낄 것이다.
    - 실제 많은 운영체제는 가장 최근에 사용된 디렉터리 정보를 저장하기 위해 소프트웨어 캐시를 구현하고 있다.
    - 캐시 적중은 그 정보를 매번 보조저장장치로부터 읽어오는 것을 피할 수 있게 한다.

</br>

- 정렬된 리스트는 이진 탐색을 가능케 하며, 평균 탐색 시간을 줄인다.
    - 그렇지만, 리스트가 정렬 상태를 유지하려면 파일을 생성하거나 삭제하는 일이 복잡해질 수 있다.
    - 정렬을 유지하기 위해 상당한 정보를 이동해야 할 수도 있기 때문이다.

</br>

### 해시 테이블

→ ***또 다른 디렉터리의 구조로 해시 테이블(hash table)을 사용한다.***

- 파일 이름을 제시하면 해시로부터 값을 얻어서 그것을 포인터로 활용하여 이 리스트를 직접 접근할 수 있다.
    - 해시의 특성상 성능은 크게 개선된다.
    - 그러므로, 디렉터리 탐색 시간을 상당히 개선할 수 있다.

</br>

> **해시 테이블의 심각한 문제점**
> 
→ ***해시 테이블이 고정된 크기를 갖는다는 점과, 해시 테이블의 크기에 따라 해시 기능도 제한을 받는다는 점이다.***

- 대안으로, **체인 오버플로우 해시 테이블**을 사용할 수 있다.
    - 각 해시 항목은 하나의 값이 아니라 연결 리스트가 되고, 새로운 항목을 연결 리스트에 추가함으로써 충돌을 해결한다.

---

## 4. 할당 방법

→ ***주요 문제는 파일들을 어떻게 저장장치 공간에 배치해야 디스크 공간을 효율적으로 사용할 수 있고, 파일들을 빨리 접근할 수 있는가 하는 것이다.***

- 저장장치 공간을 할당하기 위해서는 세 가지 주된 방법은 **연속, 연결, 인덱스 기법**이 널리 사용되며, 방법마다 장단점이 있다.

</br>

### 연속 할당

→ ***연속 할당은 각 파일이 저장장치 내에서 연속적인 공간을 차지하도록 요구한다.***

- 장치 주소들은 장치상에서 선형 순서를 정의한다.
    - 이러한 순서를 따를 경우, 단지 한 작업이 장치에 접근한다고 가정하고, 블록 `b` 다음에 블록 `b+1` 을 접근한다면 통상 헤드 이동을 요하지 않는다.
    - 헤드의 이동이 필요한 경우, 단지 한 트랙만 이동하면 된다.

</br>

→ 따라서, HDD의 경우 연속 할당된 파일들을 접근하기 위해서 필요한 디스크 탐색의 횟수를 최소화할 수 있다.

- 결국 탐색이 필요할 경우라도 탐색 시간이 최소화된다!

</br>

> **한 파일의 연속 할당은 첫 번째 블록의 주소와 길이로 정의된다.**
> 
<img width="328" alt="image" src="https://user-images.githubusercontent.com/106216912/227701156-f464279d-9e58-4428-9147-1aa781784332.png">

- 파일의 길이가 `n` 블록이고 블록 `b` 에서 시작한다면, 이 파일은 블록 `b` , `b+1` , `b+2` , …, `b+n-1` 을 차지한다.
    - 각 파일을 위한 디렉터리 항목은 이 파일의 디스크 내 시작 블록 주소와 이 파일의 크기만 표시하면 된다.
    - 연속 할당은 구현하기 쉽지만, 한계가 있기 때문에 최신 파일 시스템에서는 사용되지 않는다.

</br>

> **연속 할당 기법에는 몇 가지 문제가 있다.**
> 
- 새로운 파일을 위한 가용 공간을 찾는 일이다.
    - 가용 공간 관리 방법은 어떻게 이러한 문제를 해결할지를 결정한다.

</br>

→ 이 문제는 널리 알려진 문제로써, **동적 공간 할당** 문제의 특정 응용으로 볼 수 있다.

- 최초 적합과 최적 적합이 가용 공간 중에서 할당할 공간을 선택하는 가장 일반적인 전략이다.
    - 최초 적합이나 최적 적합 모두 저장장치 이용 면에서 최적은 아니지만, 일반적으로 최초 적합이 더 빠르다.

</br>

> **이들 알고리즘은 모두 외부 단편화 때문에 어려움이 있다.**
> 
- 파일이 할당되고 반납됨에 따라 가용 디스크 공간이 조그만 조각으로 나누어진다.
    - **외부 단편화**는 가용 공간이 덩어리들로 나누어질 때마다 발생한다.
    - 그러다가, 제일 큰 연속된 덩어리가 요구된 크기보다 작을 때 문제가 된다.

</br>

> **외부 단편화로 인한 공간의 상당한 향의 공간 손실을 방지하는 하나의 정책**
> 
→ ***전체 파일 시스템을 다른 장치로 복사하는 것***

- 원래의 장치는 완전히 비게 되어 하나의 커다란 연속적인 가용공간이 된다.
    - 그런 후에 이 공간으로부터 할당받으면서 파일들을 원래의 장치로 다시 복사하게 된다.
    - 이 기법은 효과적으로 모든 가용 공간을 하나의 연속공간으로 **밀집**함으로써 해결한다.

</br>

- 그러나, 대용량 저장장치의 경우에 이 밀집에 드는 시간과 비용이 매우 많이 들 수 있다.
    - 일부 시스템에서는 이러한 작업을 파일 시스템의 마운트를 해제한 상태로 **오프라인** 시점에 처리한다.

</br>

> **연속 할당의 또 다른 문제점**
> 
→ ***파일을 위해서 얼마나 많은 공간을 주어야 할 지를 결정하는 것***

- 만약 너무 작은 공간을 예약했다면 파일이 커질 수 없다.
    - 특히 최적 적합 방법으로 공간을 할당했다면, 양 끝에 인접한 공간이 모두 사용 중이기 때문에 파일을 그 자리에서 확장할 수 없다.

</br>

- 이에 대한 해결 방법으로는 두 가지 방법이 존재한다.
    - 확장이 안 될 경우 사용자에게 오류 메시지를 출력하고 프로그램을 종료시키는 방법
    - 보다 큰 조각을 찾아 그곳으로 파일을 복사하고 이전의 공간을 비우는 방법

</br>

→ 한 파일에 필요한 공간의 크기를 미리 알 수 있다 해도, **선 할당은 비효율적이다!**

- 이런 단점들을 최소화하기 위해서, 운영체제는 어느 정도의 연속된 공간만 초기에 할당하고 그 양이 충분히 크지 않을 때는, 추후 `n` 개의 연속된 공간을 단위로 할당한다.

</br>

### 연결 할당

→ **연결 할당은 연속 할당의 모든 문제를 해결한다.**

<img width="294" alt="image" src="https://user-images.githubusercontent.com/106216912/227701229-860b152c-8b50-4a59-b523-c97e4555c741.png">

- 연결 할당의 경우 파일은 저장장치 블록의 연결 리스트 형태로 저장되고, 이 블록들은 장치 내에 흩어져 저장될 수 있다.
    - 디렉터리는 파일의 첫 번째와 마지막 블록에 대한 포인터를 가지고 있다.

</br>

> **새 파일을 생성하려면 단순히 디렉터리 내에 새로운 항목(entry)을 만든다.**
> 
- 연결 할당의 경우 각 디렉터리 항목은 파일의 첫 블록에 대한 포인터를 갖고 있다.
    - 이 포인터는 처음에는 빈 파일을 표시하기 위해 `null` 값으로 초기화된다.
    - 파일 쓰기가 일어나면 가용 블록을 할당받아 쓰기를 수행한 후, 파일의 끝에 연결한다.

</br>

- 또한, 연결 할당의 경우 외부 단편화가 없고 모든 블록은 크기가 같기 때문에 가용 공간 리스트의 어떠한 가용 블록들을 이용하여도 무방하다.
    - 파일 생성 시 생성할 파일의 크기가 미리 고정될 필요도 없다.

</br>

> **그러나, 이 방법도 단점을 가지고 있다.**
> 

→ ***순차적 접근 파일에만 효과적으로 사용될 수 있고, 직접 접근 방식에는 매우 비효율적이다.***

- `i` 번째 블록을 찾으려면, 그 파일의 첫 블록 한 번의 저장장치 읽기와 때로는 HDD 탐색이 필요하다.
    - 따라서, 연결 할당 파일에 대한 직접 접근은 대단히 비효율적이다.
- 또 다른 단점은, 포인터들을 위한 공간이 필요하다는 것이다.

</br>

> **이 문제에 대한 일반적인 해결책은, 블록을 모아 클러스터라고 하는 단위로 만들고 블록이 아닌 클러스터를 할당하는 것이다.**
> 
- 이 방법을 사용하면 논리적-물리적 블록 매핑을 간단하게 유지할 수 있다.
    - 하지만, 디스크 헤드 탐색이 줄어들기 때문에 HDD 처리량이 향상되고 블록 할당 및 가용 리스트 관리에 필요한 공간이 줄어든다.

</br>

> **또 다른 문제는 신뢰성의 문제이다.**
> 
- 각 블록이 전체 장치에 흩어져 연결되기 때문에, 오류나 하드웨어의 고장으로 인하여 하나의 포인터를 잃어버리거나 잘못된 포인터 값을 가지게 되면 모든 데이터를 잃을 수 있다.
    - 이 경우, 이중 연결 리스트를 사용하거나 블록마다 파일 이름과 상대 블록 번호 등을 저장하여 해결할 수 있다.
        - 하지만, 이러한 기법들은 더 많은 부담을 필요로 한다.

</br>

> **한 가지 중요한 변형은 파일 할당 테이블(FAT)를 사용하는 것이다.**
> 

→ ***단순하지만 효율적인 이 방법은 MS-DOS 운영체제에서 사용된다.***

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/227701280-ab9a5e60-61a3-41c0-a9db-45961f15f2a6.png">

- 각 파티션의 시작 부분이 FAT로 사용된다.
    - 이 FAT 테이블은 각 블록마다 한 개의 항목을 가지고 있고, 이 항목은 디스크 블록 번호를 인덱스로 갖는다.
    - 디렉터리의 항목은 각 파일의 첫 번째 블록 번호를 가리킨다.
    - 그 블록 번호를 가지고 FAT 테이블로 가면 그 항목은 다음 블록의 블록 번호를 가리킨다.
    - 이러한 사슬은 마지막 블록까지 계속되며, 마지막 블록의 테이블 항은 파일의 끝을 나타내는 특수한 값을 갖고 있다.

</br>

> **FAT 할당 기법은 FAT가 캐시 되지 않으면 상당한 수의 디스크 찾기를 유발할 수 있다.**
> 
- FAT를 읽기 위해 디스크 헤드를 반드시 파티션의 시작 부분으로 움직여, 찾고자 하는 블록의 주소를 알아내야 한다.
    - 이어서, 그 블록이 있는 곳으로 다시 이동해야 한다.
    - 최악의 경우, 각 블록을 찾을 때마다 두 번의 이동이 일어나야 한다.

</br>

### 색인 할당

→ ***색인 할당은 모든 포인터들을 하나의 장소, 즉 색인 블록으로 관리함으로써 문제들을 해결한다.***

<img width="338" alt="image" src="https://user-images.githubusercontent.com/106216912/227701344-ce137a46-b9b6-4a31-934a-8eaccef25404.png">

- 각 파일은 저장장치 블록 주소를 모아 놓은 배열인 **색인(index)** 블록을 가진다.
    - 색인 블록의 `i` 번째 항목은 파일의 `i` 번째 블록을 가리킨다.
    - 디렉터리는 색인 블록의 주소를 가지고 있다.
    - `i` 번째 블록을 읽기 위해서는 색인 블록 항목에 있는 `i` 번째 항목에서 포인터를 얻어서 그 블록을 읽는다.

</br>

> **저장장치의 어느 블록이든 더 많은 공간의 요청을 만족시킬 수 있기 때문에 색인 할당은 외부 단편화 없이 직접 접근을 지원한다.**
> 
- 그러나, 색인 할당은 공간 낭비로 인한 어려움을 겪는다.
    - 색인 블록의 포인터 오버헤드는 일반적으로 연결 할당의 포인터 오버헤드보다 크다.
    - 색인 할당을 사용하면 하나 또는 두 개의 포인터만 `null` 이 아니어도 전체 색인 블록을 할당해야 한다.

</br>

> **색인 블록이 너무 작으면, 큰 파일에 대한 충분한 포인터를 보유할 수 없다!**
> 

→ ***그러므로, 이 문제를 처리하는 기법이 제공되어야 한다.***

- **연결 기법**
    - 하나의 색인 블록은 통상 한 저장장치 블록이다.
    - 파일의 크기가 크면 여러 개의 색인 블록을 연결한다.

</br>

- **다중 수준 색인**
    - 연결 기법의 변형으로서 여러 개의 두 번째 수준 색인 블록들의 집합을 가리키기 위하여 첫 번째 수준의 색인 블록을 사용한다.
    - 두 번째 수준의 색인 블록은 실제 파일 블록들을 가리킨다.

</br>

<img width="382" alt="image" src="https://user-images.githubusercontent.com/106216912/227701389-bfc4ded9-a689-4d32-b1b0-4a51a2f1d3f0.png">

- **결합 기법**
    - `inode` 에 색인 블록의 15개 포인터를 유지한다.
    - 이 포인터들의 처음 12개는 직접 블록을 가리키는데, 이 포인터들은 파일의 데이터를 저장하고 있는 블록들의 주소를 저장한다.
    - 따라서, 크기가 작은 파일의 경우 추가의 색인 블록이 필요 없다.

    - 다음의 3개의 포인터는 간접 블록을 가리키는 포인터이다.
    - 첫 번째 포인터는 **단일 간접 블록**, 두 번째 포인터는 **이중 간접 블록**, 세 번째 포인터는 **삼중 간접 블록**을 가리킨다.

</br>

→ 색인 할당 기법은 연결 할당과 동일한 성능 문제를 갖는다.

- 특히 색인 블록은 메모리에 캐시될 수 있지만, 데이터 블록은 전체 볼륨 파티션 전체에 널리 퍼져 있을 수 있다.

</br>

### 성능

→ ***연결 할당의 경우, 다음 블록의 주소를 메모리에 유지하고 직접 읽을 수 있다.***

- 이 방법은 순차적 액세스에 적합하다.
    - 직접 액세스의 경우 `i` 번째 블록에 액세스 하려면 `i` 번의 블록 읽기가 필요할 수 있다.

</br>

> **몇몇 시스템들은 연속 할당을 사용하여 직접 접근 파일을, 연결 할당을 사용하여 순차 접근 파일을 모두 지원한다.**
> 
- 이들 시스템에서는 파일이 생성될 때 접근 형태가 먼저 선언되어야 한다.
    - 순차 접근을 위해서 생성된 파일은 연결 할당되며, 직접 접근을 위해서는 사용될 수 없다.

</br>

> **색인 할당의 경우는 더 복잡하다.**
> 
- 색인 블록이 메모리 내에 상주한다면 직접 접근이 가능하다.
    - 그러나, 메모리 내에 색인 블록을 전부 상주시키는 것은 많은 양의 메모리를 필요로 한다.
    - 만약 이 메모리 공간을 사용할 수 없다면 먼저 색인 블록을 읽은 후 원하는 자료 블록을 읽어야 한다.

</br>

> **일부 시스템은 연속 할당과 색인 할당을 결합하여 작은 파일은 연속 할당하고, 파일이 더 커지면 자동으로 색인 할당으로 전환한다.**
> 
- 대부분의 파일이 작고 연속 할당이 작은 파일의 경우 효율적이기 때문에 평균 성능이 상당히 좋아진다.

---

## 5. 가용 공간의 관리

→ ***저장장치 공간은 제한되어 있기 때문에 삭제된 파일들이 차지하던 공간을 새로운 파일들을 위해 다시 재사용해야 한다.***

- 시스템은 이러한 가용 공간을 리스트로 유지하고 관리한다.
    - 새로운 파일을 만들려면 이 **가용 공간 리스트**를 탐색하여 새로운 파일을 위한 공간을 할당받아야 한다.

</br>

### 비트 벡터

→ ***가용 공간 리스트는 흔히 비트맵 또는, 비트 벡터로서 구현된다.***

- 여기서 각 블록은 1비트로 표현된다.
    - 만약에 블록이 비어 있으면 그 비트는 1이 되고, 만약 블록이 할당되어 있다면 그 비트는 0이된다.

</br>

> **이 방법의 큰 이점은 첫 번째 가용 블록 또는 `n` 개의 연속된 가용 블록들을 찾는 일이, 상대적으로 간편하고 효율적이라는 점이다.**
> 
- 실제 많은 컴퓨터가 이 일을 효율적으로 수행할 수 있는 비트 조작 명령를 제공한다.
    - 디스크 공간을 할당하기 위해 비트 벡터를 사용하는 시스템에서 첫 번째 가용 블록을 찾는 한 가지 방법은 비트맵의 각 워드를 순차적으로 검사하여, 워드의 값이 0인지 아닌지를 확인하는 것이다.

</br>

→ **블록 번호 계산법** : `(워드의 비트 수) x (값이 0인 워드의 수) + 첫 번째 1비트의 변위`

</br>

> **비트 벡터는 그 전체가 메인 메모리 내에 존재하지 않으면 비효율적이다.**
> 
- 복구할 때를 위하여 때때로 파일 시스템을 저장하고 있는 장치에 기록되기는 하더라도, 메모리에 존재해야 한다.
    - 작은 디스크의 경우 비트 벡터를 메인 메모리에 유지하는 것이 가능하지만, 용량이 큰 디스크의 경우에도 그렇다고 할 수는 없다.

</br>

### 연결 리스트

→ ***두 번째 방법은 모든 가용 블록들을 함께 연결하는 것인데, 첫 번째 가용 블록은 다음 가용 블록을 가리키는 포인터를 가진다.***

<img width="246" alt="image" src="https://user-images.githubusercontent.com/106216912/227702976-37120a96-1db4-4de9-a8a1-2692a348fb3e.png">

- 두 번째 가용 블록은 다음 가용 블록의 포인터를 갖고 있고, 계속 그런 방법으로 구현된다.
    - 시스템은 첫 번째 가용 블록에 대한 포인터를 파일 시스템의 특정 위치에 두고 또한 메모리에 캐싱하면 된다.

</br>

- HDD에서 이 기법은 리스트를 순회하려면 매번 디스크에 접근해야 하므로 효율적이지 못하다.
    - 그러나, 가용 리스트 순회는 그다지 빈번하게 일어나는 일은 아니다.
    - 통상 운영체제는 단순히 파일에 할당할 하나의 가용 블록이 필요하므로, 가용 리스트의 첫 블록을 사용하게 된다.

</br>

### 그룹핑

→ ***가용 리스트 방식의 변형으로 첫 번째 가용 블록 내의 `n` 개의 블록 주소를 저장하는 방법이 있다.***

- 이 중 처음 `n-1` 개는 실제로 비어있는 블록의 주소이다.
    - 그러나 마지막 1개는 자신과 마찬가지로 `n-1` 개의 빈 블록 주소를 가지고 있는 가용 블록을 가리킨다.

</br>

→ 이 방법은 다수 개의 가용 블록 주소들을 쉽게 찾을 수 있다는 점이 장점이다.

</br>

### 계수

→ ***또 다른 방법은 일반적으로 디스크 공간의 할당과 반환이 여러 연속된 블록 단위로 이루어진다는 이점을 이용하는 것으로, 특히 연속 할당 알고리즘이나 클러스터링을 통해 공간을 할당할 경우 유용하다.***

- 그러한 경우, 모든 블록을 일일이 추적할 필요가 없이 연속된 가용 블록의 첫 번째 블록의 주소와 연속된 블록의 개수만 유지하면 보다 효율적이다.
    - 따라서, 가용 공간 리스트의 각 항은 하나의 장치 주소와 블록의 개수로 구성된다.

</br>

### 공간맵

→ ***Oracle의 ZFS 파일 시스템은 대규모의 파일, 디렉터리, 심지어 파일 시스템을 저장할 수 있도록 설계되었다.***

- 이러한 규모에서는 메타데이터 입출력이 성능에 지대한 영향을 미치게 된다.

</br>

> **ZFS는 가용 공간을 관리할 때 자료구조의 크기를 제어하고 이 자료구조를 관리하기 위해 필요한 입출력을 최소화하기 위해 여러 기법을 조합하여 사용한다.**
> 
- 우선, ZFS는 장치의 공간을 관리 가능한 크기의 덩어리로 나누기 위해서 **메타슬랩(metaslabs)** 을 생성한다.
    - 각 메타슬랩은 연관된 공간맵을 가지고 있다.

</br>

- ZFS는 가용 블록에 관한 정보를 저장하기 위하여 계수 알고리즘을 사용한다.
    - 디스크에 계수 구조를 기록하는 것이 아니라, 로그-구조 파일 시스템 기법을 사용하여 이 정보를 저장한다.

</br>

- ZFS가 메타슬랩으로부터 공간을 할당하거나 반환하려고 할 때, 관련된 공간맵을 변위에 따라 색인된 균형-트리 형태로 메모리에 적재하고, 로그를 재실행하여 이 구조에 반영한다.
    - 그러면 메모리 내 공간맵은 메타슬랩의 할당과 반환 상태를 정확히 표현하게 된다.

</br>

- 또한, ZFS는 연속된 가용 블록을 결합하여 하나의 항으로 만들어 맵을 가능한 한 압축한다.
    - 마지막으로 ZFS의 트랜잭션 기반 연산의 일부분으로 디스크에 존재하는 가용 공간 리스트가 갱신된다.

</br>

### 사용하지 않는 블록 트림

→ ***업데이트를 위해 블록을 덮어쓸 수 있는 HDD 및 기타 저장 매체는 가용 공간 관리를 위한 가용 리스트만 필요하다.***

- 블록을 해제할 때 특별한 조치가 필요하지 않다.
    - 해제된 블록은 일반적으로 블록이 다음이 할당되어 데이터를 덮어쓸 때까지 데이터를 유지한다.

</br>

> **파일 시스템이 페이지가 비어 있고 페이지를 포함하는 블록이 완전히 비어있는 경우, 삭제될 수 있다는 것을 장치에 알릴 수 있는 새로운 기법이 필요하다.**
> 
- 해당 기법은 저장장치 컨트롤러에 따라 다르다.
    - ATA-연결 드라이브 : TRIM
    - NVMe 기반 저장장치 : `unallocate` 명령이다.

---

## 6. 효율과 성능

→ ***다양한 블록 할당과 디렉터리 관리 기법들이 저장장치의 성능과 효율적인 사용에 어떤 영향을 미치는지 살펴본다.***

- 디스크는 컴퓨터 시스템에서 가장 속도가 느린 것이므로, 시스템의 성능 면에서 병목의 주요 원인이 된다.

</br>

### 효율

→ ***저장장치 공간의 효율적인 사용은 할당 및 디렉터리 알고리즘과 밀접한 관계가 있다.***

- ex) 한 파티션에서 UNIX `inode` 들은 미리 할당된다.
    - 빈 디스크라 해도 그 공간의 일부가 `inode` 에 할당되어 있다.
    - 그렇지만 `inode` 를 미리 할당하고 또한 이들을 파티션 전체에 분산 할당함으로써, 파일 시스템의 성능을 향상할 수 있다.

</br>

> **또한 고려해야 할 사항으로, 파일의 디렉터리 항목 내에 저장되어야 할 정보의 종류가 있다.**
> 
- ex) 많은 시스템은 파일의 마지막 쓰기 시각을 기록하여 사용자에게 그 정보를 제공하고 또한 그 파일을 백업할지를 결정하는 데 사용한다.
    - 어떤 시스템은 마지막 접근 시간을 저장하여 사용자가 마지막으로 파일이 읽혔던 시간을 알 수 있게 한다.
    - 파일을 읽을 때마다 디렉터리 기록 작업을 해야 한다면 꽤 번거롭고 오버헤드도 상당히 크므로, 시스템 설계자는 잘 결정하여야 한다.

</br>

### 성능

→ ***기본적인 파일 시스템 알고리즘이 결정되었다 하더라도, 시스템 성능을 향상할 수 있는 방법들이 몇 가지 더 있다.***

- 저장장치 컨트롤러들은 전체 트랙 또는 블록의 내용을 전부 저장할 수 있을 만큼 충분한 크기의 캐시를 가지고 있다.
    - HDD에서는 일단 탐색이 디스크 헤드를 원하는 트랙으로 가져가면 디스크 헤드가 위치하는 섹터부터 곧바로 디스크 캐시로 읽어 후에 요구되는 디스크 섹터를 운영체제에 전달한다.

</br>

- 어떤 시스템은 메인 메모리에서 별도의 구역을 **버퍼 캐시용**으로 유지한다.
    - 다른 시스템은 파일 데이터를 **페이지 캐시**를 사용하여 캐시 한다.
    - 페이지 캐시는 가상 메모리 기법을 사용하여 파일 데이터를 파일 시스템 지향의 블록이 아니라 페이지로 캐시한다.
    - 파일 데이터를 가상 주소로 캐시 하는 것은 물리 블록으로 캐시 하는 것보다 훨씬 효율적이다.

</br>

> **UNIX의 몇 버전들은 통합 버퍼 캐시를 제공한다.**
> 

→ ***파일을 오픈하고 접근하는 두 가지 대안을 생각해본다.***

<img width="292" alt="image" src="https://user-images.githubusercontent.com/106216912/227704435-e3c61e81-7065-4fb5-aec2-2084109bc123.png">

- 메모리 매핑을 사용하는 것
- 표준 시스템 콜인 `read()` , `write()` 를 사용하는 것

</br>

> **이중 캐싱**
> 

<img width="295" alt="image" src="https://user-images.githubusercontent.com/106216912/227704459-a147a683-ff46-470a-8926-717c3c2db7e9.png">

- 메모리 매핑 호출은 페이지 캐시와 버퍼 캐시의 두 가지 캐시를 사용할 것을 요구한다.
    - 메모리 매핑은 파일 시스템으로부터 디스크를 읽고, 버퍼 캐시에 저장함으로써 진행된다.
    - 가상 메모리 시스템은 버퍼 캐시와 인터페이스 할 수 없기 때문에 버퍼 캐시에 있는 파일이 페이지 캐시에 복사되어야만 한다.

</br>

→ **이중 캐싱**으로, 파일 시스템 데이터를 두 번 캐싱해야 한다!

- 메모리 낭비일 뿐 아니라, 시스템 메모리 내에서 필요 없는 데이터 이동으로 인해 CPU와 I/O 사이클을 낭비하게 된다.
    - 통합 버퍼 캐시를 제공함으로써 메모리 매핑과 시스템 콜은 페이지 캐시를 사용하게 된다.

</br>

> **입출력의 성능에 영향을 미칠 수 있는 또 다른 문제는, 파일 시스템에 쓰기 연산이 동기적으로 혹은 비동기적으로 수행되느냐 하는 것이다.**
> 
- **동기식 쓰기**는 저장장치 서브시스템에 요청을 받은 순서대로 이루어지며, 쓰기가 버퍼에 저장되지 않는다.
    - 따라서 호출 루틴은 데이터가 디스크 드라이브에 도착한 후에야 수행을 계속할 수 있다.

</br>

- 대부분은 **비동기식 쓰기**가 행해진다.
    - 비동기식의 경우, 데이터를 캐시에 저장하고 호출자에게 제어를 돌려준다.
    - 대부분의 쓰기는 비동기적으로 이루어지나, 메타데이터 쓰기 작업은 통상 동기식으로 수행된다.

</br>

> **다른 시스템에서는 파일의 접근 유형에 따라 다른 교체 알고리즘을 사용함으로써 페이지 캐시를 최적화한다.**
> 
- 순차적으로 읽히고 쓰이는 파일은 LRU 순서에 따라 교체되어서는 안 된다.
    - 대부분 최근에 사용된 페이지는 마지막으로 사용되거나 혹은 사용되지 않을 것이기 때문이다.

</br>

→ 대신에 순차 접근은 `free-behind` , `read-ahead` 로 알려진 기술로 최적화된다!

- `Free-behind` : 다음 페이지가 요청되자마자 버퍼에서 페이지를 제거하는 것
- `Read-ahead` : 요구된 페이지와 몇 개의 뒤이은 페이지를 읽어 캐싱하는 것

</br>

> **페이지 캐시, 파일 시스템 그리고 장치 드라이버는 몇 가지 흥미 있는 상호 작용을 한다.**
> 
- 적은 양의 데이터가 파일에 쓰일 때, 페이지는 캐시에 버퍼 되고, 디스크 드라이버는 자신의 출력 큐를 장치 주소에 따라 소트한다.
    - 이러한 두 가지 행동은 디스크 드라이버가 디스크 헤드 탐색을 최소화할 수 있게 한다.
    - 동기식 쓰기가 필요하지 않다면, 디스크에 쓰기를 하는 프로세스는 단순히 캐시에 쓰고, 시스템은 편리할 때 비동기식으로 디스크에 데이터를 쓸 수 있다.

---

## 7. 복구

→ ***파일들과 디렉터리는 때에 따라서는 메인 메모리와 저장장치 볼륨 두 곳에 존재하게 되기 때문에, 시스템에 문제가 생길 경우 두 곳의 내용이 일관성을 가져야하고, 자료를 잃어버리지 않도록 보장해야 한다.***

- 디스크 상의 디렉터리 구조, 가용 블록 포인터, 가용 FCB 포인터와 같은 파일 시스템 자료구조는 시스템 고장 발생 시 일관성이 없어질 수 있다.
    - 많은 파일 시스템은 이러한 자료구조들에 대한 변경을 이들 구조에 직접 적용하였다.
    - 파일 생성 같은 대표적인 연산은 디스크상의 파일 시스템 내부의 많은 자료구조들에 대한 변경을 포함한다.
    - 디렉터리 구조가 변경되고, FCB와 데이터 블록이 할당되며, 이 모든 블록의 가용 블록 수가 감소한다.

</br>

→ 이러한 변경은 크래시에 의해 방해받을 수 있고, 이들 구조가 일관성이 없어지는 결과를 초래한다.

</br>

> **크래시뿐만 아니라 파일 시스템 구현의 버그, 디스크 컨트롤러 및 사용자 응용 도한 파일 시스템의 오염을 초래한다.**
> 
- 파일 시스템은 오염을 처리하기 위해서 파일 시스템 자료구조와 알고리즘에 따라 다양한 방법들을 가지고 있다.

</br>

### 일관성 검사

→ ***오염의 원인이 무엇이든지 간에 파일 시스템은 문제를 검출하고 교정할 수 있어야 한다.***

- 검출을 위해서 각 파일 시스템의 모든 메타데이터에 대한 검사를 통하여 파일 시스템의 일관성을 확인하거나 부정할 수 있다.
    - 불행하게도 이 검사는 몇 분에서 몇 시간이 소요되며, 시스템이 부트될 때마다 실행되어야 한다.
    - 대체 방안으로 파일 시스템은 파일 시스템 메타데이터 안에 자신의 상태를 기록할 수 있다.

</br>

> **UNIX 시스템의 `fsck` 와 같은 일관성 검사기는 디렉터리 구조에 있는 데이터와 다른 메타데이터를 저장장치에 있는 상태와 비교하고 불일치가 발견되면 그것을 복구하도록 시도한다.**
> 
- 이 때, 할당 및 가용 공간 관리 알고리즘이 이 검사기가 발견할 수 있는 문제의 유형과 이들을 얼마나 성공적으로 회복할 수 있는지를 결정한다.

</br>

### 로그 구조 파일 시스템

→ ***컴퓨터 과학 분야에서는 알고리즘과 기술이 종종 원래 용도로부터 다른 분야로 전이된다.***

- 데이터베이스 로그 기반 복구 알고리즘이 한 예이다.
    - 이들 로깅 알고리즘은 일관성 검사의 문제에 성공적으로 적용되었고, 그 구현은 **로그 기반 트랜잭션 지향** 파일 시스템으로 알려져 있다.

</br>

> **일관성 검사 기법의 문제점**
> 

→ ***비일관성이 회복할 수 없을 수도 있다.***

- 이 문제의 해결 방안은, 파일 시스템 메타데이터 갱신에 로그 기반 복구 기술을 적용하는 것이다!

</br>

> **기본적으로 모든 메타데이터 변경은 로그에 순차적으로 기록된다.**
> 
- 특정 태스크를 수행하는 연산의 집합 각각을 하나의 **트랜잭션**이라고 한다.
    - 일단 이 변경이 로그에 기록되면, 그들은 commit된 것으로 간주하고 시스템 콜은 유저 프로세스로 복귀하여 실행을 계속하도록 허용한다.
    - 변경이 반영되는 동안, 어느 동작이 끝났고 덜 끝났는지를 나타내기 위한 포인터가 갱신된다.
    - committed된 전체 트랜잭션이 완료되면, 그 사실을 나타내는 항목이 로그에 만들어진다.

</br>

- 이 로그 파일은 **원형 버퍼**로, 버퍼 공간의 맨 뒤에 기록하고 맨 앞에서 시작하는 연속적인 공간으로 구성된다.
    - 원형 버퍼를 사용할 경우에는, 아직 저장되지 않은 유효한 데이터 위에 새로운 데이터가 겹쳐 기록되지 않게 관리된다.

</br>

> **시스템이 크래시 하면, 로그 파일에 0개 이상의 트랜잭션이 있을 것이다.**
> 
- 이러한 트랜잭션들은 운영체제에 의해 확약되었다 할지라도 파일 시스템에서 결코 수행이 완료되지 않은 것이기 때문에, 반드시 수행을 완료해야 한다.
    - 이 트랜잭션들은 작업이 완료될 때까지 실행될 수 있고, 파일 시스템 구조는 일관성을 유지하게 된다.

</br>

> **디스크 메타데이터 갱신에 대한 로그를 사용하는 부수적인 이득은 이들을 직접 디스크 데이터 구조에 적용하는 것보다 갱신이 더 빠르다는 것이다.**
> 
- 이러한 성능 향상의 이유는 임의 입출력에 비해 순차 입출력이 빠르다는 데서 찾을 수 있다.
    - 비용이 많이 드는 동기식 임의 메타데이터 쓰기가 비용이 훨씬 적게 드는 로그 구조 파일 시스템의 로깅 지역에 대한 동기적 순차 쓰기로 변환된다.

</br>

### 다른 해결 방안들

→ ****일관성 검사 이외의 또 다른 해결 방안이 Network Appliance의 WAFL 파일 시스템과 Solaris ZFS 파일 시스템에 채택되었다.***

- 이 시스템들은 옛 데이터를 새 데이터로 절대로 덮어쓰지 않는다.
    - 오히려 트랜잭션은 모든 데이터와 메타데이터 변경을 새로운 블록에 기록한다.
    - 트랜잭션이 완료되면 이 블록들의 구버전을 가리키고 있는 메타데이터 구조가 새로운 블록들을 가리키도록 갱신된다.

</br>

> **ZFS는 디스크 일관성에 대해 더 혁신적인 접근 방법을 채택한다.**
> 
- 메타데이터와 데이터 블록의 검사-총합을 제공한다.
    - 이 해결책은 RAID와 결합될 때 데이터가 항상 올바르다는 것을 보장한다.
    - 따라서, ZFS는 일관성 검사기가 없다.

</br>

### 백업과 복구

→ ***저장장치 고장은 데이터를 잃어버리게 할 수 있으므로, 자료가 영원히 손실되지 않도록 보장해 줄 필요가 있다.***

- 이 때문에, 시스템 프로그램들은 하나의 보조저장장치의 내용을 보통 자기 테이프, 또는 다른 보조저장장치와 같은 다른 저장장치에 주기적으로 백업해야 한다.

</br>

> **전형적인 백업 과정**
> 
- 첫 번째 날 : 디스크로부터 모든 파일을 백업한다(full backup).
- 두 번째 날 : 1일 이후로 변경된 모든 파일을 백업한다(incremental backup).
- 세 번째 날 : 2일 이후로 변경된 모든 파일을 백업한다.
- N번째 날 : N-1일 이후로 변경된 모든 파일을 백업하고 1일로 되돌아간다.

</br>

→ 이 방법을 사용하면 전체 백업부터 시작하여 모든 점증적 백업을 적용함으로써 전체 파일 시스템을 복원할 수 있다.

</br>

> **사이클의 길이는 필요한 백업의 양과 복원 시 되돌아갈 수 있는 날짜 수에 좌우된다.**
> 
- 복원을 위하여 읽어야 하는 디스크 수를 줄이기 위하여, 전체 백업을 적절히 중간 지점에 수행할 수 있다.

</br>

- 한 사용자가 파일에 문제가 발생한지 오래 후에 그 파일에 문제가 발생하였음을 인식할 수 있다.
    - 그 때문에 우리는 때때로 전체 백업을 하여 그 매체를 재사용하지 않고 영원히 저장해 둘 필요가 있다.