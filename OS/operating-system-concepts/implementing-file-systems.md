## 1. 파일 시스템 구조

→ ***파일 시스템을 유지하기 위한 보조저장장치로 디스크가 대부분 사용된다.***

</br>

> **디스크가 보조저장장치로 사용되는 2가지 이유**
> 
1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
    - 디스크로부터 한 블록을 읽고, 변경하여 같은 블록에 재기록이 가능하다.

</br>

2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.
    - 따라서, 임의의 파일을 순차적 또는 무작위 방법으로 쉽게 접근할 수 있다.

</br>

> **I/O 효율성을 향상하기 위해 메모리와 대용량 스토리지 간의 I/O 전송이 블록 단위로 수행된다.**
> 
- 하드 디스크 드라이브의 각 블록에는 하나 이상의 섹터가 있다.

</br>

> **파일 시스템은 쉽게 데이터를 저장하고, 찾고 또한 인출할 수 있게 함으로써 저장장치를 더욱 효율적이고 편리하게 사용할 수 있게 한다.**
> 
- 파일 시스템은 크게 두 가지의 설계 문제를 제기한다.
    - 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의하는 것
    - 논리 파일 시스템을 물리적인 2차 저장장치로 사상하는 알고리즘과 데이터 구조를 만드는 것

</br>

> **파일 시스템은 여러 층으로 이루어져 있다.**
> 
<img width="147" alt="image" src="https://user-images.githubusercontent.com/106216912/227697066-32c4ccd6-656c-49c5-bb3a-84fcb24da5dd.png">

- **입/출력 제어 층**
    - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져 있어서 메모리와 디스크 시스템 간의 정보 전송을 담당한다.

</br>

- **기본 파일 시스템 층**
    - 적절한 장치 드라이버에게 저장장치상의 블록을 읽고 쓰도록 일반적인 명령을 내린다.
    - 논리 블록 주소를 기반으로 드라이브에 명령일 내리고, I/O 요청 스케줄링도 고려한다.
    - 또한, 다양한 파일 시스템과 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.

</br>

- **파일-구성 모듈**
    - 파일과 상응하는 논리 블록을 알고 있다.
    - 어느 디스크 공간이 비어 있는지를 파악하는 가용 공간 관리자를 포함한다.

</br>

- **논리 파일 시스템 층**
    - 메타데이터 정보를 관리한다.
    - 파일 구조는 파일 제어 블록을 통해 유지된다.
    - **파일 제어 블록(FCB)** 는 소유, 허가 그리고 파일 내용의 위치를 포함하여 파일에 관한 정보를 가지고 있다.

</br>

> **파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드의 중복이 최소화되었다.**
> 
- 다수의 파일 시스템에 의해 I/O 제어와 때로는 기본 파일 시스템 코드가 사용될 수 있다.
    - 그 경우, 각 파일 시스템은 자신의 논리 파일 시스템과 파일 구조 모듈을 가지고 있다.
    - 하지만 계층화는 **더 많은 운영체제 오버헤드를 야기하여 성능을 저하**한다.

---

## 2. 파일 시스템 구현

→ ***이 절에서는 파일 시스템 연산을 구현하는 데 사용되는 구조와 연산에 대해 깊이 살펴본다.***

</br>

### 개요

→ ***여러 저장장치상의 구조와 메모리 내 구조가 파일 시스템을 구현하는 데 사용된다.***

</br>

> **파일 시스템은 저장장치에 저장된 운영체제를 어떻게 부트시키는지, 블록의 총수, 가용 블록의 수와 위치, 디렉터리 구조, 개별 파일에 대한 정보를 디스크 상에 가지고 있다.**
> 
- **부트 제어 블록**
    - 시스템이 그 파티션으로부터 운영체제를 부트시키는 데 필요한 정보를 가지고 있다.
    - 부트 제어 블록은 일반적으로 한 파티션의 첫 번째 블록이다.
    - UFS에서는 **부트 블록**, NTFS에서는 **파티션 부트 섹터**라고 불린다.

</br>

- **볼륨 제어 블록**
    - 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 가용 FCB 수와 포인터 같은 볼륨 정보를 포함한다.
    - UFS에서는 **슈퍼 블록**, NTFS에서는 **마스터 파일 테이블**이라 불린다.

</br>

- **디렉터리 구조**
    - 파일을 조직화하는 데 사용된다.
    - UFS에서는 디렉터리 구조에 파일 이름 및 해당 `inode` 번호가 저장된다.
    - NTFS에서는 마스터 파일 테이블에 이러한 정보가 저장된다.

</br>

- **파일별 FCB**
    - 자세한 파일 정보를 가지고 있다.
    - FCB는 디렉터리 항목과의 연결을 위하여 고유한 식별 번호를 가지고 있다.

</br>

> **메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.**
> 
- **메모리 내 파티션 테이블**
    - 마운트된 모든 파티션 정보를 포함한다.

</br>

- **메모리 내 디렉터리 구조**
    - 최근 접근된 디렉터리의 디렉터리 정보를 가진다.

</br>

- **범 시스템 오픈 파일 테이블**
    - 다른 정보와 더불어 오픈된 각 파일의 FCB의 복사본을 가지고 있다.

</br>

- **프로세스별 오픈 파일 테이블**
    - 프로세스가 연 모든 파일에 대해 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다.

</br>

- **버퍼**
    - 파일 시스템이 파일 시스템으로부터 읽히거나 써질 때, 파일 시스템 블록을 저장한다.

</br>

> **새로운 파일을 생성하기 위해 프로세스는 논리 파일 시스템을 호출한다.**
> 
<img width="333" alt="image" src="https://user-images.githubusercontent.com/106216912/227697888-0b501083-d828-4d04-bef9-28d2a36b4a0d.png">

- 논리 파일 시스템은 디렉터리 구조의 포맷을 알고 있다.
    - 새로운 파일을 생성하기 위해 파일 시스템은 새로운 FCB를 할당하고, 해당 디렉터리를 메모리로 읽어 새로운 파일과 FCB로 디렉터리를 갱신한다.
    - 그 후, 파일 시스템에 다시 쓴다.

</br>

### 사용법

→ ***일단 새로운 파일이 생성되면 입출력을 위해 사용될 수 있다.***

<img width="476" alt="image" src="https://user-images.githubusercontent.com/106216912/227697901-3c3e6ee8-5c3c-4525-9401-9440520de387.png">

- 우선 파일이 반드시 오픈되어야 하며, `open()` 시스템 콜은 논리적 파일 시스템에 파일 이름을 넘겨준다.
    - `open()` 시스템 콜은 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위해 범 시스템 오픈 파일 테이블을 검색한다.
    - 사용 중이면, 기존 범 시스템 오픈 파일 테이블을 가리키는 프로세스별 오픈 파일 테이블 항목이 생성된다.
        - 이 알고리즘은 상당한 오버헤드를 줄일 수 있다.

</br>

- 만일 파일이 오픈되지 않았다면, 주어진 파일 이름을 디렉터리 구조에서 찾는다.
    - 디렉터리 연산의 속도를 향상하기 위해 통상 디렉터리 구조의 일부를 메모리에 캐싱한다.
    - 파일이 발견되면 FCB가 메모리내의 범 시스템 오픈 파일 테이블에 복사된다.

</br>

> **다음으로, 범 시스템 오픈 파일 테이블의 항목에 대한 포인터와 몇 개의 다른 필드를 갖는 새로운 항목이 프로세스별 오픈 파일 테이블 안에 만들어진다.**
> 
- 이 필드들은 파일 안의 현재 위치를 가리키는 포인터와 파일이 오픈된 접근 모드 등을 포함한다.
    - `open()` 시스템 콜은 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 찾아 돌려준다.
    - 그 후, 모든 파일 연산은 이 포인터를 통해 실행된다.

</br>

- **파일 디스크립터(파일 핸들)**
    - 일단 해당 FCB를 디스크에서 찾으면 시스템은 파일 이름을 더는 사용하지 않기 때문에, 파일 이름은 오픈 파일 테이블의 한 부분이 아니다.
    - 그러나, 이것은 같은 파일에 대한 다중 오픈 연산을 빠르게 하기 위해 캐쉬될 수 있다.

</br>

→ **이러한 기법을 사용함으로써, 실제 데이터 블록을 제외한 오픈 파일에 대한 모든 정보는 메모리 내에 존재한다!**

---

## 3. 디렉터리 구현

→ ***디렉터리 공간을 어떻게 할당하고 어떻게 관리하는가는 파일 시스템의 효율, 성능과 신뢰성에 큰 영향을 미친다.***

- 따라서, 이들 알고리즘과 연관되어 있는 문제점들을 이해할 필요가 있다!

</br>

### 선형 리스트

→ ***디렉터리를 구현하는 가장 간단한 방법은, 파일 이름과 데이터 블록에 대한 포인터들의 선형 리스트를 디렉터리에 사용하는 것이다.***

- 이 방법은 프로그램이 쉽지만, 실행 시간이 길다.
    - 새로운 파일을 생성하기 위해서는 먼저 디렉터리를 탐색하여 같은 이름을 가진 파일이 존재하지 않는다는 것을 확인한 후, 디렉터리의 끝부분에 새로운 항목을 첨가하면 된다.
    - 한 파일을 삭제하려면 디렉터리에서 이름을 찾아 그 파일에 할당된 공간을 방출한다.

</br>

- 디렉터리 항목을 재사용하기 위해 여러 가지 중 하나를 수행할 수 있다.
    - 항목을 미사용으로 표시하거나, 가용 디렉터리 항목 리스트에 추가할 수 있다.
    - 사용 가능하게 된 항목에 제일 마지막 항목을 복사해 넣고 디렉터리의 길이를 하나 줄일 수 있다.

</br>

> **선형 리스트로 구성된 디렉터리의 가장 큰 단점**
> 

→ ***선형 탐색을 해야 한다는 점이다.***

- 디렉터리는 빈번하게 사용되고, 속도가 느리면 사용자는 이를 바로 느낄 것이다.
    - 실제 많은 운영체제는 가장 최근에 사용된 디렉터리 정보를 저장하기 위해 소프트웨어 캐시를 구현하고 있다.
    - 캐시 적중은 그 정보를 매번 보조저장장치로부터 읽어오는 것을 피할 수 있게 한다.

</br>

- 정렬된 리스트는 이진 탐색을 가능케 하며, 평균 탐색 시간을 줄인다.
    - 그렇지만, 리스트가 정렬 상태를 유지하려면 파일을 생성하거나 삭제하는 일이 복잡해질 수 있다.
    - 정렬을 유지하기 위해 상당한 정보를 이동해야 할 수도 있기 때문이다.

</br>

### 해시 테이블

→ ***또 다른 디렉터리의 구조로 해시 테이블(hash table)을 사용한다.***

- 파일 이름을 제시하면 해시로부터 값을 얻어서 그것을 포인터로 활용하여 이 리스트를 직접 접근할 수 있다.
    - 해시의 특성상 성능은 크게 개선된다.
    - 그러므로, 디렉터리 탐색 시간을 상당히 개선할 수 있다.

</br>

> **해시 테이블의 심각한 문제점**
> 
→ ***해시 테이블이 고정된 크기를 갖는다는 점과, 해시 테이블의 크기에 따라 해시 기능도 제한을 받는다는 점이다.***

- 대안으로, **체인 오버플로우 해시 테이블**을 사용할 수 있다.
    - 각 해시 항목은 하나의 값이 아니라 연결 리스트가 되고, 새로운 항목을 연결 리스트에 추가함으로써 충돌을 해결한다.

---