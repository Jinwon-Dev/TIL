## 1. 파일 시스템 구조

→ ***파일 시스템을 유지하기 위한 보조저장장치로 디스크가 대부분 사용된다.***

</br>

> **디스크가 보조저장장치로 사용되는 2가지 이유**
> 
1. 디스크는 추가 장소를 사용하지 않고 재기록이 가능하다.
    - 디스크로부터 한 블록을 읽고, 변경하여 같은 블록에 재기록이 가능하다.

</br>

2. 디스크에 있는 임의의 블록의 정보를 직접 접근할 수 있다.
    - 따라서, 임의의 파일을 순차적 또는 무작위 방법으로 쉽게 접근할 수 있다.

</br>

> **I/O 효율성을 향상하기 위해 메모리와 대용량 스토리지 간의 I/O 전송이 블록 단위로 수행된다.**
> 
- 하드 디스크 드라이브의 각 블록에는 하나 이상의 섹터가 있다.

</br>

> **파일 시스템은 쉽게 데이터를 저장하고, 찾고 또한 인출할 수 있게 함으로써 저장장치를 더욱 효율적이고 편리하게 사용할 수 있게 한다.**
> 
- 파일 시스템은 크게 두 가지의 설계 문제를 제기한다.
    - 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의하는 것
    - 논리 파일 시스템을 물리적인 2차 저장장치로 사상하는 알고리즘과 데이터 구조를 만드는 것

</br>

> **파일 시스템은 여러 층으로 이루어져 있다.**
> 
<img width="147" alt="image" src="https://user-images.githubusercontent.com/106216912/227697066-32c4ccd6-656c-49c5-bb3a-84fcb24da5dd.png">

- **입/출력 제어 층**
    - 장치 드라이버 루틴들과 인터럽트 핸들러로 이루어져 있어서 메모리와 디스크 시스템 간의 정보 전송을 담당한다.

</br>

- **기본 파일 시스템 층**
    - 적절한 장치 드라이버에게 저장장치상의 블록을 읽고 쓰도록 일반적인 명령을 내린다.
    - 논리 블록 주소를 기반으로 드라이브에 명령일 내리고, I/O 요청 스케줄링도 고려한다.
    - 또한, 다양한 파일 시스템과 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리한다.

</br>

- **파일-구성 모듈**
    - 파일과 상응하는 논리 블록을 알고 있다.
    - 어느 디스크 공간이 비어 있는지를 파악하는 가용 공간 관리자를 포함한다.

</br>

- **논리 파일 시스템 층**
    - 메타데이터 정보를 관리한다.
    - 파일 구조는 파일 제어 블록을 통해 유지된다.
    - **파일 제어 블록(FCB)** 는 소유, 허가 그리고 파일 내용의 위치를 포함하여 파일에 관한 정보를 가지고 있다.

</br>

> **파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드의 중복이 최소화되었다.**
> 
- 다수의 파일 시스템에 의해 I/O 제어와 때로는 기본 파일 시스템 코드가 사용될 수 있다.
    - 그 경우, 각 파일 시스템은 자신의 논리 파일 시스템과 파일 구조 모듈을 가지고 있다.
    - 하지만 계층화는 **더 많은 운영체제 오버헤드를 야기하여 성능을 저하**한다.

---

## 2. 파일 시스템 구현

→ ***이 절에서는 파일 시스템 연산을 구현하는 데 사용되는 구조와 연산에 대해 깊이 살펴본다.***

</br>

### 개요

→ ***여러 저장장치상의 구조와 메모리 내 구조가 파일 시스템을 구현하는 데 사용된다.***

</br>

> **파일 시스템은 저장장치에 저장된 운영체제를 어떻게 부트시키는지, 블록의 총수, 가용 블록의 수와 위치, 디렉터리 구조, 개별 파일에 대한 정보를 디스크 상에 가지고 있다.**
> 
- **부트 제어 블록**
    - 시스템이 그 파티션으로부터 운영체제를 부트시키는 데 필요한 정보를 가지고 있다.
    - 부트 제어 블록은 일반적으로 한 파티션의 첫 번째 블록이다.
    - UFS에서는 **부트 블록**, NTFS에서는 **파티션 부트 섹터**라고 불린다.

</br>

- **볼륨 제어 블록**
    - 볼륨의 블록의 수, 블록의 크기, 가용 블록의 수와 포인터, 가용 FCB 수와 포인터 같은 볼륨 정보를 포함한다.
    - UFS에서는 **슈퍼 블록**, NTFS에서는 **마스터 파일 테이블**이라 불린다.

</br>

- **디렉터리 구조**
    - 파일을 조직화하는 데 사용된다.
    - UFS에서는 디렉터리 구조에 파일 이름 및 해당 `inode` 번호가 저장된다.
    - NTFS에서는 마스터 파일 테이블에 이러한 정보가 저장된다.

</br>

- **파일별 FCB**
    - 자세한 파일 정보를 가지고 있다.
    - FCB는 디렉터리 항목과의 연결을 위하여 고유한 식별 번호를 가지고 있다.

</br>

> **메모리 내의 정보는 파일 시스템 관리와 캐싱을 통한 성능 향상을 위해 사용된다.**
> 
- **메모리 내 파티션 테이블**
    - 마운트된 모든 파티션 정보를 포함한다.

</br>

- **메모리 내 디렉터리 구조**
    - 최근 접근된 디렉터리의 디렉터리 정보를 가진다.

</br>

- **범 시스템 오픈 파일 테이블**
    - 다른 정보와 더불어 오픈된 각 파일의 FCB의 복사본을 가지고 있다.

</br>

- **프로세스별 오픈 파일 테이블**
    - 프로세스가 연 모든 파일에 대해 다른 정보뿐만 아니라 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함한다.

</br>

- **버퍼**
    - 파일 시스템이 파일 시스템으로부터 읽히거나 써질 때, 파일 시스템 블록을 저장한다.

</br>

> **새로운 파일을 생성하기 위해 프로세스는 논리 파일 시스템을 호출한다.**
> 
<img width="333" alt="image" src="https://user-images.githubusercontent.com/106216912/227697888-0b501083-d828-4d04-bef9-28d2a36b4a0d.png">

- 논리 파일 시스템은 디렉터리 구조의 포맷을 알고 있다.
    - 새로운 파일을 생성하기 위해 파일 시스템은 새로운 FCB를 할당하고, 해당 디렉터리를 메모리로 읽어 새로운 파일과 FCB로 디렉터리를 갱신한다.
    - 그 후, 파일 시스템에 다시 쓴다.

</br>

### 사용법

→ ***일단 새로운 파일이 생성되면 입출력을 위해 사용될 수 있다.***

<img width="476" alt="image" src="https://user-images.githubusercontent.com/106216912/227697901-3c3e6ee8-5c3c-4525-9401-9440520de387.png">

- 우선 파일이 반드시 오픈되어야 하며, `open()` 시스템 콜은 논리적 파일 시스템에 파일 이름을 넘겨준다.
    - `open()` 시스템 콜은 우선 파일이 이미 다른 프로세스에 의해 사용 중인지 확인하기 위해 범 시스템 오픈 파일 테이블을 검색한다.
    - 사용 중이면, 기존 범 시스템 오픈 파일 테이블을 가리키는 프로세스별 오픈 파일 테이블 항목이 생성된다.
        - 이 알고리즘은 상당한 오버헤드를 줄일 수 있다.

</br>

- 만일 파일이 오픈되지 않았다면, 주어진 파일 이름을 디렉터리 구조에서 찾는다.
    - 디렉터리 연산의 속도를 향상하기 위해 통상 디렉터리 구조의 일부를 메모리에 캐싱한다.
    - 파일이 발견되면 FCB가 메모리내의 범 시스템 오픈 파일 테이블에 복사된다.

</br>

> **다음으로, 범 시스템 오픈 파일 테이블의 항목에 대한 포인터와 몇 개의 다른 필드를 갖는 새로운 항목이 프로세스별 오픈 파일 테이블 안에 만들어진다.**
> 
- 이 필드들은 파일 안의 현재 위치를 가리키는 포인터와 파일이 오픈된 접근 모드 등을 포함한다.
    - `open()` 시스템 콜은 프로세스별 파일 시스템 테이블 내의 해당 항목에 대한 포인터를 찾아 돌려준다.
    - 그 후, 모든 파일 연산은 이 포인터를 통해 실행된다.

</br>

- **파일 디스크립터(파일 핸들)**
    - 일단 해당 FCB를 디스크에서 찾으면 시스템은 파일 이름을 더는 사용하지 않기 때문에, 파일 이름은 오픈 파일 테이블의 한 부분이 아니다.
    - 그러나, 이것은 같은 파일에 대한 다중 오픈 연산을 빠르게 하기 위해 캐쉬될 수 있다.

</br>

→ **이러한 기법을 사용함으로써, 실제 데이터 블록을 제외한 오픈 파일에 대한 모든 정보는 메모리 내에 존재한다!**

---

## 3. 디렉터리 구현

→ ***디렉터리 공간을 어떻게 할당하고 어떻게 관리하는가는 파일 시스템의 효율, 성능과 신뢰성에 큰 영향을 미친다.***

- 따라서, 이들 알고리즘과 연관되어 있는 문제점들을 이해할 필요가 있다!

</br>

### 선형 리스트

→ ***디렉터리를 구현하는 가장 간단한 방법은, 파일 이름과 데이터 블록에 대한 포인터들의 선형 리스트를 디렉터리에 사용하는 것이다.***

- 이 방법은 프로그램이 쉽지만, 실행 시간이 길다.
    - 새로운 파일을 생성하기 위해서는 먼저 디렉터리를 탐색하여 같은 이름을 가진 파일이 존재하지 않는다는 것을 확인한 후, 디렉터리의 끝부분에 새로운 항목을 첨가하면 된다.
    - 한 파일을 삭제하려면 디렉터리에서 이름을 찾아 그 파일에 할당된 공간을 방출한다.

</br>

- 디렉터리 항목을 재사용하기 위해 여러 가지 중 하나를 수행할 수 있다.
    - 항목을 미사용으로 표시하거나, 가용 디렉터리 항목 리스트에 추가할 수 있다.
    - 사용 가능하게 된 항목에 제일 마지막 항목을 복사해 넣고 디렉터리의 길이를 하나 줄일 수 있다.

</br>

> **선형 리스트로 구성된 디렉터리의 가장 큰 단점**
> 

→ ***선형 탐색을 해야 한다는 점이다.***

- 디렉터리는 빈번하게 사용되고, 속도가 느리면 사용자는 이를 바로 느낄 것이다.
    - 실제 많은 운영체제는 가장 최근에 사용된 디렉터리 정보를 저장하기 위해 소프트웨어 캐시를 구현하고 있다.
    - 캐시 적중은 그 정보를 매번 보조저장장치로부터 읽어오는 것을 피할 수 있게 한다.

</br>

- 정렬된 리스트는 이진 탐색을 가능케 하며, 평균 탐색 시간을 줄인다.
    - 그렇지만, 리스트가 정렬 상태를 유지하려면 파일을 생성하거나 삭제하는 일이 복잡해질 수 있다.
    - 정렬을 유지하기 위해 상당한 정보를 이동해야 할 수도 있기 때문이다.

</br>

### 해시 테이블

→ ***또 다른 디렉터리의 구조로 해시 테이블(hash table)을 사용한다.***

- 파일 이름을 제시하면 해시로부터 값을 얻어서 그것을 포인터로 활용하여 이 리스트를 직접 접근할 수 있다.
    - 해시의 특성상 성능은 크게 개선된다.
    - 그러므로, 디렉터리 탐색 시간을 상당히 개선할 수 있다.

</br>

> **해시 테이블의 심각한 문제점**
> 
→ ***해시 테이블이 고정된 크기를 갖는다는 점과, 해시 테이블의 크기에 따라 해시 기능도 제한을 받는다는 점이다.***

- 대안으로, **체인 오버플로우 해시 테이블**을 사용할 수 있다.
    - 각 해시 항목은 하나의 값이 아니라 연결 리스트가 되고, 새로운 항목을 연결 리스트에 추가함으로써 충돌을 해결한다.

---

## 4. 할당 방법

→ ***주요 문제는 파일들을 어떻게 저장장치 공간에 배치해야 디스크 공간을 효율적으로 사용할 수 있고, 파일들을 빨리 접근할 수 있는가 하는 것이다.***

- 저장장치 공간을 할당하기 위해서는 세 가지 주된 방법은 **연속, 연결, 인덱스 기법**이 널리 사용되며, 방법마다 장단점이 있다.

</br>

### 연속 할당

→ ***연속 할당은 각 파일이 저장장치 내에서 연속적인 공간을 차지하도록 요구한다.***

- 장치 주소들은 장치상에서 선형 순서를 정의한다.
    - 이러한 순서를 따를 경우, 단지 한 작업이 장치에 접근한다고 가정하고, 블록 `b` 다음에 블록 `b+1` 을 접근한다면 통상 헤드 이동을 요하지 않는다.
    - 헤드의 이동이 필요한 경우, 단지 한 트랙만 이동하면 된다.

</br>

→ 따라서, HDD의 경우 연속 할당된 파일들을 접근하기 위해서 필요한 디스크 탐색의 횟수를 최소화할 수 있다.

- 결국 탐색이 필요할 경우라도 탐색 시간이 최소화된다!

</br>

> **한 파일의 연속 할당은 첫 번째 블록의 주소와 길이로 정의된다.**
> 
<img width="328" alt="image" src="https://user-images.githubusercontent.com/106216912/227701156-f464279d-9e58-4428-9147-1aa781784332.png">

- 파일의 길이가 `n` 블록이고 블록 `b` 에서 시작한다면, 이 파일은 블록 `b` , `b+1` , `b+2` , …, `b+n-1` 을 차지한다.
    - 각 파일을 위한 디렉터리 항목은 이 파일의 디스크 내 시작 블록 주소와 이 파일의 크기만 표시하면 된다.
    - 연속 할당은 구현하기 쉽지만, 한계가 있기 때문에 최신 파일 시스템에서는 사용되지 않는다.

</br>

> **연속 할당 기법에는 몇 가지 문제가 있다.**
> 
- 새로운 파일을 위한 가용 공간을 찾는 일이다.
    - 가용 공간 관리 방법은 어떻게 이러한 문제를 해결할지를 결정한다.

</br>

→ 이 문제는 널리 알려진 문제로써, **동적 공간 할당** 문제의 특정 응용으로 볼 수 있다.

- 최초 적합과 최적 적합이 가용 공간 중에서 할당할 공간을 선택하는 가장 일반적인 전략이다.
    - 최초 적합이나 최적 적합 모두 저장장치 이용 면에서 최적은 아니지만, 일반적으로 최초 적합이 더 빠르다.

</br>

> **이들 알고리즘은 모두 외부 단편화 때문에 어려움이 있다.**
> 
- 파일이 할당되고 반납됨에 따라 가용 디스크 공간이 조그만 조각으로 나누어진다.
    - **외부 단편화**는 가용 공간이 덩어리들로 나누어질 때마다 발생한다.
    - 그러다가, 제일 큰 연속된 덩어리가 요구된 크기보다 작을 때 문제가 된다.

</br>

> **외부 단편화로 인한 공간의 상당한 향의 공간 손실을 방지하는 하나의 정책**
> 
→ ***전체 파일 시스템을 다른 장치로 복사하는 것***

- 원래의 장치는 완전히 비게 되어 하나의 커다란 연속적인 가용공간이 된다.
    - 그런 후에 이 공간으로부터 할당받으면서 파일들을 원래의 장치로 다시 복사하게 된다.
    - 이 기법은 효과적으로 모든 가용 공간을 하나의 연속공간으로 **밀집**함으로써 해결한다.

</br>

- 그러나, 대용량 저장장치의 경우에 이 밀집에 드는 시간과 비용이 매우 많이 들 수 있다.
    - 일부 시스템에서는 이러한 작업을 파일 시스템의 마운트를 해제한 상태로 **오프라인** 시점에 처리한다.

</br>

> **연속 할당의 또 다른 문제점**
> 
→ ***파일을 위해서 얼마나 많은 공간을 주어야 할 지를 결정하는 것***

- 만약 너무 작은 공간을 예약했다면 파일이 커질 수 없다.
    - 특히 최적 적합 방법으로 공간을 할당했다면, 양 끝에 인접한 공간이 모두 사용 중이기 때문에 파일을 그 자리에서 확장할 수 없다.

</br>

- 이에 대한 해결 방법으로는 두 가지 방법이 존재한다.
    - 확장이 안 될 경우 사용자에게 오류 메시지를 출력하고 프로그램을 종료시키는 방법
    - 보다 큰 조각을 찾아 그곳으로 파일을 복사하고 이전의 공간을 비우는 방법

</br>

→ 한 파일에 필요한 공간의 크기를 미리 알 수 있다 해도, **선 할당은 비효율적이다!**

- 이런 단점들을 최소화하기 위해서, 운영체제는 어느 정도의 연속된 공간만 초기에 할당하고 그 양이 충분히 크지 않을 때는, 추후 `n` 개의 연속된 공간을 단위로 할당한다.

</br>

### 연결 할당

→ **연결 할당은 연속 할당의 모든 문제를 해결한다.**

<img width="294" alt="image" src="https://user-images.githubusercontent.com/106216912/227701229-860b152c-8b50-4a59-b523-c97e4555c741.png">

- 연결 할당의 경우 파일은 저장장치 블록의 연결 리스트 형태로 저장되고, 이 블록들은 장치 내에 흩어져 저장될 수 있다.
    - 디렉터리는 파일의 첫 번째와 마지막 블록에 대한 포인터를 가지고 있다.

</br>

> **새 파일을 생성하려면 단순히 디렉터리 내에 새로운 항목(entry)을 만든다.**
> 
- 연결 할당의 경우 각 디렉터리 항목은 파일의 첫 블록에 대한 포인터를 갖고 있다.
    - 이 포인터는 처음에는 빈 파일을 표시하기 위해 `null` 값으로 초기화된다.
    - 파일 쓰기가 일어나면 가용 블록을 할당받아 쓰기를 수행한 후, 파일의 끝에 연결한다.

</br>

- 또한, 연결 할당의 경우 외부 단편화가 없고 모든 블록은 크기가 같기 때문에 가용 공간 리스트의 어떠한 가용 블록들을 이용하여도 무방하다.
    - 파일 생성 시 생성할 파일의 크기가 미리 고정될 필요도 없다.

</br>

> **그러나, 이 방법도 단점을 가지고 있다.**
> 

→ ***순차적 접근 파일에만 효과적으로 사용될 수 있고, 직접 접근 방식에는 매우 비효율적이다.***

- `i` 번째 블록을 찾으려면, 그 파일의 첫 블록 한 번의 저장장치 읽기와 때로는 HDD 탐색이 필요하다.
    - 따라서, 연결 할당 파일에 대한 직접 접근은 대단히 비효율적이다.
- 또 다른 단점은, 포인터들을 위한 공간이 필요하다는 것이다.

</br>

> **이 문제에 대한 일반적인 해결책은, 블록을 모아 클러스터라고 하는 단위로 만들고 블록이 아닌 클러스터를 할당하는 것이다.**
> 
- 이 방법을 사용하면 논리적-물리적 블록 매핑을 간단하게 유지할 수 있다.
    - 하지만, 디스크 헤드 탐색이 줄어들기 때문에 HDD 처리량이 향상되고 블록 할당 및 가용 리스트 관리에 필요한 공간이 줄어든다.

</br>

> **또 다른 문제는 신뢰성의 문제이다.**
> 
- 각 블록이 전체 장치에 흩어져 연결되기 때문에, 오류나 하드웨어의 고장으로 인하여 하나의 포인터를 잃어버리거나 잘못된 포인터 값을 가지게 되면 모든 데이터를 잃을 수 있다.
    - 이 경우, 이중 연결 리스트를 사용하거나 블록마다 파일 이름과 상대 블록 번호 등을 저장하여 해결할 수 있다.
        - 하지만, 이러한 기법들은 더 많은 부담을 필요로 한다.

</br>

> **한 가지 중요한 변형은 파일 할당 테이블(FAT)를 사용하는 것이다.**
> 

→ ***단순하지만 효율적인 이 방법은 MS-DOS 운영체제에서 사용된다.***

<img width="340" alt="image" src="https://user-images.githubusercontent.com/106216912/227701280-ab9a5e60-61a3-41c0-a9db-45961f15f2a6.png">

- 각 파티션의 시작 부분이 FAT로 사용된다.
    - 이 FAT 테이블은 각 블록마다 한 개의 항목을 가지고 있고, 이 항목은 디스크 블록 번호를 인덱스로 갖는다.
    - 디렉터리의 항목은 각 파일의 첫 번째 블록 번호를 가리킨다.
    - 그 블록 번호를 가지고 FAT 테이블로 가면 그 항목은 다음 블록의 블록 번호를 가리킨다.
    - 이러한 사슬은 마지막 블록까지 계속되며, 마지막 블록의 테이블 항은 파일의 끝을 나타내는 특수한 값을 갖고 있다.

</br>

> **FAT 할당 기법은 FAT가 캐시 되지 않으면 상당한 수의 디스크 찾기를 유발할 수 있다.**
> 
- FAT를 읽기 위해 디스크 헤드를 반드시 파티션의 시작 부분으로 움직여, 찾고자 하는 블록의 주소를 알아내야 한다.
    - 이어서, 그 블록이 있는 곳으로 다시 이동해야 한다.
    - 최악의 경우, 각 블록을 찾을 때마다 두 번의 이동이 일어나야 한다.

</br>

### 색인 할당

→ ***색인 할당은 모든 포인터들을 하나의 장소, 즉 색인 블록으로 관리함으로써 문제들을 해결한다.***

<img width="338" alt="image" src="https://user-images.githubusercontent.com/106216912/227701344-ce137a46-b9b6-4a31-934a-8eaccef25404.png">

- 각 파일은 저장장치 블록 주소를 모아 놓은 배열인 **색인(index)** 블록을 가진다.
    - 색인 블록의 `i` 번째 항목은 파일의 `i` 번째 블록을 가리킨다.
    - 디렉터리는 색인 블록의 주소를 가지고 있다.
    - `i` 번째 블록을 읽기 위해서는 색인 블록 항목에 있는 `i` 번째 항목에서 포인터를 얻어서 그 블록을 읽는다.

</br>

> **저장장치의 어느 블록이든 더 많은 공간의 요청을 만족시킬 수 있기 때문에 색인 할당은 외부 단편화 없이 직접 접근을 지원한다.**
> 
- 그러나, 색인 할당은 공간 낭비로 인한 어려움을 겪는다.
    - 색인 블록의 포인터 오버헤드는 일반적으로 연결 할당의 포인터 오버헤드보다 크다.
    - 색인 할당을 사용하면 하나 또는 두 개의 포인터만 `null` 이 아니어도 전체 색인 블록을 할당해야 한다.

</br>

> **색인 블록이 너무 작으면, 큰 파일에 대한 충분한 포인터를 보유할 수 없다!**
> 

→ ***그러므로, 이 문제를 처리하는 기법이 제공되어야 한다.***

- **연결 기법**
    - 하나의 색인 블록은 통상 한 저장장치 블록이다.
    - 파일의 크기가 크면 여러 개의 색인 블록을 연결한다.

</br>

- **다중 수준 색인**
    - 연결 기법의 변형으로서 여러 개의 두 번째 수준 색인 블록들의 집합을 가리키기 위하여 첫 번째 수준의 색인 블록을 사용한다.
    - 두 번째 수준의 색인 블록은 실제 파일 블록들을 가리킨다.

</br>

<img width="382" alt="image" src="https://user-images.githubusercontent.com/106216912/227701389-bfc4ded9-a689-4d32-b1b0-4a51a2f1d3f0.png">

- **결합 기법**
    - `inode` 에 색인 블록의 15개 포인터를 유지한다.
    - 이 포인터들의 처음 12개는 직접 블록을 가리키는데, 이 포인터들은 파일의 데이터를 저장하고 있는 블록들의 주소를 저장한다.
    - 따라서, 크기가 작은 파일의 경우 추가의 색인 블록이 필요 없다.

    - 다음의 3개의 포인터는 간접 블록을 가리키는 포인터이다.
    - 첫 번째 포인터는 **단일 간접 블록**, 두 번째 포인터는 **이중 간접 블록**, 세 번째 포인터는 **삼중 간접 블록**을 가리킨다.

</br>

→ 색인 할당 기법은 연결 할당과 동일한 성능 문제를 갖는다.

- 특히 색인 블록은 메모리에 캐시될 수 있지만, 데이터 블록은 전체 볼륨 파티션 전체에 널리 퍼져 있을 수 있다.

</br>

### 성능

→ ***연결 할당의 경우, 다음 블록의 주소를 메모리에 유지하고 직접 읽을 수 있다.***

- 이 방법은 순차적 액세스에 적합하다.
    - 직접 액세스의 경우 `i` 번째 블록에 액세스 하려면 `i` 번의 블록 읽기가 필요할 수 있다.

</br>

> **몇몇 시스템들은 연속 할당을 사용하여 직접 접근 파일을, 연결 할당을 사용하여 순차 접근 파일을 모두 지원한다.**
> 
- 이들 시스템에서는 파일이 생성될 때 접근 형태가 먼저 선언되어야 한다.
    - 순차 접근을 위해서 생성된 파일은 연결 할당되며, 직접 접근을 위해서는 사용될 수 없다.

</br>

> **색인 할당의 경우는 더 복잡하다.**
> 
- 색인 블록이 메모리 내에 상주한다면 직접 접근이 가능하다.
    - 그러나, 메모리 내에 색인 블록을 전부 상주시키는 것은 많은 양의 메모리를 필요로 한다.
    - 만약 이 메모리 공간을 사용할 수 없다면 먼저 색인 블록을 읽은 후 원하는 자료 블록을 읽어야 한다.

</br>

> **일부 시스템은 연속 할당과 색인 할당을 결합하여 작은 파일은 연속 할당하고, 파일이 더 커지면 자동으로 색인 할당으로 전환한다.**
> 
- 대부분의 파일이 작고 연속 할당이 작은 파일의 경우 효율적이기 때문에 평균 성능이 상당히 좋아진다.

---