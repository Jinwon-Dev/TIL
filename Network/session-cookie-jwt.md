> **쿠키, 세션, JWT? </br>
→ 웹 어플리케이션에서 사용자 인증과 같은 보안적인 작업을 수행하는 데 사용되는 세 가지 메커니즘이다.**

</br>

## Session / Cookie 방식

</br>

### 개념

> ***쿠키***
> 
- 클라이언트(브라우저)에 저장되는 키-값 쌍의 작은 데이터 파일이다.
- 서버가 사용자의 웹 브라우저에게 전송하여 클라이언트 측에 저장하고 필요할 때마다 서버로 전송하는 방식으로 사용된다.

</br>

> ***세션***
> 
- 쿠키와 마찬가지로 클라이언트와 서버 간 상호작용을 위해 사용되며, 쿠키와 달리 서버 측에서 관리된다.
- 클라이언트가 서버에 접속하면 서버는 세션 ID를 생성하고, 클라이언트에게 전달한다.
- 이후 클라이언트는 세션 ID를 쿠키에 저장해두고, 서버와 상호작용할 때마다 세션 ID를 전달한다.

</br>

</br>

### 동작 과정

<img width="635" alt="image" src="https://user-images.githubusercontent.com/106216912/226191853-81bfbe64-285b-4b56-8f71-93209f7a512f.png">

1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 사용자를 확인한다.
3. 서버는 사용자의 고유한 ID 값을 부여하여, 세션 저장소와 연결한다.
4. 해당하는 세션 ID를 발행하고, 서버는 응답으로 사용자에게 보내준다.
5. 사용자는 서버에서 해당 세션 ID를 받아 쿠키에 저장을 하게 된다.
6. 그 후, 인증이 필요한 요청마다 쿠키를 헤더에 실어 보낸다.
7. 서버에서는 쿠키를 사용자로부터 받아 세션 저장소에서 대조를 한다.
8. 그 후, 세션 저장소로부터 대응되는 정보를 가져온다.
9. 인증이 완료되고, 서버는 사용자에게 맞는 데이터를 응답한다.

</br>

> **세션을 사용하는 이유?**
> 
- 결과적으로는, ***인증의 책임을 서버가 지게하기 위해*** 세션을 사용한다.
    - 사용자는 쿠키를 이용하고, 서버에서는 쿠키를 받아 세션의 정보를 접근하는 방식으로 인증을 한다.

</br>

</br>

### 장단점

> **장점**
> 
1. 쿠키를 매개로 인증을 거치는데, 쿠키는 단순히 세션 저장소에 담긴 유저 정보를 얻기 위한 열쇠이다.
    - 따라서, 쿠키가 담긴 HTTP 요청이 중간에 노출되더라도, 쿠키 자체(세션 ID)는 유의미한 값을 갖고 있지 않기 때문에 안전하다.

</br>

2. 사용자마다 고유의 ID 값을 발급받게 된다.
    - 서버에서는 쿠키 값을 받았을 때 일일이 회원정보를 확인할 필요 없이, ***바로 어떤 회원인지를 확인할 수 있어서 편리***하다.

</br>

> **단점**
> 
1. 만일 쿠키가 담긴 HTTP 요청을 해커가 가로채면, 그 안에 들어있는 쿠키도 충분히 훔칠 수 있다.
    - 따라서, **해커는 그 훔친 쿠키를 이용해 HTTP 요청을 보내서 세션 저장소에서 사용자의 정보를 가져올 수 있다**(세션 하이재킹 공격).

</br>

→ **해결책** 

1. ***HTTPS***를 사용해서 요청 자체를 탈취해도 안의 정보를 읽기 힘들게 한다.
2. 세션에 ***유효시간***을 넣어주어서, 시간이 지나면 만료되게 한다.

---

## JWT

</br>

### 개념

> ***JWT***
> 
- JSON Web Token의 약자로, 웹 표준으로 지정된 토큰 기반의 인증 방식이다.
- 사용자 정보를 담고 있는 JSON 객체를 서버에서 생성하여 클라이언트에게 전달하고, 이후 사용자 인증이 필요한 API를 호출할 때마다 JWT를 함께 전송하여 인증을 수행한다.

</br>

</br>

### JWT의 구조

- ***Header*** : Header, Payload, Verify Signature을 암호화할 방식, 타입 등이 들어간다.
- ***Payload*** : 서버에서 보낼 데이터가 들어간다.
    - 일반적으로 유저의 고유 ID 값, 유효 기간이 들어간다.
- ***Verify Signature*** : Base64 방식으로 인코딩한 Header, Payload, Secret Key를 더한 후 서명된다.

</br>

> **암호화, 복호화 여부**
> 
- ***Header, Payload는 인코딩될 뿐, 따로 암호화되지 않는다.***
    - 따라서, JWT 토큰에서 헤더와 페이로드는 누구나 디코딩하여 확인할 수 있다.

- ***Verify Signature은 Secret Key를 알지 못하면 복호화할 수 없다.***
    - ex) 어떤 사용자가 토큰을 조작해서 A 사용자의 데이터를 훔치려고한다.
    - 그래서 Payload에 있던 A의 ID를 자신의 ID로 바꿔서 다시 인코딩한 후, 토큰을 서버로 보낸다.
    - 그러면, 서버는 처음에 암호화된 Verify Signature를 검사하게 된다.
    - 여기서 Payload는 조작된 사용자의 정보가 들어가 있으나, Verify Signature는 A의 Payload를 기반으로 암호화 되었기 때문에, 유효하지 않는 토큰으로 간주된다.
    - **따라서, Secret Key를 알지 못하는 이상 토큰을 조작할 수 없다!**

</br>

</br>

### 동작 과정

<img width="628" alt="image" src="https://user-images.githubusercontent.com/106216912/226191993-81abc878-e4dc-47c6-96b4-1dc9eeeb2fcd.png">

1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어서 사용자를 확인한다.
    - 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣는다.
3. JWT 토큰의 유효 기간을 설정하고, 암호화할 Secret Key를 이용해 Access Token을 발급한다.
4. 서버는 Access Token을 응답으로 보내주고, 사용자는 받아서 저장한다.
5. 그 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
6. 서버에서는 해당 토큰의 Verify Signature를 Secret Key로 복호화한 후, 조작 여부, 유효 기간을 확인한다.
7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

</br>

</br>

### 장단점

> **장점**
> 
1. 간편하다.
    - 세션/쿠키 방식은 별도의 저장소 관리가 필요하지만, ***JWT는 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없다.***

</br>

2. ***확장성***이 뛰어나다.
    - 토큰 기반으로 하는 다른 인증 시스템에 접근이 가능하다.
    - ex) Facebook 로그인, Google 로그인

> **단점**
> 
1. 이미 발급된 JWT에 대해서는 돌이킬 수 없다.
    - 세션/쿠키의 경우 쿠키가 악의적으로 이용된다면, 해당하는 세션을 지워버리면 된다.
    - 하지만 **JWT는 한 번 발급 되면 유효기간이 완료될 때 까지 사용이 가능하다.**

</br>

→ **해결책**

- 기존의 Access Token의 유효기간을 짧게 하고, ***Refresh Token***이라는 새로운 토큰을 발급한다.
    - 그렇게 되면 Access Token을 탈취당해도 피해를 줄일 수 있다.

</br>

2. **Payload 정보가 제한적**이다.
    - Payload는 따로 암호화되지 않기 때문에, 디코딩하면 누구나 정보를 확인할 수 있다.
    - 따라서, 유저의 중요한 정보들은 Payload에 넣을 수 없다.

</br>

3. JWT의 길이는 세션/쿠키 방식에 비해 길다.
    - 따라서, **인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생**한다.

---

## Refresh Token

> **Refresh Token </br>
→ Access Token과 똑같은 형태의 JWT로, 처음에 로그인을 완료했을 때 Access Token과 동시에 발급된다.**

- ***긴 유효기간을 가지면서, Access Token이 만료됐을 때 새로 발급해주는 열쇠***가 된다.
    - Refresh Token의 유효기간이 만료되었다면, 사용자는 새로 로그인 해야 한다.

</br>

</br>

### 동작 과정

<img width="630" alt="image" src="https://user-images.githubusercontent.com/106216912/226192179-a68cae08-ddac-4c0c-b472-aef18f034483.png">

1. 사용자가 ID, PW를 통해 로그인한다.
2. 서버에서는 회원 DB에서 값을 비교한다.
3. 로그인이 완료되면 Access Token, Refresh Token을 발급한다.
    - 이 때, 일반적으로는 회원 DB에 Refresh Token을 저장해둔다.
4. 발급받은 Access Token, Refresh Token을 응답으로 사용자가 받고, Refresh Token은 안전한 저장소에 저장한다.
5. 사용자는 Access Token을 헤더에 실어 요청을 보낸다.
6. 서버는 Access Token을 검증한다.
7. 그 후, 이에 맞는 데이터를 보내준다.
8. 이 때, Access Token이 만료되었다고 가정하면,
9. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보낸다.
10. 서버는 Access Token이 만료되었음을 확인한다.
    - 프론드엔드 단에서 Access Token의 Payload를 통해 유효기간을 알 수 있으므로, 프론트 엔드 단에서 API 요청 전에 토큰이 만료되었다면 바로 재발급 요청을 할 수도 있다.
11. 그 후, 응답으로 권한이 없음을 사용자에게 보낸다.
12. 사용자는 Refresh Token과 Access Token을 함께 서버로 보낸다.
13. 서버는 받은 Access Token의 조작 여부를 확인 후, 받은 Refresh Token과 회원 DB에 저장되어 있던 Refresh Token을 비교하고, 새로운 Access Token을 발급해준다.
14. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청을 진행한다.

</br>

</br>

### 장단점

> **장점**
> 
1. 기존의 Access Token만 있을 때보다 ***안전***하다.

</br>

> **단점**
> 
1. 구현이 복잡하다.

</br>

2. Access Token이 만료될 때마다 새롭게 발급하는 과정에서 생기는 HTTP 요청 회수가 많다.
    - 서버의 자원 낭비가 될 수 있다.
