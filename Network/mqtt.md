# MQTT

</br>

## MQTT란?
- 저 대역폭 환경에서 M2M(machine to machine) 원격 측정을 위해 설계된 경량 **발행/구독 메시징 프로토콜**이다.
- **발행/구독 패턴**을 사용한다.
- **저전력**이 필수인 사물 인터넷 환경에서 낮은 전력, 낮은 대역폭 환경에서도 사용할 수 있도록 설계되었다.

</br>

## MQTT의 특징은?
- 실시간 푸시 전송이 가능하고, **전력사용을 최소화**할 수 있다.
- 80~100kb 정도의 메시지 크기를 갖고 있어, **경량화**가 되어 있고 오버헤드를 최소화 시킬 수 있다.
- 응용 코드의 변경 없이 **유연하게 기능을 확장**할 수 있다.
- 간단한 개념으로 개발자의 학습이 용이하다.
- 소형 기기의 제어와 센서 정보 수집(IoT)에 유리하다.

</br>

## 발행/구독 모델이란?
<img width="636" alt="image" src="https://user-images.githubusercontent.com/106216912/206202334-0aa03e0c-16cd-4696-9bce-d5a9932da2f3.png">

- **메시지를 수신하는 클라이언트와 메시지를 송신하는 클라이언트를 분리하는 방식**이다.
- 메시지를 전송하는 클라이언트를 **발행자(publisher)**, 메시지를 수신하는 클라이언트를 **구독자(subscriber)** 라고 한다.
- 중간에 위치한 **브로커(broker)** 가 중심적인 역할을 한다.
    - 메시지를 구독 중인 클라이언트로 전달해준다.

</br>

> 그렇다면 MQTT를 사용하는 이유는?
1. **MQTT를 사용하면 발행자와 구독자를 분리할 수 있다.**
    - 브로커가 중간에 위치하여 메시지를 전달해 주기 때문에, 발행자와 구독자(소비자)는 서로를 직접 알 필요가 없다!
    - 물리적으로 알 수 없거나, 유동적인 IoT 배포에 유용하다.

</br>

2. **MQTT는 데이터 형식에 구애 받지 않는다.**
    - 거의 모든 유형의 데이터를 페이로드에 실을 수 있다.
    - 텍스트 메시지, 이미지 데이터, 오디오, JSON 객체 등 거의 모든 구조의 전송이 가능하다.

</br>

3. **저전력화가 가능하여 IoT 부문에서 사용하기 유리하다.**
    - 저전력이 필수인 사물 인터넷에서 MQTT는 필수적인 프로토콜이다.

</br>

## MQTT 서비스 품질(QoS)
- MQTT는 **서비스 품질 레벨에 따라서 데이터 송수신에 특정 수준의 성능을 보장**해준다.
    - Level 0 (At most once)
        - 메시지는 **한 번만** 전달된다.
    - Level 1 (At least once)
        - 메시지는 **최소 한 번은** 전달된다.
    - Level 2 (Exactly once)
        - 메시지는 **반드시 한 번** 전달된다.

</br>

> 이렇게만 들으면 이해가 가지 않는다. 그림을 통해 살펴보자!

</br>

### Level 0 (At most once)
<img width="500" alt="image" src="https://user-images.githubusercontent.com/106216912/206206509-93a492c8-dbed-4450-9f88-9b05df5085b1.png">

- 최소 수준의 QoS로, **Fire and Forget** 모델을 사용한다.
    - 메시지를 보내고 바로 잊어버리므로 sleep을 통한 저전력이 가능하다.
- 메시지는 **한 번만 전달되고, 전달 여부는 확인하지 않는다.**
    - 메시지 확인 응답을 하는 수신자나, 전송을 재시도하는 송신자가 없다.

</br>

### Level 1 (At least once)
<img width="500" alt="image" src="https://user-images.githubusercontent.com/106216912/206207381-8ba4e1f1-e1b4-4baa-84f2-5ef78efcf91b.png">

- 메시지는 **최소 한 번은** 전달된다.
    - 연결 여부를 확인하지 않고, 메시지를 남긴다.
- 메시지를 성공적으로 전달하면 **Broker가 Publisher에게 PUBACK을 보내서 성공을 알린다.**
- 정상적인 통신이 이루어지지 않아서 PUBACK을 받지 못하면, **Publisher는 일정 시간이 지난 후 실패로 알고 메시지를 재송신**한다.
    - 따라서 Subscriber에게 중복으로 메시지를 보내는 경우도 있다.

</br>

### Level 2 (Exactly once)
<img width="500" alt="image" src="https://user-images.githubusercontent.com/106216912/206208049-59f5d0a5-152f-4a10-ba47-cd3ffed3efa7.png">

- 가장 높은 수준의 QoS로, 메시지는 **반드시 한 번만 전달**된다.
- PUBACK 과정을 PUBREC으로 핸드 셰이킹을 함으로써 **메시지가 정확히 한 번만 간다.**
- PUBREC을 전달 받지 못하더라도, **Broker는 이미 보냈다는 사실을 알기 때문에 메시지를 재송신 하지 않는다.**

</br>

> 서비스 레벨이 올라갈 수록 비용은 n배가 되므로 비용을 고려하여 적절한 QoS 레벨을 선택해야 한다!

</br>

## MQTT Topics

### Topic이란?
- **Broker가 연결된 각 클라이언트의 메시지를 필터링하는 데 사용하는 문자열**이다.
    - 하나 이상의 topic 레벨로 구성되고, `/` 로 구분된다.
    - Topic이 너무 길면 데이터의 양이 많아진다.
    - 와일드 카드를 사용하려고 토픽을 `/`로 구분한다.

</br>

### 와일드 카드란?
- 클라이언트는 와일드 카드를 사용하여 **여러 Topic을 동시에 구독**할 수 있다.
- 와일드 카드는 **발행할 때는 사용할 수 없고, Topic을 구독하는 데만 사용**할 수 있다.
    - 싱글 레벨 와일드 카드 : `+`
    - 다중 레벨 와일드 카드 : `#`

</br>

> 싱글 레벨 와일드 카드 : `+`

<img width="509" alt="image" src="https://user-images.githubusercontent.com/106216912/206210532-ffa1b9d4-513f-4834-a649-b0c5f5a4889d.png">

- 와일드 카드 대신 **임의의 어느 문자열이 들어와도 가능**하다.
- `+` 대신에 들어오는 문자열의 메시지를 수신한다.

</br>

> 다중 레벨 와일드 카드 : `+`

<img width="509" alt="image" src="https://user-images.githubusercontent.com/106216912/206210995-bcf6c23f-143c-41f5-a6c4-3aa3f5086379.png">

- 주제의 길이나 깊이에 상관 없이 **와일드 카드 문자 이전의 패턴으로 시작하는 Topic의 모든 메시지를 수신**한다.
- 다중 레벨 와일드 카드는 **마지막에만** 올 수 있다.
- 많은 정보가 들어오기 때문에 **구분해 주는 비용이 추가로 필요**하다.
    - 단순한 클라이언트 보다는 보다 많은 데이터를 수집하는 경우에 사용한다.

</br>

> `+` 는 각 자리에 무엇이 오는지 정확하게 알고 사용하지만, `#` 는 그렇지 않고 모두 받기 때문에 편리하지만 처리하기 보다 까다롭다.